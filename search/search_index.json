{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to XLRON's documentation!","text":"<p>XLRON (\"ex-el-er-on\") is an open-source research project that provides a suite of gym-style environments for simulating resource allocation problems in optical networks and applying reinforcement learning techniques. It is built on the JAX numerical computing framework, enabling accelerated training on GPU and TPU hardware.</p> <p>XLRON is a product of my PhD research, which is focused on the application of Reinforcement Learning (RL) to a set of combinatorial optimisation problems that occur in resource allocation for in optical networks. The project is currently in active development.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Gym-style environments for optical network resource allocation problems (RWA, RSA, RMSA, RWA-LR, VONE, ...)</li> <li>Powered by JAX for accelerated training on GPU and TPU</li> <li>Command-line interface for running experiments with customisable hyperparameters</li> <li>Advanced deep learning architectures (GNN, GAT) and physical layer models (ISRS GN model).</li> <li>Implementations of heuristics (KSP-FF, etc.) for benchmarking and comparison.</li> <li>Ideal for research and innovation in optical network optimization.</li> </ul>"},{"location":"#understanding-xlron","title":"\ud83e\udde0 Understanding XLRON \ud83e\udde0","text":"<p>Check out this page to get a deeper understanding of XLRON's architecture and how it works.</p> <p>XLRON is faster than CPU-based training because of the following factors:</p> <p></p> <ul> <li>End-to-end JAX implementation (both environment and RL algorithm) allows entire training loop to be compiled and optimised as a single program</li> <li>GPU-compatiblity allows parallelisation to make maximum use of accelerator hardware (GPU or TPU)</li> <li>Running entirely on GPU avoids CPU-GPU data transfer bottleneck and eliminates any overhead from Python interpreter</li> </ul> <p>To further understand the architecture of XLRON and how it allows distributed training for multiple environments across multiple devices and even for multiple learners (neural network parameters), take a look at the below diagram:</p> <p></p>"},{"location":"#speed-benchmarks","title":"\ud83c\udfce\ufe0f Speed Benchmarks \ud83c\udfce\ufe0f","text":""},{"location":"#tldr-expect-approximately-500x-speed-up","title":"tldr: Expect approximately 500x speed-up! \ud83d\ude80","text":"<p>For the comparisons shown, the CPU is 10-core Apple M1 Pro and the GPU is Nvidia A100.</p>"},{"location":"#case-study-1","title":"Case study 1","text":"<p>To fairly assess the speed-up offered by XLRON, we implement a \"DeepRMSA\" environment and agent (exactly like in the canonical DeepRMSA paper) and compare with the equivalent example from optical-rl-gym, which uses stables_baselines3 (SB3) for training.</p> <p>The below figure shows the training curves for both implementations, with 250 or 2000 parallel envs shown for XLRON. Shaded areas indicate the standard deviation of values across environments (each with a unique random seed) for XLRON and across 3 random seeds for SB3. The left figure shows the training progression with episode count, the right figure shows training progression with time on a log scale.</p> <p></p> <p>Increasing the number of parallel environments decreases the time required to train on a given number of environment steps, but changes the training dynamics so hyperparameters should be tuned accordingly for different numbers of parallel environments.</p>"},{"location":"#case-study-2","title":"Case study 2","text":"<p>For the virtual optical network embedding problem, XLRON is compared with the environments from an ECOC 2023 paper (publication pending). The below figure compares the time it takes to train on 1M environment steps for two different topologies (NSFNET or CONUS) and either 100 or 320 frequency slot units (FSU) per link.</p> <p>There are 4 horizontal bars per experiment:</p> <ul> <li>sb3 training with 1 vectorised environment on CPU</li> <li>sb3 training with 10 vectorised environments on CPU</li> <li>XLRON training with 1 vectorised environment on CPU</li> <li>XLRON training with 2000 vectorised environments on GPU</li> </ul> <p>Experiment names on y-axis follow the naming convention: topology name (NSFNET or CONUS) - number of FSU per link - JAX or numpy environment - device type - number of vectorised environments.</p> <p></p>"},{"location":"#compilation-times","title":"Compilation times","text":"<p>See below figure for compilation times of different environments. Compilation typically takes a few seconds, therefore adds very little overhead to the training process.</p> <p></p>"},{"location":"#related-work","title":"Related work","text":"<p>The gym-style environments follow the example set in Gymnax</p> <p>The PPO implementation in this project derives from the excellent PureJaxRL</p> <p>Multi-device support takes inspiration from Stoix</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This work was supported by the Engineering and Physical Sciences Research Council (EPSRC) grant EP/S022139/1 - the Centre for Doctoral Training in Connected Electronic and Photonic Systems - and EPSRC Programme Grant TRANSNET (EP/R035342/1)</p>"},{"location":"#contact","title":"Contact","text":"<p>If you have any questions or comments, please feel free to contact me at michael.doherty.21@ucl.ac.uk</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"flags_reference/","title":"Command-line Options","text":"<pre><code>xlron.train.parameter_flags:\n  --[no]ACTION_MASKING: Use invalid action masking\n    (default: 'false')\n  --ACTIVATION: Activation function\n    (default: 'tanh')\n  --ADAM_BETA1: Adam beta1\n    (default: '0.9')\n    (a number)\n  --ADAM_BETA2: Adam beta2\n    (default: '0.999')\n    (a number)\n  --ADAM_EPS: Adam epsilon\n    (default: '1e-05')\n    (a number)\n  --CLIP_EPS: PPO clipping parameter\n    (default: '0.2')\n    (a number)\n  --DATA_OUTPUT_FILE: Path to save data output\n  --[no]DEBUG: Debug mode\n    (default: 'false')\n  --[no]DEBUG_NANS: Debug NaNs\n    (default: 'false')\n  --[no]DISABLE_JIT: Disable JIT compilation\n    (default: 'false')\n  --DOWNSAMPLE_FACTOR: Downsample factor to reduce data uploaded to wandb\n    (default: '1')\n    (an integer)\n  --EMULATED_DEVICES: Number of devices to emulate\n    (an integer)\n  --[no]ENABLE_X64: Enable x64 floating point precision\n    (default: 'false')\n  --ENT_COEF: Entropy coefficient\n    (default: '0.0')\n    (a number)\n  --ENV_WARMUP_STEPS: Number of warmup steps before training or eval\n    (default: '0')\n    (an integer)\n  --[no]EVAL_HEURISTIC: Evaluate heuristic\n    (default: 'false')\n  --[no]EVAL_MODEL: Evaluate model\n    (default: 'false')\n  --EXPERIMENT_NAME: Name of experiment (equivalent to run name in wandb) (auto-generated based on other flags if unspecified)\n    (default: '')\n  --GAE_LAMBDA: GAE lambda parameter\n    (default: '0.95')\n    (a number)\n  --GAMMA: Discount factor\n    (default: '0.999')\n    (a number)\n  --[no]LAYER_NORM: Use layer normalization\n    (default: 'false')\n  --[no]LOAD_MODEL: Load model for retraining or evaluation\n    (default: 'false')\n  --LR: Learning rate\n    (default: '0.0005')\n    (a number)\n  --LR_SCHEDULE: Learning rate schedule\n    (default: 'warmup_cosine')\n  --MAX_GRAD_NORM: Maximum gradient norm\n    (default: '0.5')\n    (a number)\n  --MINIBATCH_SIZE: Minibatch size\n    (default: '1')\n    (an integer)\n  --MODEL_PATH: Path to save/load model\n  --[no]NO_PRINT_FLAGS: Do not print flags\n    (default: 'false')\n  --NUM_DEVICES: Number of devices\n    (default: '1')\n    (an integer)\n  --NUM_ENVS: Number of environments per device\n    (default: '1')\n    (an integer)\n  --NUM_LAYERS: Number of layers in actor and critic networks\n    (default: '2')\n    (an integer)\n  --NUM_LEARNERS: Number of independent learners i.e. how many independent experiments to run with a unique set of learned parameters each\n    (default: '1')\n    (an integer)\n  --NUM_MINIBATCHES: Number of minibatches per update\n    (default: '1')\n    (an integer)\n  --NUM_UNITS: Number of hidden units in actor and critic networks\n    (default: '64')\n    (an integer)\n  --NUM_UPDATES: Number of rollouts per environment\n    (default: '1')\n    (an integer)\n  --[no]ORDERED: Order print statements when debugging (must be false if using pmap)\n    (default: 'true')\n  --[no]PLOTTING: Plotting\n    (default: 'false')\n  --[no]PREALLOCATE_MEM: Preallocate GPU memory\n    (default: 'true')\n  --PREALLOCATE_MEM_FRACTION: Fraction of GPU memory to preallocate\n    (default: '0.95')\n  --[no]PRINT_MEMORY_USE: Print memory usage\n    (default: 'false')\n  --PROJECT: Name of project (same as experiment name if unspecified)\n    (default: '')\n  --ROLLOUT_LENGTH: Number of steps per rollout per environment\n    (default: '150')\n    (an integer)\n  --[no]SAVE_MODEL: Save model (will be saved to --MODEL_PATH locally and uploaded to wandb if --WANDB is True)\n    (default: 'false')\n  --SCHEDULE_MULTIPLIER: Increase the learning rate schedule horizon by this factor (to keep schedule for longer final training runs consistent with that from tuning runs)\n    (default: '1')\n    (an integer)\n  --SEED: Random seed\n    (default: '42')\n    (an integer)\n  --TOTAL_TIMESTEPS: Total number of timesteps\n    (default: '1000000.0')\n    (a number)\n  --UPDATE_EPOCHS: Number of epochs per update\n    (default: '10')\n    (an integer)\n  --[no]USE_GNN: Use GNN\n    (default: 'false')\n  --VF_COEF: Value function coefficient\n    (default: '0.5')\n    (a number)\n  --VISIBLE_DEVICES: Comma-separated indices of (desired) visible GPUs e.g. 1,2,3\n    (default: '0')\n  --[no]WANDB: Use wandb\n    (default: 'false')\n  --WARMUP_END_FRACTION: Fraction of init LR that is final LR\n    (default: '0.1')\n    (a number)\n  --WARMUP_PEAK_MULTIPLIER: Increase the learning rate warmup peak compared to init\n    (default: '1.0')\n    (a number)\n  --WARMUP_STEPS_FRACTION: Fraction of total timesteps to use for warmup\n    (default: '0.2')\n    (a number)\n  --aggregate_slots: Number of slots to aggregate into a single action\n    (default: '1')\n    (an integer)\n  --alpha: Fibre attenuation coefficient, alpha [dB/km]\n    (default: '0.2')\n    (a number)\n  --amplifier_noise_figure: Amplifier noise figure [dB]\n    (default: '4.5')\n    (a number)\n  --beta_2: Dispersion parameter [ps^2/km]\n    (default: '-21.7')\n    (a number)\n  --[no]continuous_operation: If True, do not reset the environment at the end of an episode\n    (default: 'false')\n  --custom_traffic_matrix_csv_filepath: Path to custom traffic matrix CSV file\n  --[no]deterministic: Deterministic evaluation (use mode of action distribution)\n    (default: 'false')\n  --[no]disjoint_paths: Use disjoint paths (k paths still considered)\n    (default: 'false')\n  --[no]end_first_blocking: End episode on first blocking event\n    (default: 'false')\n  --env_type: Environment type\n    (default: 'vone')\n  --gamma: Nonlinear coefficient\n    (default: '0.0012')\n    (a number)\n  --gnn_latent: GNN latent size\n    (default: '64')\n    (an integer)\n  --gnn_mlp_layers: Number of MLP layers\n    (default: '2')\n    (an integer)\n  --guardband: Guard band in slots\n    (default: '1')\n    (an integer)\n  --[no]incremental_loading: Incremental increase in traffic load (non-expiring requests)\n    (default: 'false')\n  --k: Number of paths\n    (default: '5')\n    (an integer)\n  --lambda0: Wavelength [nm]\n    (default: '1550.0')\n    (a number)\n  --link_resources: Number of link resources\n    (default: '5')\n    (an integer)\n  --load: Load\n    (default: '250.0')\n    (a number)\n  --[no]log_actions: Log actions taken and other details\n    (default: 'false')\n  --max_bw: Maximum requested bandwidth\n    (default: '100')\n    (an integer)\n  --max_node_resources: Maximum number of node resources\n    (default: '1')\n    (an integer)\n  --max_requests: Maximum number of requests in an episode\n    (default: '4.0')\n    (a number)\n  --max_timesteps: Maximum number of timesteps in an episode\n    (default: '30.0')\n    (a number)\n  --max_traffic: Maximum traffic\n    (default: '1.0')\n  --mean_service_holding_time: Mean service holding time\n    (default: '25.0')\n    (a number)\n  --message_passing_steps: Number of message passing steps\n    (default: '3')\n    (an integer)\n  --min_bw: Minimum requested bandwidth\n    (default: '25')\n    (an integer)\n  --min_node_resources: Minimum number of node resources\n    (default: '1')\n    (an integer)\n  --min_traffic: Minimum traffic\n    (default: '0.0')\n  --model: Used to hold model parameters\n    (a comma separated list)\n  --modulations_csv_filepath: Modulation format definitions for RSA environment\n    (default: './examples/modulations.csv')\n  --multiple_topologies_directory: Directory containing JSON definitions of network topologies that will be alternated per episode\n  --node_heuristic: Node heuristic to be evaluated\n    (default: 'random')\n  --node_probs: List of node probabilities for selection\n    (a comma separated list)\n  --node_resources: Number of node resources\n    (default: '4')\n    (an integer)\n  --[no]normalize_by_link_length: Normalize by link length\n    (default: 'false')\n  --output_edges_size: Output edges size (not used)\n    (default: '64')\n    (an integer)\n  --output_globals_size: Output globals size\n    (default: '64')\n    (an integer)\n  --output_nodes_size: Output nodes size\n    (default: '64')\n    (an integer)\n  --path_heuristic: Path heuristic to be evaluated\n    (default: 'ksp_ff')\n  --[no]random_traffic: Random traffic matrix for RSA on each reset (else uniform or custom)\n    (default: 'false')\n  --reward_type: Reward type\n    (default: 'service')\n  --scale_factor: Scale factor for link capacity (only used in RWA with lightpath reuse)\n    (default: '1.0')\n    (a number)\n  --slot_size: Spectral width of frequency slot in GHz\n    (default: '12.5')\n    (a number)\n  --span_length: Span length [km]\n    (default: '100.0')\n    (a number)\n  --step_bw: Step size for requested bandwidth values between min and max\n    (default: '1')\n    (an integer)\n  --step_traffic: Step size for traffic values between min and max\n    (default: '0.1')\n  --symbol_rate: Symbol rate [Gbaud]\n    (default: '100.0')\n    (a number)\n  --topology_directory: Directory containing JSON definitions of network topologies\n  --topology_name: Topology name\n    (default: '4node')\n  --traffic_requests_csv_filepath: Path to traffic request CSV file\n  --[no]truncate_holding_time: Truncate holding time to less than 2*mean_service_holding_time\n    (default: 'false')\n  --values_bw: List of requested bandwidth values\n    (a comma separated list)\n  --virtual_topologies: Virtual topologies\n    (default: '3_ring')\n    (a comma separated list)\n  --weight: Edge attribute name for ordering k-shortest paths\n\nabsl.flags:\n  --flagfile: Insert flag definitions from the given file into the command line.\n    (default: '')\n  --undefok: comma-separated list of flag names that it is okay to specify on the command line even if the program does not define a flag with that name.  IMPORTANT: flags in this list that have arguments MUST use the --flag=value\n    format.\n    (default: '')\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>XLRON is a research tool intended to be downloaded as a repository, not installed as a package. This offers greater flexibility to the user if they wish to modify or extend the codebase.</p> <p>It is recommended to use a virtual environment to manage dependencies.  Requirements are defined in pyproject.toml and can be installed with poetry. See quickstart for more details.</p>"},{"location":"license/","title":"License and Support","text":""},{"location":"license/#license","title":"License","text":"<p>Copyright (c) Michael Doherty 2023.  This project is licensed under the MIT License.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#setup-virtual-environment","title":"Setup virtual environment","text":"<p>We recommend using poetry to manage dependencies. To install poetry, run:</p> <pre><code>pip install poetry\n</code></pre> <p>Then, clone the repository and install the dependencies:</p> <pre><code>git clone\ncd XLRON\npoetry install\n</code></pre> <p>If you prefer, you can use requirements.txt (not recommended as it may not be up-to-date):</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>N.B. if you want to run on GPU or TPU, then you need to edit the <code>pyproject.toml</code> file to include the appropriate accelerator-specific dependencies, i.e. comment/uncomment the relevant lines below, then follow the steps above:</p> <pre><code>jax = {extras = [\"tpu\"], version = \"^0.4.11\"}  # for Google Cloud TPU\njax = {extras = [\"cuda11_pip\"], version = \"^0.4.11\"} # or cuda12_pip depending on drivers\njax = {extras = [\"cpu\"], version = \"^0.4.11\"}  # for CPU-only\n</code></pre>"},{"location":"quickstart/#running-experiments","title":"Running experiments","text":"<p>Every experiment in XLRON is defined through command-line options. No need to edit the source code. See configuration options for a full list of options.</p> <p>To run an experiment, use the <code>train.py</code> script. For example, to recreate the training of DeepRMSA:</p> <pre><code>poetry run python train.py --env_type=deeprmsa --env_type=deeprmsa --continuous_operation --load=250 --k=5 --topology_name=nsfnet_deeprmsa --link_resources=100 --max_requests=1e3 --max_timesteps=1e3 --mean_service_holding_time=25 --ROLLOUT_LENGTH=100 --continuous_operation --NUM_LAYERS 5 --NUM_UNITS 128 --NUM_ENVS 16 --TOTAL_TIMESTEPS 5000000 --ENV_WARMUP_STEPS 3000 --LR 5e-5 --WARMUP_PEAK_MULTIPLIER 2 --LR_SCHEDULE linear --UPDATE_EPOCHS 10 --GAE_LAMBDA 0.9 --GAMMA 0.95 --ACTION_MASKING\n</code></pre> <p>Launch power optimisation using closed-form GN model RMSA environment (experimental feature): <pre><code>poetry run python train.py --env_type=rsa_gn_model --PROJECT LAUNCH_POWER --ROLLOUT_LENGTH=50 --NUM_LAYERS 3 --NUM_UNITS 128 --load=100 --k=5 --weight=weight --topology_name=nsfnet_deeprmsa_directed --link_resources=115 --max_requests=10 --max_timesteps=10 --mean_service_holding_time=25 --continuous_operation --ENV_WARMUP_STEPS=0 --TOTAL_TIMESTEPS 20000 --NUM_ENVS 200 --launch_power_type=rl --interband_gap=100 --values_bw=400,600,800,1200 --guardband=0 --coherent --reward_type=bitrate --snr_margin=0.01 --slot_size=100 --max_power=3 --min_power=-1 --VISIBLE_DEVICES=1 --PLOTTING --DOWNSAMPLE_FACTOR=1 --LR 1e-4 --LR_SCHEDULE warmup_cosine --WARMUP_PEAK_MULTIPLIER 2 --GAE_LAMBDA 0.9 --GAMMA 0.9  --EVAL_MODEL --LOAD_MODEL --MODEL_PATH /home/XLRON/models/BEST_LP --WANDB --DATA_OUTPUT_FILE /home/XLRON/data/launch_power_train_out.csv\n</code></pre></p> <p>You can save models with <code>--SAVE_MODEL</code> to the directory specified by <code>--MODEL_PATH</code>. You can log data to Weights and Biases (see Understanding XLRON for more details) with <code>--WANDB</code>. You can also log episode end data to a CSV file with <code>--DATA_OUTPUT_FILE</code>.</p>"},{"location":"reference/","title":"Environments","text":""},{"location":"reference/#xlron.environments.EnvParams","title":"<code>EnvParams</code>","text":"<p>Dataclass to hold environment parameters. Parameters are immutable.</p> <p>Parameters:</p> Name Type Description Default <code>max_requests</code> <code>Scalar</code> <p>Maximum number of requests in an episode</p> required <code>incremental_loading</code> <code>Scalar</code> <p>Incremental increase in traffic load (non-expiring requests)</p> required <code>end_first_blocking</code> <code>Scalar</code> <p>End episode on first blocking event</p> required <code>continuous_operation</code> <code>Scalar</code> <p>If True, do not reset the environment at the end of an episode</p> required <code>edges</code> <code>Array</code> <p>Two column array defining source-dest node-pair edges of the graph</p> required <code>slot_size</code> <code>Scalar</code> <p>Spectral width of frequency slot in GHz</p> required <code>consider_modulation_format</code> <code>Scalar</code> <p>If True, consider modulation format to determine required slots</p> required <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>aggregate_slots</code> <code>Scalar</code> <p>Number of slots to aggregate into a single action (First-Fit with aggregation)</p> required <code>guardband</code> <code>Scalar</code> <p>Guard band in slots</p> required <code>directed_graph</code> <code>bool</code> <p>Whether graph is directed (one fibre per link per transmission direction)</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvParams:\n    \"\"\"Dataclass to hold environment parameters. Parameters are immutable.\n\n    Args:\n        max_requests (chex.Scalar): Maximum number of requests in an episode\n        incremental_loading (chex.Scalar): Incremental increase in traffic load (non-expiring requests)\n        end_first_blocking (chex.Scalar): End episode on first blocking event\n        continuous_operation (chex.Scalar): If True, do not reset the environment at the end of an episode\n        edges (chex.Array): Two column array defining source-dest node-pair edges of the graph\n        slot_size (chex.Scalar): Spectral width of frequency slot in GHz\n        consider_modulation_format (chex.Scalar): If True, consider modulation format to determine required slots\n        link_length_array (chex.Array): Array of link lengths\n        aggregate_slots (chex.Scalar): Number of slots to aggregate into a single action (First-Fit with aggregation)\n        guardband (chex.Scalar): Guard band in slots\n        directed_graph (bool): Whether graph is directed (one fibre per link per transmission direction)\n    \"\"\"\n    max_requests: chex.Scalar = struct.field(pytree_node=False)\n    incremental_loading: chex.Scalar = struct.field(pytree_node=False)\n    end_first_blocking: chex.Scalar = struct.field(pytree_node=False)\n    continuous_operation: chex.Scalar = struct.field(pytree_node=False)\n    edges: chex.Array = struct.field(pytree_node=False)\n    slot_size: chex.Scalar = struct.field(pytree_node=False)\n    consider_modulation_format: chex.Scalar = struct.field(pytree_node=False)\n    link_length_array: chex.Array = struct.field(pytree_node=False)\n    aggregate_slots: chex.Scalar = struct.field(pytree_node=False)\n    guardband: chex.Scalar = struct.field(pytree_node=False)\n    directed_graph: bool = struct.field(pytree_node=False)\n    maximise_throughput: bool = struct.field(pytree_node=False)\n    reward_type: str = struct.field(pytree_node=False)\n    values_bw: chex.Array = struct.field(pytree_node=False)\n    truncate_holding_time: bool = struct.field(pytree_node=False)\n    traffic_array: bool = struct.field(pytree_node=False)\n    pack_path_bits: bool = struct.field(pytree_node=False)\n    relative_arrival_times: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.EnvState","title":"<code>EnvState</code>","text":"<p>Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>current_time</code> <code>Scalar</code> <p>Current time in environment</p> required <code>holding_time</code> <code>Scalar</code> <p>Holding time of current request</p> required <code>total_timesteps</code> <code>Scalar</code> <p>Total timesteps in environment</p> required <code>total_requests</code> <code>Scalar</code> <p>Total requests in environment</p> required <code>graph</code> <code>GraphsTuple</code> <p>Graph tuple representing network state</p> required <code>full_link_slot_mask</code> <code>Array</code> <p>Action mask for link slot action (including if slot actions are aggregated)</p> required <code>accepted_services</code> <code>Array</code> <p>Number of accepted services</p> required <code>accepted_bitrate</code> <code>Array</code> <p>Accepted bitrate</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvState:\n    \"\"\"Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.\n\n    Args:\n        current_time (chex.Scalar): Current time in environment\n        holding_time (chex.Scalar): Holding time of current request\n        total_timesteps (chex.Scalar): Total timesteps in environment\n        total_requests (chex.Scalar): Total requests in environment\n        graph (jraph.GraphsTuple): Graph tuple representing network state\n        full_link_slot_mask (chex.Array): Action mask for link slot action (including if slot actions are aggregated)\n        accepted_services (chex.Array): Number of accepted services\n        accepted_bitrate (chex.Array): Accepted bitrate\n        \"\"\"\n    current_time: chex.Scalar\n    holding_time: chex.Scalar\n    arrival_time: chex.Scalar\n    total_timesteps: chex.Scalar\n    total_requests: chex.Scalar\n    graph: jraph.GraphsTuple\n    full_link_slot_mask: chex.Array\n    accepted_services: chex.Array\n    accepted_bitrate: chex.Array\n    total_bitrate: chex.Array\n    list_of_requests: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnv","title":"<code>RMSAGNModelEnv</code>","text":"<p>               Bases: <code>RSAEnv</code></p> <p>RMSA + GNN model environment.</p> Source code in <code>xlron/environments/gn_model/rmsa_gn_model.py</code> <pre><code>class RMSAGNModelEnv(RSAEnv):\n    \"\"\"RMSA + GNN model environment.\"\"\"\n    def __init__(\n            self,\n            key: chex.PRNGKey,\n            params: RSAGNModelEnvParams,\n            traffic_matrix: chex.Array = None,\n            launch_power_array: chex.Array = None,\n            list_of_requests: chex.Array = None,\n            laplacian_matrix: chex.Array = None,\n    ):\n        \"\"\"Initialise the environment state and set as initial state.\n\n        Args:\n            key: PRNG key\n            params: Environment parameters\n            traffic_matrix (optional): Traffic matrix\n            launch_power_array (optional): Launch power array\n\n        Returns:\n            None\n        \"\"\"\n        super().__init__(key, params, traffic_matrix=traffic_matrix, list_of_requests=list_of_requests, laplacian_matrix=laplacian_matrix)\n        state = RMSAGNModelEnvState(\n            current_time=0,\n            arrival_time=0,\n            holding_time=0,\n            total_timesteps=0,\n            total_requests=-1,\n            link_slot_array=init_link_slot_array(params),\n            link_slot_departure_array=init_link_slot_departure_array(params),\n            request_array=init_rsa_request_array(),\n            link_slot_mask=init_link_slot_mask(params, agg=params.aggregate_slots),\n            traffic_matrix=traffic_matrix if traffic_matrix is not None else init_traffic_matrix(key, params),\n            graph=None,\n            full_link_slot_mask=init_link_slot_mask(params),\n            accepted_services=0,\n            accepted_bitrate=0.,\n            total_bitrate=0.,\n            list_of_requests=list_of_requests,\n            link_snr_array=init_link_snr_array(params),\n            path_index_array=init_path_index_array(params),\n            path_index_array_prev=init_path_index_array(params),\n            channel_centre_bw_array=init_channel_centre_bw_array(params),\n            channel_power_array=init_channel_power_array(params),\n            modulation_format_index_array=init_modulation_format_index_array(params),\n            channel_centre_bw_array_prev=init_channel_centre_bw_array(params),\n            channel_power_array_prev=init_channel_power_array(params),\n            modulation_format_index_array_prev=init_modulation_format_index_array(params),\n            launch_power_array=launch_power_array,\n            mod_format_mask=init_mod_format_mask(params),\n        )\n        self.initial_state = state.replace(graph=init_graph_tuple(state, params, laplacian_matrix))\n\n    @partial(jax.jit, static_argnums=(0, 2,))\n    def action_mask(self, state: RSAEnvState, params: RSAEnvParams) -&gt; RSAEnvState:\n        \"\"\"Returns mask of valid actions.\n\n        Args:\n            state: Environment state\n            params: Environment parameters\n\n        Returns:\n            state: Environment state with action mask\n        \"\"\"\n        state = mask_slots_rmsa_gn_model(state, params, state.request_array)\n        return state\n\n    @partial(jax.jit, static_argnums=(0, 2,))\n    def get_obs(self, state: RMSAGNModelEnvState, params: RMSAGNModelEnvParams) -&gt; chex.Array:\n        return get_paths_obs_gn_model(state, params)\n\n    @staticmethod\n    def num_actions(params: RSAEnvParams) -&gt; int:\n        \"\"\"Number of actions possible in environment.\"\"\"\n        return 1\n\n    def observation_space(self, params: RSAEnvParams):\n        \"\"\"Observation space of the environment.\"\"\"\n        return spaces.Discrete(\n            3 +  # Request array\n            1 +  # Holding time\n            7 * params.k_paths\n            # Path stats:\n            # Mean free block size\n            # Free slots\n            # Path length (100 km)\n            # Path length (hops)\n            # Number of connections on path\n            # Mean power of connection on path\n            # Mean SNR of connection on path\n        )\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnv.__init__","title":"<code>__init__(key, params, traffic_matrix=None, launch_power_array=None, list_of_requests=None, laplacian_matrix=None)</code>","text":"<p>Initialise the environment state and set as initial state.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>PRNGKey</code> <p>PRNG key</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <code>traffic_matrix</code> <code>optional</code> <p>Traffic matrix</p> <code>None</code> <code>launch_power_array</code> <code>optional</code> <p>Launch power array</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>xlron/environments/gn_model/rmsa_gn_model.py</code> <pre><code>def __init__(\n        self,\n        key: chex.PRNGKey,\n        params: RSAGNModelEnvParams,\n        traffic_matrix: chex.Array = None,\n        launch_power_array: chex.Array = None,\n        list_of_requests: chex.Array = None,\n        laplacian_matrix: chex.Array = None,\n):\n    \"\"\"Initialise the environment state and set as initial state.\n\n    Args:\n        key: PRNG key\n        params: Environment parameters\n        traffic_matrix (optional): Traffic matrix\n        launch_power_array (optional): Launch power array\n\n    Returns:\n        None\n    \"\"\"\n    super().__init__(key, params, traffic_matrix=traffic_matrix, list_of_requests=list_of_requests, laplacian_matrix=laplacian_matrix)\n    state = RMSAGNModelEnvState(\n        current_time=0,\n        arrival_time=0,\n        holding_time=0,\n        total_timesteps=0,\n        total_requests=-1,\n        link_slot_array=init_link_slot_array(params),\n        link_slot_departure_array=init_link_slot_departure_array(params),\n        request_array=init_rsa_request_array(),\n        link_slot_mask=init_link_slot_mask(params, agg=params.aggregate_slots),\n        traffic_matrix=traffic_matrix if traffic_matrix is not None else init_traffic_matrix(key, params),\n        graph=None,\n        full_link_slot_mask=init_link_slot_mask(params),\n        accepted_services=0,\n        accepted_bitrate=0.,\n        total_bitrate=0.,\n        list_of_requests=list_of_requests,\n        link_snr_array=init_link_snr_array(params),\n        path_index_array=init_path_index_array(params),\n        path_index_array_prev=init_path_index_array(params),\n        channel_centre_bw_array=init_channel_centre_bw_array(params),\n        channel_power_array=init_channel_power_array(params),\n        modulation_format_index_array=init_modulation_format_index_array(params),\n        channel_centre_bw_array_prev=init_channel_centre_bw_array(params),\n        channel_power_array_prev=init_channel_power_array(params),\n        modulation_format_index_array_prev=init_modulation_format_index_array(params),\n        launch_power_array=launch_power_array,\n        mod_format_mask=init_mod_format_mask(params),\n    )\n    self.initial_state = state.replace(graph=init_graph_tuple(state, params, laplacian_matrix))\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnv.action_mask","title":"<code>action_mask(state, params)</code>","text":"<p>Returns mask of valid actions.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>RSAEnvState</code> <p>Environment state</p> required <code>params</code> <code>RSAEnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>RSAEnvState</code> <p>Environment state with action mask</p> Source code in <code>xlron/environments/gn_model/rmsa_gn_model.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 2,))\ndef action_mask(self, state: RSAEnvState, params: RSAEnvParams) -&gt; RSAEnvState:\n    \"\"\"Returns mask of valid actions.\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        state: Environment state with action mask\n    \"\"\"\n    state = mask_slots_rmsa_gn_model(state, params, state.request_array)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnv.num_actions","title":"<code>num_actions(params)</code>  <code>staticmethod</code>","text":"<p>Number of actions possible in environment.</p> Source code in <code>xlron/environments/gn_model/rmsa_gn_model.py</code> <pre><code>@staticmethod\ndef num_actions(params: RSAEnvParams) -&gt; int:\n    \"\"\"Number of actions possible in environment.\"\"\"\n    return 1\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnv.observation_space","title":"<code>observation_space(params)</code>","text":"<p>Observation space of the environment.</p> Source code in <code>xlron/environments/gn_model/rmsa_gn_model.py</code> <pre><code>def observation_space(self, params: RSAEnvParams):\n    \"\"\"Observation space of the environment.\"\"\"\n    return spaces.Discrete(\n        3 +  # Request array\n        1 +  # Holding time\n        7 * params.k_paths\n        # Path stats:\n        # Mean free block size\n        # Free slots\n        # Path length (100 km)\n        # Path length (hops)\n        # Number of connections on path\n        # Mean power of connection on path\n        # Mean SNR of connection on path\n    )\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnvParams","title":"<code>RMSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulations_array: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.RMSAGNModelEnvState","title":"<code>RMSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulation_format_index_array: chex.Array  # Modulation format index for each active connection\n    modulation_format_index_array_prev: chex.Array  # Modulation format index for each active connection in previous timestep\n    mod_format_mask: chex.Array  # Modulation format mask\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnv","title":"<code>RSAGNModelEnv</code>","text":"<p>               Bases: <code>RSAEnv</code></p> <p>RMSA + GNN model environment.</p> Source code in <code>xlron/environments/gn_model/rsa_gn_model.py</code> <pre><code>class RSAGNModelEnv(RSAEnv):\n    \"\"\"RMSA + GNN model environment.\"\"\"\n    def __init__(\n            self,\n            key: chex.PRNGKey,\n            params: RSAGNModelEnvParams,\n            traffic_matrix: chex.Array = None,\n            launch_power_array: chex.Array = None,\n            list_of_requests: chex.Array = None,\n            laplacian_matrix: chex.Array = None,\n    ):\n        \"\"\"Initialise the environment state and set as initial state.\n\n        Args:\n            key: PRNG key\n            params: Environment parameters\n            traffic_matrix (optional): Traffic matrix\n            launch_power_array (optional): Launch power array\n\n        Returns:\n            None\n        \"\"\"\n        super().__init__(key, params, traffic_matrix=traffic_matrix, list_of_requests=list_of_requests, laplacian_matrix=laplacian_matrix)\n        state = RSAGNModelEnvState(\n            current_time=0,\n            arrival_time=0,\n            holding_time=0,\n            total_timesteps=0,\n            total_requests=-1,\n            link_slot_array=init_link_slot_array(params),\n            link_slot_departure_array=init_link_slot_departure_array(params),\n            request_array=init_rsa_request_array(),\n            link_slot_mask=init_link_slot_mask(params, agg=params.aggregate_slots),\n            traffic_matrix=traffic_matrix if traffic_matrix is not None else init_traffic_matrix(key, params),\n            graph=None,\n            full_link_slot_mask=init_link_slot_mask(params),\n            accepted_services=0,\n            accepted_bitrate=0.,\n            total_bitrate=0.,\n            list_of_requests=list_of_requests,\n            link_snr_array=init_link_snr_array(params),\n            path_index_array=init_path_index_array(params),\n            path_index_array_prev=init_path_index_array(params),\n            channel_centre_bw_array=init_channel_centre_bw_array(params),\n            channel_power_array=init_channel_power_array(params),\n            channel_centre_bw_array_prev=init_channel_centre_bw_array(params),\n            channel_power_array_prev=init_channel_power_array(params),\n            launch_power_array=launch_power_array,\n            active_lightpaths_array=init_active_lightpaths_array(params),\n            active_lightpaths_array_departure=init_active_lightpaths_array_departure(params),\n            throughput=jnp.array(0., dtype=init_link_snr_array(params).dtype),\n        )\n        self.initial_state = state.replace(graph=init_graph_tuple(state, params, laplacian_matrix))\n\n\n    @partial(jax.jit, static_argnums=(0, 2,))\n    def reset(\n        self, key: chex.PRNGKey, params: Optional[RSAEnvParams] = None, state: Optional[RSAEnvState] = None\n    ) -&gt; Tuple[chex.Array, RSAEnvState]:\n        \"\"\"Reset the environment and log the total throughput at episode end.\n        \"\"\"\n        throughput_condition = params.monitor_active_lightpaths and state is not None\n        throughput = calculate_throughput_from_active_lightpaths(state, params) if (\n            throughput_condition) else jnp.array(0.)\n        obs, state = super().reset(key, params, state)\n        state = state.replace(throughput=throughput)\n        jax.debug.print(\"resetting env, throughput: {}\", throughput, ordered=True)\n        return obs, state\n\n    @partial(jax.jit, static_argnums=(0, 2,))\n    def get_obs(self, state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; chex.Array:\n        # Monitoring active lightpaths is used to track total throughput at end of episode\n        if params.monitor_active_lightpaths:\n           return jnp.array(0)\n        return get_paths_obs_gn_model(state, params)\n\n    @staticmethod\n    def num_actions(params: RSAEnvParams) -&gt; int:\n        \"\"\"Number of actions possible in environment.\"\"\"\n        return 1\n\n    def observation_space(self, params: RSAEnvParams):\n        \"\"\"Observation space of the environment.\"\"\"\n        return spaces.Discrete(\n            3 +  # Request array\n            1 +  # Holding time\n            7 * params.k_paths\n            # Path stats:\n            # Mean free block size\n            # Free slots\n            # Path length (100 km)\n            # Path length (hops)\n            # Number of connections on path\n            # Mean power of connection on path\n            # Mean SNR of connection on path\n        )\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnv.__init__","title":"<code>__init__(key, params, traffic_matrix=None, launch_power_array=None, list_of_requests=None, laplacian_matrix=None)</code>","text":"<p>Initialise the environment state and set as initial state.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>PRNGKey</code> <p>PRNG key</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <code>traffic_matrix</code> <code>optional</code> <p>Traffic matrix</p> <code>None</code> <code>launch_power_array</code> <code>optional</code> <p>Launch power array</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>xlron/environments/gn_model/rsa_gn_model.py</code> <pre><code>def __init__(\n        self,\n        key: chex.PRNGKey,\n        params: RSAGNModelEnvParams,\n        traffic_matrix: chex.Array = None,\n        launch_power_array: chex.Array = None,\n        list_of_requests: chex.Array = None,\n        laplacian_matrix: chex.Array = None,\n):\n    \"\"\"Initialise the environment state and set as initial state.\n\n    Args:\n        key: PRNG key\n        params: Environment parameters\n        traffic_matrix (optional): Traffic matrix\n        launch_power_array (optional): Launch power array\n\n    Returns:\n        None\n    \"\"\"\n    super().__init__(key, params, traffic_matrix=traffic_matrix, list_of_requests=list_of_requests, laplacian_matrix=laplacian_matrix)\n    state = RSAGNModelEnvState(\n        current_time=0,\n        arrival_time=0,\n        holding_time=0,\n        total_timesteps=0,\n        total_requests=-1,\n        link_slot_array=init_link_slot_array(params),\n        link_slot_departure_array=init_link_slot_departure_array(params),\n        request_array=init_rsa_request_array(),\n        link_slot_mask=init_link_slot_mask(params, agg=params.aggregate_slots),\n        traffic_matrix=traffic_matrix if traffic_matrix is not None else init_traffic_matrix(key, params),\n        graph=None,\n        full_link_slot_mask=init_link_slot_mask(params),\n        accepted_services=0,\n        accepted_bitrate=0.,\n        total_bitrate=0.,\n        list_of_requests=list_of_requests,\n        link_snr_array=init_link_snr_array(params),\n        path_index_array=init_path_index_array(params),\n        path_index_array_prev=init_path_index_array(params),\n        channel_centre_bw_array=init_channel_centre_bw_array(params),\n        channel_power_array=init_channel_power_array(params),\n        channel_centre_bw_array_prev=init_channel_centre_bw_array(params),\n        channel_power_array_prev=init_channel_power_array(params),\n        launch_power_array=launch_power_array,\n        active_lightpaths_array=init_active_lightpaths_array(params),\n        active_lightpaths_array_departure=init_active_lightpaths_array_departure(params),\n        throughput=jnp.array(0., dtype=init_link_snr_array(params).dtype),\n    )\n    self.initial_state = state.replace(graph=init_graph_tuple(state, params, laplacian_matrix))\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnv.num_actions","title":"<code>num_actions(params)</code>  <code>staticmethod</code>","text":"<p>Number of actions possible in environment.</p> Source code in <code>xlron/environments/gn_model/rsa_gn_model.py</code> <pre><code>@staticmethod\ndef num_actions(params: RSAEnvParams) -&gt; int:\n    \"\"\"Number of actions possible in environment.\"\"\"\n    return 1\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnv.observation_space","title":"<code>observation_space(params)</code>","text":"<p>Observation space of the environment.</p> Source code in <code>xlron/environments/gn_model/rsa_gn_model.py</code> <pre><code>def observation_space(self, params: RSAEnvParams):\n    \"\"\"Observation space of the environment.\"\"\"\n    return spaces.Discrete(\n        3 +  # Request array\n        1 +  # Holding time\n        7 * params.k_paths\n        # Path stats:\n        # Mean free block size\n        # Free slots\n        # Path length (100 km)\n        # Path length (hops)\n        # Number of connections on path\n        # Mean power of connection on path\n        # Mean SNR of connection on path\n    )\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnv.reset","title":"<code>reset(key, params=None, state=None)</code>","text":"<p>Reset the environment and log the total throughput at episode end.</p> Source code in <code>xlron/environments/gn_model/rsa_gn_model.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 2,))\ndef reset(\n    self, key: chex.PRNGKey, params: Optional[RSAEnvParams] = None, state: Optional[RSAEnvState] = None\n) -&gt; Tuple[chex.Array, RSAEnvState]:\n    \"\"\"Reset the environment and log the total throughput at episode end.\n    \"\"\"\n    throughput_condition = params.monitor_active_lightpaths and state is not None\n    throughput = calculate_throughput_from_active_lightpaths(state, params) if (\n        throughput_condition) else jnp.array(0.)\n    obs, state = super().reset(key, params, state)\n    state = state.replace(throughput=throughput)\n    jax.debug.print(\"resetting env, throughput: {}\", throughput, ordered=True)\n    return obs, state\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnvParams","title":"<code>RSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RSA with GN model.\n    \"\"\"\n    min_snr: chex.Scalar = struct.field(pytree_node=False)\n    fec_threshold: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.RSAGNModelEnvState","title":"<code>RSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    active_lightpaths_array: chex.Array  # Active lightpath array. 1 x M array. Each value is a lightpath index. Used to calculate total throughput.\n    active_lightpaths_array_departure: chex.Array  # Active lightpath array departure time.\n    throughput: chex.Array  # Current network throughput\n</code></pre>"},{"location":"reference/#dataclasses","title":"Dataclasses","text":""},{"location":"reference/#xlron.environments.dataclasses.DeepRMSAEnvState","title":"<code>DeepRMSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for DeepRMSA.</p> <p>Parameters:</p> Name Type Description Default <code>path_stats</code> <code>Array</code> <p>Path stats array containing</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass DeepRMSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for DeepRMSA.\n\n    Args:\n        path_stats (chex.Array): Path stats array containing\n        1. Required slots on path\n        2. Total available slots on path\n        3. Size of 1st free spectrum block\n        4. Avg. free block size\n    \"\"\"\n    path_stats: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.EnvParams","title":"<code>EnvParams</code>","text":"<p>Dataclass to hold environment parameters. Parameters are immutable.</p> <p>Parameters:</p> Name Type Description Default <code>max_requests</code> <code>Scalar</code> <p>Maximum number of requests in an episode</p> required <code>incremental_loading</code> <code>Scalar</code> <p>Incremental increase in traffic load (non-expiring requests)</p> required <code>end_first_blocking</code> <code>Scalar</code> <p>End episode on first blocking event</p> required <code>continuous_operation</code> <code>Scalar</code> <p>If True, do not reset the environment at the end of an episode</p> required <code>edges</code> <code>Array</code> <p>Two column array defining source-dest node-pair edges of the graph</p> required <code>slot_size</code> <code>Scalar</code> <p>Spectral width of frequency slot in GHz</p> required <code>consider_modulation_format</code> <code>Scalar</code> <p>If True, consider modulation format to determine required slots</p> required <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>aggregate_slots</code> <code>Scalar</code> <p>Number of slots to aggregate into a single action (First-Fit with aggregation)</p> required <code>guardband</code> <code>Scalar</code> <p>Guard band in slots</p> required <code>directed_graph</code> <code>bool</code> <p>Whether graph is directed (one fibre per link per transmission direction)</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvParams:\n    \"\"\"Dataclass to hold environment parameters. Parameters are immutable.\n\n    Args:\n        max_requests (chex.Scalar): Maximum number of requests in an episode\n        incremental_loading (chex.Scalar): Incremental increase in traffic load (non-expiring requests)\n        end_first_blocking (chex.Scalar): End episode on first blocking event\n        continuous_operation (chex.Scalar): If True, do not reset the environment at the end of an episode\n        edges (chex.Array): Two column array defining source-dest node-pair edges of the graph\n        slot_size (chex.Scalar): Spectral width of frequency slot in GHz\n        consider_modulation_format (chex.Scalar): If True, consider modulation format to determine required slots\n        link_length_array (chex.Array): Array of link lengths\n        aggregate_slots (chex.Scalar): Number of slots to aggregate into a single action (First-Fit with aggregation)\n        guardband (chex.Scalar): Guard band in slots\n        directed_graph (bool): Whether graph is directed (one fibre per link per transmission direction)\n    \"\"\"\n    max_requests: chex.Scalar = struct.field(pytree_node=False)\n    incremental_loading: chex.Scalar = struct.field(pytree_node=False)\n    end_first_blocking: chex.Scalar = struct.field(pytree_node=False)\n    continuous_operation: chex.Scalar = struct.field(pytree_node=False)\n    edges: chex.Array = struct.field(pytree_node=False)\n    slot_size: chex.Scalar = struct.field(pytree_node=False)\n    consider_modulation_format: chex.Scalar = struct.field(pytree_node=False)\n    link_length_array: chex.Array = struct.field(pytree_node=False)\n    aggregate_slots: chex.Scalar = struct.field(pytree_node=False)\n    guardband: chex.Scalar = struct.field(pytree_node=False)\n    directed_graph: bool = struct.field(pytree_node=False)\n    maximise_throughput: bool = struct.field(pytree_node=False)\n    reward_type: str = struct.field(pytree_node=False)\n    values_bw: chex.Array = struct.field(pytree_node=False)\n    truncate_holding_time: bool = struct.field(pytree_node=False)\n    traffic_array: bool = struct.field(pytree_node=False)\n    pack_path_bits: bool = struct.field(pytree_node=False)\n    relative_arrival_times: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.EnvState","title":"<code>EnvState</code>","text":"<p>Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>current_time</code> <code>Scalar</code> <p>Current time in environment</p> required <code>holding_time</code> <code>Scalar</code> <p>Holding time of current request</p> required <code>total_timesteps</code> <code>Scalar</code> <p>Total timesteps in environment</p> required <code>total_requests</code> <code>Scalar</code> <p>Total requests in environment</p> required <code>graph</code> <code>GraphsTuple</code> <p>Graph tuple representing network state</p> required <code>full_link_slot_mask</code> <code>Array</code> <p>Action mask for link slot action (including if slot actions are aggregated)</p> required <code>accepted_services</code> <code>Array</code> <p>Number of accepted services</p> required <code>accepted_bitrate</code> <code>Array</code> <p>Accepted bitrate</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvState:\n    \"\"\"Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.\n\n    Args:\n        current_time (chex.Scalar): Current time in environment\n        holding_time (chex.Scalar): Holding time of current request\n        total_timesteps (chex.Scalar): Total timesteps in environment\n        total_requests (chex.Scalar): Total requests in environment\n        graph (jraph.GraphsTuple): Graph tuple representing network state\n        full_link_slot_mask (chex.Array): Action mask for link slot action (including if slot actions are aggregated)\n        accepted_services (chex.Array): Number of accepted services\n        accepted_bitrate (chex.Array): Accepted bitrate\n        \"\"\"\n    current_time: chex.Scalar\n    holding_time: chex.Scalar\n    arrival_time: chex.Scalar\n    total_timesteps: chex.Scalar\n    total_requests: chex.Scalar\n    graph: jraph.GraphsTuple\n    full_link_slot_mask: chex.Array\n    accepted_services: chex.Array\n    accepted_bitrate: chex.Array\n    total_bitrate: chex.Array\n    list_of_requests: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.GNModelEnvParams","title":"<code>GNModelEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment state for GN model environments.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment state for GN model environments.\n    \"\"\"\n    ref_lambda: chex.Scalar = struct.field(pytree_node=False)\n    max_spans: chex.Scalar = struct.field(pytree_node=False)\n    max_span_length: chex.Scalar = struct.field(pytree_node=False)\n    nonlinear_coeff: chex.Scalar = struct.field(pytree_node=False)\n    raman_gain_slope: chex.Scalar = struct.field(pytree_node=False)\n    attenuation: chex.Scalar = struct.field(pytree_node=False)\n    attenuation_bar: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_coeff: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_slope: chex.Scalar = struct.field(pytree_node=False)\n    transceiver_snr: chex.Array = struct.field(pytree_node=False)\n    amplifier_noise_figure: chex.Array = struct.field(pytree_node=False)\n    coherent: bool = struct.field(pytree_node=False)\n    num_roadms: chex.Scalar = struct.field(pytree_node=False)\n    roadm_loss: chex.Scalar = struct.field(pytree_node=False)\n    num_spans: chex.Scalar = struct.field(pytree_node=False)\n    launch_power_type: chex.Scalar = struct.field(pytree_node=False)\n    snr_margin: chex.Scalar = struct.field(pytree_node=False)\n    max_snr: chex.Scalar = struct.field(pytree_node=False)\n    max_power: chex.Scalar = struct.field(pytree_node=False)\n    min_power: chex.Scalar = struct.field(pytree_node=False)\n    step_power: chex.Scalar = struct.field(pytree_node=False)\n    last_fit: bool = struct.field(pytree_node=False)\n    default_launch_power: chex.Scalar = struct.field(pytree_node=False)\n    mod_format_correction: bool = struct.field(pytree_node=False)\n    monitor_active_lightpaths: bool = struct.field(pytree_node=False)  # Monitor active lightpaths for throughput calculation\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n    uniform_spans: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.GNModelEnvState","title":"<code>GNModelEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    link_snr_array: chex.Array  # Available SNR on each link\n    channel_centre_bw_array: chex.Array  # Channel centre bandwidth for each active connection\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots (used for lightpath SNR calculation)\n    channel_power_array: chex.Array  # Channel power for each active connection\n    channel_centre_bw_array_prev: chex.Array  # Channel centre bandwidth for each active connection in previous timestep\n    path_index_array_prev: chex.Array  # Contains indices of lightpaths in use on slots in previous timestep\n    channel_power_array_prev: chex.Array  # Channel power for each active connection in previous timestep\n    launch_power_array: chex.Array  # Launch power array\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.LogEnvState","title":"<code>LogEnvState</code>","text":"<p>Dataclass to hold environment state for logging.</p> <p>Parameters:</p> Name Type Description Default <code>env_state</code> <code>EnvState</code> <p>Environment state</p> required <code>lengths</code> <code>Scalar</code> <p>Lengths</p> required <code>returns</code> <code>Scalar</code> <p>Returns</p> required <code>cum_returns</code> <code>Scalar</code> <p>Cumulative returns</p> required <code>episode_lengths</code> <code>Scalar</code> <p>Episode lengths</p> required <code>episode_returns</code> <code>Scalar</code> <p>Episode returns</p> required <code>accepted_services</code> <code>Scalar</code> <p>Accepted services</p> required <code>accepted_bitrate</code> <code>Scalar</code> <p>Accepted bitrate</p> required <code>done</code> <code>Scalar</code> <p>Done</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass LogEnvState:\n    \"\"\"Dataclass to hold environment state for logging.\n\n    Args:\n        env_state (EnvState): Environment state\n        lengths (chex.Scalar): Lengths\n        returns (chex.Scalar): Returns\n        cum_returns (chex.Scalar): Cumulative returns\n        episode_lengths (chex.Scalar): Episode lengths\n        episode_returns (chex.Scalar): Episode returns\n        accepted_services (chex.Scalar): Accepted services\n        accepted_bitrate (chex.Scalar): Accepted bitrate\n        done (chex.Scalar): Done\n    \"\"\"\n    env_state: EnvState\n    lengths: float\n    returns: float\n    cum_returns: float\n    accepted_services: int\n    accepted_bitrate: float\n    total_bitrate: float\n    utilisation: float\n    done: bool\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.MultiBandRSAEnvParams","title":"<code>MultiBandRSAEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_start: chex.Scalar = struct.field(pytree_node=False)\n    gap_width: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.MultiBandRSAEnvState","title":"<code>MultiBandRSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RMSAGNModelEnvParams","title":"<code>RMSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulations_array: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RMSAGNModelEnvState","title":"<code>RMSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulation_format_index_array: chex.Array  # Modulation format index for each active connection\n    modulation_format_index_array_prev: chex.Array  # Modulation format index for each active connection in previous timestep\n    mod_format_mask: chex.Array  # Modulation format mask\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RSAEnvParams","title":"<code>RSAEnvParams</code>","text":"<p>               Bases: <code>EnvParams</code></p> <p>Dataclass to hold environment parameters for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>Scalar</code> <p>Number of nodes</p> required <code>num_links</code> <code>Scalar</code> <p>Number of links</p> required <code>link_resources</code> <code>Scalar</code> <p>Number of link resources</p> required <code>k_paths</code> <code>Scalar</code> <p>Number of paths</p> required <code>mean_service_holding_time</code> <code>Scalar</code> <p>Mean service holding time</p> required <code>load</code> <code>Scalar</code> <p>Load</p> required <code>arrival_rate</code> <code>Scalar</code> <p>Arrival rate</p> required <code>path_link_array</code> <code>Array</code> <p>Path link array</p> required <code>random_traffic</code> <code>bool</code> <p>Random traffic matrix for RSA on each reset (else uniform or custom)</p> required <code>max_slots</code> <code>Scalar</code> <p>Maximum number of slots</p> required <code>path_se_array</code> <code>Array</code> <p>Path spectral efficiency array</p> required <code>deterministic_requests</code> <code>bool</code> <p>If True, use deterministic requests</p> required <code>multiple_topologies</code> <code>bool</code> <p>If True, use multiple topologies</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvParams(EnvParams):\n    \"\"\"Dataclass to hold environment parameters for RSA.\n\n    Args:\n        num_nodes (chex.Scalar): Number of nodes\n        num_links (chex.Scalar): Number of links\n        link_resources (chex.Scalar): Number of link resources\n        k_paths (chex.Scalar): Number of paths\n        mean_service_holding_time (chex.Scalar): Mean service holding time\n        load (chex.Scalar): Load\n        arrival_rate (chex.Scalar): Arrival rate\n        path_link_array (chex.Array): Path link array\n        random_traffic (bool): Random traffic matrix for RSA on each reset (else uniform or custom)\n        max_slots (chex.Scalar): Maximum number of slots\n        path_se_array (chex.Array): Path spectral efficiency array\n        deterministic_requests (bool): If True, use deterministic requests\n        multiple_topologies (bool): If True, use multiple topologies\n    \"\"\"\n    num_nodes: chex.Scalar = struct.field(pytree_node=False)\n    num_links: chex.Scalar = struct.field(pytree_node=False)\n    link_resources: chex.Scalar = struct.field(pytree_node=False)\n    k_paths: chex.Scalar = struct.field(pytree_node=False)\n    mean_service_holding_time: chex.Scalar = struct.field(pytree_node=False)\n    load: chex.Scalar = struct.field(pytree_node=False)\n    arrival_rate: chex.Scalar = struct.field(pytree_node=False)\n    path_link_array: chex.Array = struct.field(pytree_node=False)\n    random_traffic: bool = struct.field(pytree_node=False)\n    max_slots: chex.Scalar = struct.field(pytree_node=False)\n    path_se_array: chex.Array = struct.field(pytree_node=False)\n    deterministic_requests: bool = struct.field(pytree_node=False)\n    multiple_topologies: bool = struct.field(pytree_node=False)\n    log_actions: bool = struct.field(pytree_node=False)\n    disable_node_features: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RSAEnvState","title":"<code>RSAEnvState</code>","text":"<p>               Bases: <code>EnvState</code></p> <p>Dataclass to hold environment state for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>request_array</code> <code>Array</code> <p>Request array</p> required <code>link_slot_departure_array</code> <code>Array</code> <p>Link slot departure array</p> required <code>link_slot_mask</code> <code>Array</code> <p>Link slot mask</p> required <code>traffic_matrix</code> <code>Array</code> <p>Traffic matrix</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvState(EnvState):\n    \"\"\"Dataclass to hold environment state for RSA.\n\n    Args:\n        link_slot_array (chex.Array): Link slot array\n        request_array (chex.Array): Request array\n        link_slot_departure_array (chex.Array): Link slot departure array\n        link_slot_mask (chex.Array): Link slot mask\n        traffic_matrix (chex.Array): Traffic matrix\n    \"\"\"\n    link_slot_array: chex.Array\n    request_array: chex.Array\n    link_slot_departure_array: chex.Array\n    link_slot_mask: chex.Array\n    traffic_matrix: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RSAGNModelEnvParams","title":"<code>RSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RSA with GN model.\n    \"\"\"\n    min_snr: chex.Scalar = struct.field(pytree_node=False)\n    fec_threshold: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RSAGNModelEnvState","title":"<code>RSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    active_lightpaths_array: chex.Array  # Active lightpath array. 1 x M array. Each value is a lightpath index. Used to calculate total throughput.\n    active_lightpaths_array_departure: chex.Array  # Active lightpath array departure time.\n    throughput: chex.Array  # Current network throughput\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RSAMultibandEnvParams","title":"<code>RSAMultibandEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RSAMultibandEnvState","title":"<code>RSAMultibandEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.RWALightpathReuseEnvState","title":"<code>RWALightpathReuseEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RWA with lightpath reuse.</p> <p>Parameters:</p> Name Type Description Default <code>path_index_array</code> <code>Array</code> <p>Contains indices of lightpaths in use on slots</p> required <code>path_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of each lightpath</p> required <code>link_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of lightpath on each link-slot</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RWALightpathReuseEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RWA with lightpath reuse.\n\n    Args:\n        path_index_array (chex.Array): Contains indices of lightpaths in use on slots\n        path_capacity_array (chex.Array): Contains remaining capacity of each lightpath\n        link_capacity_array (chex.Array): Contains remaining capacity of lightpath on each link-slot\n    \"\"\"\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots\n    path_capacity_array: chex.Array  # Contains remaining capacity of each lightpath\n    link_capacity_array: chex.Array  # Contains remaining capacity of lightpath on each link-slot\n    time_since_last_departure: chex.Array  # Time since last departure\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.VONEEnvParams","title":"<code>VONEEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_resources</code> <code>Scalar</code> <p>Number of node resources</p> required <code>max_edges</code> <code>Scalar</code> <p>Maximum number of edges</p> required <code>min_node_resources</code> <code>Scalar</code> <p>Minimum number of node resources</p> required <code>max_node_resources</code> <code>Scalar</code> <p>Maximum number of node resources</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for VONE.\n\n    Args:\n        node_resources (chex.Scalar): Number of node resources\n        max_edges (chex.Scalar): Maximum number of edges\n        min_node_resources (chex.Scalar): Minimum number of node resources\n        max_node_resources (chex.Scalar): Maximum number of node resources\n    \"\"\"\n    node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_edges: chex.Scalar = struct.field(pytree_node=False)\n    min_node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_node_resources: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.dataclasses.VONEEnvState","title":"<code>VONEEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_capacity_array</code> <code>Array</code> <p>Node capacity array</p> required <code>node_resource_array</code> <code>Array</code> <p>Node resource array</p> required <code>node_departure_array</code> <code>Array</code> <p>Node departure array</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>action_history</code> <code>Array</code> <p>Action history</p> required <code>node_mask_s</code> <code>Array</code> <p>Node mask for source node</p> required <code>node_mask_d</code> <code>Array</code> <p>Node mask for destination node</p> required <code>virtual_topology_patterns</code> <code>Array</code> <p>Virtual topology patterns</p> required <code>values_nodes</code> <code>Array</code> <p>Values for nodes</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for VONE.\n\n    Args:\n        node_capacity_array (chex.Array): Node capacity array\n        node_resource_array (chex.Array): Node resource array\n        node_departure_array (chex.Array): Node departure array\n        action_counter (chex.Array): Action counter\n        action_history (chex.Array): Action history\n        node_mask_s (chex.Array): Node mask for source node\n        node_mask_d (chex.Array): Node mask for destination node\n        virtual_topology_patterns (chex.Array): Virtual topology patterns\n        values_nodes (chex.Array): Values for nodes\n    \"\"\"\n    node_capacity_array: chex.Array\n    node_resource_array: chex.Array\n    node_departure_array: chex.Array\n    action_counter: chex.Array\n    action_history: chex.Array\n    node_mask_s: chex.Array\n    node_mask_d: chex.Array\n    virtual_topology_patterns: chex.Array\n    values_nodes: chex.Array\n</code></pre>"},{"location":"reference/#environment-wrappers","title":"Environment wrappers","text":""},{"location":"reference/#xlron.environments.wrappers.DeepRMSAEnvState","title":"<code>DeepRMSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for DeepRMSA.</p> <p>Parameters:</p> Name Type Description Default <code>path_stats</code> <code>Array</code> <p>Path stats array containing</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass DeepRMSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for DeepRMSA.\n\n    Args:\n        path_stats (chex.Array): Path stats array containing\n        1. Required slots on path\n        2. Total available slots on path\n        3. Size of 1st free spectrum block\n        4. Avg. free block size\n    \"\"\"\n    path_stats: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.EnvParams","title":"<code>EnvParams</code>","text":"<p>Dataclass to hold environment parameters. Parameters are immutable.</p> <p>Parameters:</p> Name Type Description Default <code>max_requests</code> <code>Scalar</code> <p>Maximum number of requests in an episode</p> required <code>incremental_loading</code> <code>Scalar</code> <p>Incremental increase in traffic load (non-expiring requests)</p> required <code>end_first_blocking</code> <code>Scalar</code> <p>End episode on first blocking event</p> required <code>continuous_operation</code> <code>Scalar</code> <p>If True, do not reset the environment at the end of an episode</p> required <code>edges</code> <code>Array</code> <p>Two column array defining source-dest node-pair edges of the graph</p> required <code>slot_size</code> <code>Scalar</code> <p>Spectral width of frequency slot in GHz</p> required <code>consider_modulation_format</code> <code>Scalar</code> <p>If True, consider modulation format to determine required slots</p> required <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>aggregate_slots</code> <code>Scalar</code> <p>Number of slots to aggregate into a single action (First-Fit with aggregation)</p> required <code>guardband</code> <code>Scalar</code> <p>Guard band in slots</p> required <code>directed_graph</code> <code>bool</code> <p>Whether graph is directed (one fibre per link per transmission direction)</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvParams:\n    \"\"\"Dataclass to hold environment parameters. Parameters are immutable.\n\n    Args:\n        max_requests (chex.Scalar): Maximum number of requests in an episode\n        incremental_loading (chex.Scalar): Incremental increase in traffic load (non-expiring requests)\n        end_first_blocking (chex.Scalar): End episode on first blocking event\n        continuous_operation (chex.Scalar): If True, do not reset the environment at the end of an episode\n        edges (chex.Array): Two column array defining source-dest node-pair edges of the graph\n        slot_size (chex.Scalar): Spectral width of frequency slot in GHz\n        consider_modulation_format (chex.Scalar): If True, consider modulation format to determine required slots\n        link_length_array (chex.Array): Array of link lengths\n        aggregate_slots (chex.Scalar): Number of slots to aggregate into a single action (First-Fit with aggregation)\n        guardband (chex.Scalar): Guard band in slots\n        directed_graph (bool): Whether graph is directed (one fibre per link per transmission direction)\n    \"\"\"\n    max_requests: chex.Scalar = struct.field(pytree_node=False)\n    incremental_loading: chex.Scalar = struct.field(pytree_node=False)\n    end_first_blocking: chex.Scalar = struct.field(pytree_node=False)\n    continuous_operation: chex.Scalar = struct.field(pytree_node=False)\n    edges: chex.Array = struct.field(pytree_node=False)\n    slot_size: chex.Scalar = struct.field(pytree_node=False)\n    consider_modulation_format: chex.Scalar = struct.field(pytree_node=False)\n    link_length_array: chex.Array = struct.field(pytree_node=False)\n    aggregate_slots: chex.Scalar = struct.field(pytree_node=False)\n    guardband: chex.Scalar = struct.field(pytree_node=False)\n    directed_graph: bool = struct.field(pytree_node=False)\n    maximise_throughput: bool = struct.field(pytree_node=False)\n    reward_type: str = struct.field(pytree_node=False)\n    values_bw: chex.Array = struct.field(pytree_node=False)\n    truncate_holding_time: bool = struct.field(pytree_node=False)\n    traffic_array: bool = struct.field(pytree_node=False)\n    pack_path_bits: bool = struct.field(pytree_node=False)\n    relative_arrival_times: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.EnvState","title":"<code>EnvState</code>","text":"<p>Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>current_time</code> <code>Scalar</code> <p>Current time in environment</p> required <code>holding_time</code> <code>Scalar</code> <p>Holding time of current request</p> required <code>total_timesteps</code> <code>Scalar</code> <p>Total timesteps in environment</p> required <code>total_requests</code> <code>Scalar</code> <p>Total requests in environment</p> required <code>graph</code> <code>GraphsTuple</code> <p>Graph tuple representing network state</p> required <code>full_link_slot_mask</code> <code>Array</code> <p>Action mask for link slot action (including if slot actions are aggregated)</p> required <code>accepted_services</code> <code>Array</code> <p>Number of accepted services</p> required <code>accepted_bitrate</code> <code>Array</code> <p>Accepted bitrate</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvState:\n    \"\"\"Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.\n\n    Args:\n        current_time (chex.Scalar): Current time in environment\n        holding_time (chex.Scalar): Holding time of current request\n        total_timesteps (chex.Scalar): Total timesteps in environment\n        total_requests (chex.Scalar): Total requests in environment\n        graph (jraph.GraphsTuple): Graph tuple representing network state\n        full_link_slot_mask (chex.Array): Action mask for link slot action (including if slot actions are aggregated)\n        accepted_services (chex.Array): Number of accepted services\n        accepted_bitrate (chex.Array): Accepted bitrate\n        \"\"\"\n    current_time: chex.Scalar\n    holding_time: chex.Scalar\n    arrival_time: chex.Scalar\n    total_timesteps: chex.Scalar\n    total_requests: chex.Scalar\n    graph: jraph.GraphsTuple\n    full_link_slot_mask: chex.Array\n    accepted_services: chex.Array\n    accepted_bitrate: chex.Array\n    total_bitrate: chex.Array\n    list_of_requests: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.GNModelEnvParams","title":"<code>GNModelEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment state for GN model environments.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment state for GN model environments.\n    \"\"\"\n    ref_lambda: chex.Scalar = struct.field(pytree_node=False)\n    max_spans: chex.Scalar = struct.field(pytree_node=False)\n    max_span_length: chex.Scalar = struct.field(pytree_node=False)\n    nonlinear_coeff: chex.Scalar = struct.field(pytree_node=False)\n    raman_gain_slope: chex.Scalar = struct.field(pytree_node=False)\n    attenuation: chex.Scalar = struct.field(pytree_node=False)\n    attenuation_bar: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_coeff: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_slope: chex.Scalar = struct.field(pytree_node=False)\n    transceiver_snr: chex.Array = struct.field(pytree_node=False)\n    amplifier_noise_figure: chex.Array = struct.field(pytree_node=False)\n    coherent: bool = struct.field(pytree_node=False)\n    num_roadms: chex.Scalar = struct.field(pytree_node=False)\n    roadm_loss: chex.Scalar = struct.field(pytree_node=False)\n    num_spans: chex.Scalar = struct.field(pytree_node=False)\n    launch_power_type: chex.Scalar = struct.field(pytree_node=False)\n    snr_margin: chex.Scalar = struct.field(pytree_node=False)\n    max_snr: chex.Scalar = struct.field(pytree_node=False)\n    max_power: chex.Scalar = struct.field(pytree_node=False)\n    min_power: chex.Scalar = struct.field(pytree_node=False)\n    step_power: chex.Scalar = struct.field(pytree_node=False)\n    last_fit: bool = struct.field(pytree_node=False)\n    default_launch_power: chex.Scalar = struct.field(pytree_node=False)\n    mod_format_correction: bool = struct.field(pytree_node=False)\n    monitor_active_lightpaths: bool = struct.field(pytree_node=False)  # Monitor active lightpaths for throughput calculation\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n    uniform_spans: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.GNModelEnvState","title":"<code>GNModelEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    link_snr_array: chex.Array  # Available SNR on each link\n    channel_centre_bw_array: chex.Array  # Channel centre bandwidth for each active connection\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots (used for lightpath SNR calculation)\n    channel_power_array: chex.Array  # Channel power for each active connection\n    channel_centre_bw_array_prev: chex.Array  # Channel centre bandwidth for each active connection in previous timestep\n    path_index_array_prev: chex.Array  # Contains indices of lightpaths in use on slots in previous timestep\n    channel_power_array_prev: chex.Array  # Channel power for each active connection in previous timestep\n    launch_power_array: chex.Array  # Launch power array\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.HashableArrayWrapper","title":"<code>HashableArrayWrapper</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Wrapper for making arrays hashable. In order to access pre-computed data, such as shortest paths between node-pairs or the constituent links of a path, within a jitted function, we need to make the arrays containing this data hashable. By defining this wrapper, we can define a hash method that returns a hash of the array's bytes, thus making the array hashable. From: https://github.com/google/jax/issues/4572#issuecomment-709677518</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>class HashableArrayWrapper(Generic[T]):\n    \"\"\"Wrapper for making arrays hashable.\n    In order to access pre-computed data, such as shortest paths between node-pairs or the constituent links of a path,\n    within a jitted function, we need to make the arrays containing this data hashable. By defining this wrapper, we can\n    define a __hash__ method that returns a hash of the array's bytes, thus making the array hashable.\n    From: https://github.com/google/jax/issues/4572#issuecomment-709677518\n    \"\"\"\n    def __init__(self, val: T):\n        self.val = val\n\n    def __getattribute__(self, prop):\n        if prop == 'val' or prop == \"__hash__\" or prop == \"__eq__\":\n            return super(HashableArrayWrapper, self).__getattribute__(prop)\n        return getattr(self.val, prop)\n\n    def __getitem__(self, key):\n        return self.val[key]\n\n    def __setitem__(self, key, val):\n        self.val[key] = val\n\n    def __hash__(self):\n        return hash(self.val.tobytes())\n\n    def __eq__(self, other):\n        if isinstance(other, HashableArrayWrapper):\n            return self.__hash__() == other.__hash__()\n\n        f = getattr(self.val, \"__eq__\")\n        return f(self, other)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.LogEnvState","title":"<code>LogEnvState</code>","text":"<p>Dataclass to hold environment state for logging.</p> <p>Parameters:</p> Name Type Description Default <code>env_state</code> <code>EnvState</code> <p>Environment state</p> required <code>lengths</code> <code>Scalar</code> <p>Lengths</p> required <code>returns</code> <code>Scalar</code> <p>Returns</p> required <code>cum_returns</code> <code>Scalar</code> <p>Cumulative returns</p> required <code>episode_lengths</code> <code>Scalar</code> <p>Episode lengths</p> required <code>episode_returns</code> <code>Scalar</code> <p>Episode returns</p> required <code>accepted_services</code> <code>Scalar</code> <p>Accepted services</p> required <code>accepted_bitrate</code> <code>Scalar</code> <p>Accepted bitrate</p> required <code>done</code> <code>Scalar</code> <p>Done</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass LogEnvState:\n    \"\"\"Dataclass to hold environment state for logging.\n\n    Args:\n        env_state (EnvState): Environment state\n        lengths (chex.Scalar): Lengths\n        returns (chex.Scalar): Returns\n        cum_returns (chex.Scalar): Cumulative returns\n        episode_lengths (chex.Scalar): Episode lengths\n        episode_returns (chex.Scalar): Episode returns\n        accepted_services (chex.Scalar): Accepted services\n        accepted_bitrate (chex.Scalar): Accepted bitrate\n        done (chex.Scalar): Done\n    \"\"\"\n    env_state: EnvState\n    lengths: float\n    returns: float\n    cum_returns: float\n    accepted_services: int\n    accepted_bitrate: float\n    total_bitrate: float\n    utilisation: float\n    done: bool\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.LogWrapper","title":"<code>LogWrapper</code>","text":"<p>               Bases: <code>GymnaxWrapper</code></p> <p>Log the episode returns and lengths. Modified from: https://github.com/RobertTLange/gymnax/blob/master/gymnax/wrappers/purerl.py</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>class LogWrapper(GymnaxWrapper):\n    \"\"\"Log the episode returns and lengths.\n    Modified from: https://github.com/RobertTLange/gymnax/blob/master/gymnax/wrappers/purerl.py\n    \"\"\"\n\n    def __init__(self, env: environment.Environment):\n        super().__init__(env)\n\n    @partial(jax.jit, static_argnums=(0,))\n    def reset(\n        self, key: chex.PRNGKey, params: Optional[environment.EnvParams] = None, state: Optional[environment.EnvState] = None\n    ) -&gt; Tuple[chex.Array, environment.EnvState]:\n        obs, env_state = self._env.reset(key, params, state)\n        state = LogEnvState(\n            env_state=env_state,\n            lengths=0,\n            returns=0,\n            cum_returns=0,\n            accepted_services=0,\n            accepted_bitrate=0,\n            total_bitrate=0,\n            utilisation=0,\n            done=False,\n        )\n        return obs, state\n\n    @partial(jax.jit, static_argnums=(0,))\n    def step(\n        self,\n        key: chex.PRNGKey,\n        state: environment.EnvState,\n        action: Union[int, float],\n        params: Optional[environment.EnvParams] = None,\n    ) -&gt; Tuple[chex.Array, environment.EnvState, float, bool, dict]:\n        obs, env_state, reward, done, info = self._env.step(\n            key, state.env_state, action, params\n        )\n        state = LogEnvState(\n            env_state=env_state,\n            lengths=state.lengths * (1 - done) + 1,\n            returns=reward,\n            cum_returns=state.cum_returns * (1 - done) + reward,\n            accepted_services=env_state.accepted_services,\n            accepted_bitrate=env_state.accepted_bitrate,\n            total_bitrate=env_state.total_bitrate,\n            utilisation=jnp.count_nonzero(env_state.link_slot_array) / env_state.link_slot_array.size,\n            done=done,\n        )\n        info[\"lengths\"] = state.lengths\n        info[\"returns\"] = state.returns\n        info[\"cum_returns\"] = state.cum_returns\n        info[\"accepted_services\"] = state.accepted_services\n        info[\"accepted_bitrate\"] = state.accepted_bitrate\n        info[\"total_bitrate\"] = state.total_bitrate\n        info[\"utilisation\"] = state.utilisation\n        info[\"done\"] = done\n        # First check if we're dealing with RSAGNModelEnvParams\n        is_rsa_params = params.__class__.__name__ == \"RSAGNModelEnvParams\"\n\n        # For RSA params, unpack the action\n        if is_rsa_params:\n            action, power_action = action\n            info[\"launch_power\"] = power_action\n\n        # Now, if we need to log actions OR we have RSA params, compute the common fields\n        if is_rsa_params or params.log_actions:\n            # Compute common fields\n            nodes_sd, dr_request = read_rsa_request(state.env_state.request_array)\n            source, dest = nodes_sd\n            i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph).astype(\n                jnp.int32)\n            path_index, slot_index = process_path_action(state.env_state, params, action)\n\n            # Set common info\n            info[\"path_index\"] = i + path_index\n            info[\"slot_index\"] = slot_index\n            info[\"source\"] = source\n            info[\"dest\"] = dest\n            info[\"data_rate\"] = dr_request[0]\n\n            # RSA-specific throughput info\n            if is_rsa_params:\n                info[\"throughput\"] = env_state.throughput #* done  # Only != 0 at end of episode\n\n            # Logging-specific info\n            if params.log_actions:\n                # RSA-specific logging\n                if is_rsa_params:\n                    path = params.path_link_array.val[path_index.astype(jnp.int32)]\n                    info[\"path_snr\"] = get_snr_for_path(path, env_state.link_snr_array, params)[\n                        slot_index.astype(jnp.int32)]\n                # Common logging fields\n                info[\"arrival_time\"] = env_state.current_time[0]\n                info[\"departure_time\"] = env_state.current_time[0] + env_state.holding_time[0]\n        return obs, state, reward, done, info\n\n    def _tree_flatten(self):\n        children = ()  # arrays / dynamic values\n        aux_data = {\"env\": self._env}  # static values\n        return (children, aux_data)\n\n    @classmethod\n    def _tree_unflatten(cls, aux_data, children):\n        return cls(*children, **aux_data)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.MultiBandRSAEnvParams","title":"<code>MultiBandRSAEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_start: chex.Scalar = struct.field(pytree_node=False)\n    gap_width: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.MultiBandRSAEnvState","title":"<code>MultiBandRSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RMSAGNModelEnvParams","title":"<code>RMSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulations_array: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RMSAGNModelEnvState","title":"<code>RMSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulation_format_index_array: chex.Array  # Modulation format index for each active connection\n    modulation_format_index_array_prev: chex.Array  # Modulation format index for each active connection in previous timestep\n    mod_format_mask: chex.Array  # Modulation format mask\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RSAEnvParams","title":"<code>RSAEnvParams</code>","text":"<p>               Bases: <code>EnvParams</code></p> <p>Dataclass to hold environment parameters for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>Scalar</code> <p>Number of nodes</p> required <code>num_links</code> <code>Scalar</code> <p>Number of links</p> required <code>link_resources</code> <code>Scalar</code> <p>Number of link resources</p> required <code>k_paths</code> <code>Scalar</code> <p>Number of paths</p> required <code>mean_service_holding_time</code> <code>Scalar</code> <p>Mean service holding time</p> required <code>load</code> <code>Scalar</code> <p>Load</p> required <code>arrival_rate</code> <code>Scalar</code> <p>Arrival rate</p> required <code>path_link_array</code> <code>Array</code> <p>Path link array</p> required <code>random_traffic</code> <code>bool</code> <p>Random traffic matrix for RSA on each reset (else uniform or custom)</p> required <code>max_slots</code> <code>Scalar</code> <p>Maximum number of slots</p> required <code>path_se_array</code> <code>Array</code> <p>Path spectral efficiency array</p> required <code>deterministic_requests</code> <code>bool</code> <p>If True, use deterministic requests</p> required <code>multiple_topologies</code> <code>bool</code> <p>If True, use multiple topologies</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvParams(EnvParams):\n    \"\"\"Dataclass to hold environment parameters for RSA.\n\n    Args:\n        num_nodes (chex.Scalar): Number of nodes\n        num_links (chex.Scalar): Number of links\n        link_resources (chex.Scalar): Number of link resources\n        k_paths (chex.Scalar): Number of paths\n        mean_service_holding_time (chex.Scalar): Mean service holding time\n        load (chex.Scalar): Load\n        arrival_rate (chex.Scalar): Arrival rate\n        path_link_array (chex.Array): Path link array\n        random_traffic (bool): Random traffic matrix for RSA on each reset (else uniform or custom)\n        max_slots (chex.Scalar): Maximum number of slots\n        path_se_array (chex.Array): Path spectral efficiency array\n        deterministic_requests (bool): If True, use deterministic requests\n        multiple_topologies (bool): If True, use multiple topologies\n    \"\"\"\n    num_nodes: chex.Scalar = struct.field(pytree_node=False)\n    num_links: chex.Scalar = struct.field(pytree_node=False)\n    link_resources: chex.Scalar = struct.field(pytree_node=False)\n    k_paths: chex.Scalar = struct.field(pytree_node=False)\n    mean_service_holding_time: chex.Scalar = struct.field(pytree_node=False)\n    load: chex.Scalar = struct.field(pytree_node=False)\n    arrival_rate: chex.Scalar = struct.field(pytree_node=False)\n    path_link_array: chex.Array = struct.field(pytree_node=False)\n    random_traffic: bool = struct.field(pytree_node=False)\n    max_slots: chex.Scalar = struct.field(pytree_node=False)\n    path_se_array: chex.Array = struct.field(pytree_node=False)\n    deterministic_requests: bool = struct.field(pytree_node=False)\n    multiple_topologies: bool = struct.field(pytree_node=False)\n    log_actions: bool = struct.field(pytree_node=False)\n    disable_node_features: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RSAEnvState","title":"<code>RSAEnvState</code>","text":"<p>               Bases: <code>EnvState</code></p> <p>Dataclass to hold environment state for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>request_array</code> <code>Array</code> <p>Request array</p> required <code>link_slot_departure_array</code> <code>Array</code> <p>Link slot departure array</p> required <code>link_slot_mask</code> <code>Array</code> <p>Link slot mask</p> required <code>traffic_matrix</code> <code>Array</code> <p>Traffic matrix</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvState(EnvState):\n    \"\"\"Dataclass to hold environment state for RSA.\n\n    Args:\n        link_slot_array (chex.Array): Link slot array\n        request_array (chex.Array): Request array\n        link_slot_departure_array (chex.Array): Link slot departure array\n        link_slot_mask (chex.Array): Link slot mask\n        traffic_matrix (chex.Array): Traffic matrix\n    \"\"\"\n    link_slot_array: chex.Array\n    request_array: chex.Array\n    link_slot_departure_array: chex.Array\n    link_slot_mask: chex.Array\n    traffic_matrix: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RSAGNModelEnvParams","title":"<code>RSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RSA with GN model.\n    \"\"\"\n    min_snr: chex.Scalar = struct.field(pytree_node=False)\n    fec_threshold: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RSAGNModelEnvState","title":"<code>RSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    active_lightpaths_array: chex.Array  # Active lightpath array. 1 x M array. Each value is a lightpath index. Used to calculate total throughput.\n    active_lightpaths_array_departure: chex.Array  # Active lightpath array departure time.\n    throughput: chex.Array  # Current network throughput\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RSAMultibandEnvParams","title":"<code>RSAMultibandEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RSAMultibandEnvState","title":"<code>RSAMultibandEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RWALightpathReuseEnvState","title":"<code>RWALightpathReuseEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RWA with lightpath reuse.</p> <p>Parameters:</p> Name Type Description Default <code>path_index_array</code> <code>Array</code> <p>Contains indices of lightpaths in use on slots</p> required <code>path_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of each lightpath</p> required <code>link_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of lightpath on each link-slot</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RWALightpathReuseEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RWA with lightpath reuse.\n\n    Args:\n        path_index_array (chex.Array): Contains indices of lightpaths in use on slots\n        path_capacity_array (chex.Array): Contains remaining capacity of each lightpath\n        link_capacity_array (chex.Array): Contains remaining capacity of lightpath on each link-slot\n    \"\"\"\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots\n    path_capacity_array: chex.Array  # Contains remaining capacity of each lightpath\n    link_capacity_array: chex.Array  # Contains remaining capacity of lightpath on each link-slot\n    time_since_last_departure: chex.Array  # Time since last departure\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RolloutWrapper","title":"<code>RolloutWrapper</code>","text":"<p>Wrapper to define batch evaluation for generation parameters. Used for genetic algorithm. From: https://github.com/RobertTLange/gymnax/</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>class RolloutWrapper:\n    \"\"\"Wrapper to define batch evaluation for generation parameters. Used for genetic algorithm.\n    From: https://github.com/RobertTLange/gymnax/\n    \"\"\"\n    def __init__(\n        self,\n        model_forward=None,\n        env: environment.Environment = None,\n        num_env_steps: Optional[int] = None,\n        env_params: EnvParams = None,\n    ):\n        \"\"\"Wrapper to define batch evaluation for generation parameters.\"\"\"\n        self.env = env\n        # Define the RL environment &amp; network forward function\n        self.env_params = env_params\n        self.model_forward = model_forward\n\n        if num_env_steps is None:\n            self.num_env_steps = self.env_params.max_requests\n        else:\n            self.num_env_steps = num_env_steps\n\n    @partial(jax.jit, static_argnums=(0, 2))\n    def population_rollout(self, rng_eval, policy_params):\n        \"\"\"Reshape parameter vector and evaluate the generation.\"\"\"\n        # Evaluate population of nets on gymnax task - vmap over rng &amp; params\n        pop_rollout = jax.vmap(self.batch_rollout, in_axes=(None, 0))\n        return pop_rollout(rng_eval, policy_params)\n\n    @partial(jax.jit, static_argnums=(0, 2))\n    def batch_rollout(self, rng_eval, policy_params):\n        \"\"\"Evaluate a generation of networks on RL/Supervised/etc. task.\"\"\"\n        # vmap over different MC fitness evaluations for single network\n        batch_rollout = jax.vmap(self.single_rollout, in_axes=(0, None))\n        return batch_rollout(rng_eval, policy_params)\n\n    @partial(jax.jit, static_argnums=(0, 2))\n    def single_rollout(self, rng_input, policy_params):\n        \"\"\"Rollout a pendulum episode with lax.scan.\"\"\"\n        # Reset the environment\n        rng_reset, rng_episode = jax.random.split(rng_input)\n        obs, state = self.env.reset(rng_reset, self.env_params)\n\n        def policy_step(state_input, tmp):\n            \"\"\"lax.scan compatible step transition in jax env.\"\"\"\n            obs, state, policy_params, rng, cum_reward, valid_mask = state_input\n            rng, rng_step, rng_net = jax.random.split(rng, 3)\n            if self.model_forward is not None:\n                action = self.model_forward(policy_params, obs, rng_net)\n            else:\n                action = self.env.action_space(self.env_params).sample(rng_net)\n            next_obs, next_state, reward, done, _ = self.env.step(\n                rng_step, state, action, self.env_params\n            )\n            new_cum_reward = cum_reward + reward * valid_mask\n            new_valid_mask = valid_mask * (1 - done)\n            carry = [\n                next_obs,\n                next_state,\n                policy_params,\n                rng,\n                new_cum_reward,\n                new_valid_mask,\n            ]\n            y = [obs, action, reward, next_obs, done]\n            return carry, y\n\n        # Scan over episode step loop\n        carry_out, scan_out = jax.lax.scan(\n            policy_step,\n            [\n                obs,\n                state,\n                policy_params,\n                rng_episode,\n                jnp.array([0.0]),\n                jnp.array([1.0]),\n            ],\n            (),\n            self.num_env_steps,\n        )\n        # Return the sum of rewards accumulated by agent in episode rollout\n        obs, action, reward, next_obs, done = scan_out\n        cum_return = carry_out[-2]\n        return obs, action, reward, next_obs, done, cum_return\n\n    @property\n    def input_shape(self):\n        \"\"\"Get the shape of the observation.\"\"\"\n        rng = jax.random.PRNGKey(0)\n        obs, state = self.env.reset(rng, self.env_params)\n        return obs.shape\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RolloutWrapper.input_shape","title":"<code>input_shape</code>  <code>property</code>","text":"<p>Get the shape of the observation.</p>"},{"location":"reference/#xlron.environments.wrappers.RolloutWrapper.__init__","title":"<code>__init__(model_forward=None, env=None, num_env_steps=None, env_params=None)</code>","text":"<p>Wrapper to define batch evaluation for generation parameters.</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>def __init__(\n    self,\n    model_forward=None,\n    env: environment.Environment = None,\n    num_env_steps: Optional[int] = None,\n    env_params: EnvParams = None,\n):\n    \"\"\"Wrapper to define batch evaluation for generation parameters.\"\"\"\n    self.env = env\n    # Define the RL environment &amp; network forward function\n    self.env_params = env_params\n    self.model_forward = model_forward\n\n    if num_env_steps is None:\n        self.num_env_steps = self.env_params.max_requests\n    else:\n        self.num_env_steps = num_env_steps\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RolloutWrapper.batch_rollout","title":"<code>batch_rollout(rng_eval, policy_params)</code>","text":"<p>Evaluate a generation of networks on RL/Supervised/etc. task.</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 2))\ndef batch_rollout(self, rng_eval, policy_params):\n    \"\"\"Evaluate a generation of networks on RL/Supervised/etc. task.\"\"\"\n    # vmap over different MC fitness evaluations for single network\n    batch_rollout = jax.vmap(self.single_rollout, in_axes=(0, None))\n    return batch_rollout(rng_eval, policy_params)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RolloutWrapper.population_rollout","title":"<code>population_rollout(rng_eval, policy_params)</code>","text":"<p>Reshape parameter vector and evaluate the generation.</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 2))\ndef population_rollout(self, rng_eval, policy_params):\n    \"\"\"Reshape parameter vector and evaluate the generation.\"\"\"\n    # Evaluate population of nets on gymnax task - vmap over rng &amp; params\n    pop_rollout = jax.vmap(self.batch_rollout, in_axes=(None, 0))\n    return pop_rollout(rng_eval, policy_params)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.RolloutWrapper.single_rollout","title":"<code>single_rollout(rng_input, policy_params)</code>","text":"<p>Rollout a pendulum episode with lax.scan.</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 2))\ndef single_rollout(self, rng_input, policy_params):\n    \"\"\"Rollout a pendulum episode with lax.scan.\"\"\"\n    # Reset the environment\n    rng_reset, rng_episode = jax.random.split(rng_input)\n    obs, state = self.env.reset(rng_reset, self.env_params)\n\n    def policy_step(state_input, tmp):\n        \"\"\"lax.scan compatible step transition in jax env.\"\"\"\n        obs, state, policy_params, rng, cum_reward, valid_mask = state_input\n        rng, rng_step, rng_net = jax.random.split(rng, 3)\n        if self.model_forward is not None:\n            action = self.model_forward(policy_params, obs, rng_net)\n        else:\n            action = self.env.action_space(self.env_params).sample(rng_net)\n        next_obs, next_state, reward, done, _ = self.env.step(\n            rng_step, state, action, self.env_params\n        )\n        new_cum_reward = cum_reward + reward * valid_mask\n        new_valid_mask = valid_mask * (1 - done)\n        carry = [\n            next_obs,\n            next_state,\n            policy_params,\n            rng,\n            new_cum_reward,\n            new_valid_mask,\n        ]\n        y = [obs, action, reward, next_obs, done]\n        return carry, y\n\n    # Scan over episode step loop\n    carry_out, scan_out = jax.lax.scan(\n        policy_step,\n        [\n            obs,\n            state,\n            policy_params,\n            rng_episode,\n            jnp.array([0.0]),\n            jnp.array([1.0]),\n        ],\n        (),\n        self.num_env_steps,\n    )\n    # Return the sum of rewards accumulated by agent in episode rollout\n    obs, action, reward, next_obs, done = scan_out\n    cum_return = carry_out[-2]\n    return obs, action, reward, next_obs, done, cum_return\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.TimeIt","title":"<code>TimeIt</code>","text":"<p>Context manager for timing execution of code blocks.</p> Source code in <code>xlron/environments/wrappers.py</code> <pre><code>class TimeIt:\n    \"\"\"Context manager for timing execution of code blocks.\"\"\"\n\n    def __init__(self, tag, frames=None):\n        self.tag = tag\n        self.frames = frames\n\n    def __enter__(self):\n        self.start = timeit.default_timer()\n        return self\n\n    def __exit__(self, *args):\n        self.elapsed_secs = timeit.default_timer() - self.start\n        msg = self.tag + (': Elapsed time=%.2fs' % self.elapsed_secs)\n        if self.frames:\n            msg += ', FPS=%.2e' % (self.frames / self.elapsed_secs)\n        print(msg)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.VONEEnvParams","title":"<code>VONEEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_resources</code> <code>Scalar</code> <p>Number of node resources</p> required <code>max_edges</code> <code>Scalar</code> <p>Maximum number of edges</p> required <code>min_node_resources</code> <code>Scalar</code> <p>Minimum number of node resources</p> required <code>max_node_resources</code> <code>Scalar</code> <p>Maximum number of node resources</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for VONE.\n\n    Args:\n        node_resources (chex.Scalar): Number of node resources\n        max_edges (chex.Scalar): Maximum number of edges\n        min_node_resources (chex.Scalar): Minimum number of node resources\n        max_node_resources (chex.Scalar): Maximum number of node resources\n    \"\"\"\n    node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_edges: chex.Scalar = struct.field(pytree_node=False)\n    min_node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_node_resources: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.wrappers.VONEEnvState","title":"<code>VONEEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_capacity_array</code> <code>Array</code> <p>Node capacity array</p> required <code>node_resource_array</code> <code>Array</code> <p>Node resource array</p> required <code>node_departure_array</code> <code>Array</code> <p>Node departure array</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>action_history</code> <code>Array</code> <p>Action history</p> required <code>node_mask_s</code> <code>Array</code> <p>Node mask for source node</p> required <code>node_mask_d</code> <code>Array</code> <p>Node mask for destination node</p> required <code>virtual_topology_patterns</code> <code>Array</code> <p>Virtual topology patterns</p> required <code>values_nodes</code> <code>Array</code> <p>Values for nodes</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for VONE.\n\n    Args:\n        node_capacity_array (chex.Array): Node capacity array\n        node_resource_array (chex.Array): Node resource array\n        node_departure_array (chex.Array): Node departure array\n        action_counter (chex.Array): Action counter\n        action_history (chex.Array): Action history\n        node_mask_s (chex.Array): Node mask for source node\n        node_mask_d (chex.Array): Node mask for destination node\n        virtual_topology_patterns (chex.Array): Virtual topology patterns\n        values_nodes (chex.Array): Values for nodes\n    \"\"\"\n    node_capacity_array: chex.Array\n    node_resource_array: chex.Array\n    node_departure_array: chex.Array\n    action_counter: chex.Array\n    action_history: chex.Array\n    node_mask_s: chex.Array\n    node_mask_d: chex.Array\n    virtual_topology_patterns: chex.Array\n    values_nodes: chex.Array\n</code></pre>"},{"location":"reference/#constituent-functions-of-environments","title":"Constituent functions of environments","text":""},{"location":"reference/#xlron.environments.env_funcs.DeepRMSAEnvState","title":"<code>DeepRMSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for DeepRMSA.</p> <p>Parameters:</p> Name Type Description Default <code>path_stats</code> <code>Array</code> <p>Path stats array containing</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass DeepRMSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for DeepRMSA.\n\n    Args:\n        path_stats (chex.Array): Path stats array containing\n        1. Required slots on path\n        2. Total available slots on path\n        3. Size of 1st free spectrum block\n        4. Avg. free block size\n    \"\"\"\n    path_stats: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.EnvParams","title":"<code>EnvParams</code>","text":"<p>Dataclass to hold environment parameters. Parameters are immutable.</p> <p>Parameters:</p> Name Type Description Default <code>max_requests</code> <code>Scalar</code> <p>Maximum number of requests in an episode</p> required <code>incremental_loading</code> <code>Scalar</code> <p>Incremental increase in traffic load (non-expiring requests)</p> required <code>end_first_blocking</code> <code>Scalar</code> <p>End episode on first blocking event</p> required <code>continuous_operation</code> <code>Scalar</code> <p>If True, do not reset the environment at the end of an episode</p> required <code>edges</code> <code>Array</code> <p>Two column array defining source-dest node-pair edges of the graph</p> required <code>slot_size</code> <code>Scalar</code> <p>Spectral width of frequency slot in GHz</p> required <code>consider_modulation_format</code> <code>Scalar</code> <p>If True, consider modulation format to determine required slots</p> required <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>aggregate_slots</code> <code>Scalar</code> <p>Number of slots to aggregate into a single action (First-Fit with aggregation)</p> required <code>guardband</code> <code>Scalar</code> <p>Guard band in slots</p> required <code>directed_graph</code> <code>bool</code> <p>Whether graph is directed (one fibre per link per transmission direction)</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvParams:\n    \"\"\"Dataclass to hold environment parameters. Parameters are immutable.\n\n    Args:\n        max_requests (chex.Scalar): Maximum number of requests in an episode\n        incremental_loading (chex.Scalar): Incremental increase in traffic load (non-expiring requests)\n        end_first_blocking (chex.Scalar): End episode on first blocking event\n        continuous_operation (chex.Scalar): If True, do not reset the environment at the end of an episode\n        edges (chex.Array): Two column array defining source-dest node-pair edges of the graph\n        slot_size (chex.Scalar): Spectral width of frequency slot in GHz\n        consider_modulation_format (chex.Scalar): If True, consider modulation format to determine required slots\n        link_length_array (chex.Array): Array of link lengths\n        aggregate_slots (chex.Scalar): Number of slots to aggregate into a single action (First-Fit with aggregation)\n        guardband (chex.Scalar): Guard band in slots\n        directed_graph (bool): Whether graph is directed (one fibre per link per transmission direction)\n    \"\"\"\n    max_requests: chex.Scalar = struct.field(pytree_node=False)\n    incremental_loading: chex.Scalar = struct.field(pytree_node=False)\n    end_first_blocking: chex.Scalar = struct.field(pytree_node=False)\n    continuous_operation: chex.Scalar = struct.field(pytree_node=False)\n    edges: chex.Array = struct.field(pytree_node=False)\n    slot_size: chex.Scalar = struct.field(pytree_node=False)\n    consider_modulation_format: chex.Scalar = struct.field(pytree_node=False)\n    link_length_array: chex.Array = struct.field(pytree_node=False)\n    aggregate_slots: chex.Scalar = struct.field(pytree_node=False)\n    guardband: chex.Scalar = struct.field(pytree_node=False)\n    directed_graph: bool = struct.field(pytree_node=False)\n    maximise_throughput: bool = struct.field(pytree_node=False)\n    reward_type: str = struct.field(pytree_node=False)\n    values_bw: chex.Array = struct.field(pytree_node=False)\n    truncate_holding_time: bool = struct.field(pytree_node=False)\n    traffic_array: bool = struct.field(pytree_node=False)\n    pack_path_bits: bool = struct.field(pytree_node=False)\n    relative_arrival_times: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.EnvState","title":"<code>EnvState</code>","text":"<p>Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>current_time</code> <code>Scalar</code> <p>Current time in environment</p> required <code>holding_time</code> <code>Scalar</code> <p>Holding time of current request</p> required <code>total_timesteps</code> <code>Scalar</code> <p>Total timesteps in environment</p> required <code>total_requests</code> <code>Scalar</code> <p>Total requests in environment</p> required <code>graph</code> <code>GraphsTuple</code> <p>Graph tuple representing network state</p> required <code>full_link_slot_mask</code> <code>Array</code> <p>Action mask for link slot action (including if slot actions are aggregated)</p> required <code>accepted_services</code> <code>Array</code> <p>Number of accepted services</p> required <code>accepted_bitrate</code> <code>Array</code> <p>Accepted bitrate</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvState:\n    \"\"\"Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.\n\n    Args:\n        current_time (chex.Scalar): Current time in environment\n        holding_time (chex.Scalar): Holding time of current request\n        total_timesteps (chex.Scalar): Total timesteps in environment\n        total_requests (chex.Scalar): Total requests in environment\n        graph (jraph.GraphsTuple): Graph tuple representing network state\n        full_link_slot_mask (chex.Array): Action mask for link slot action (including if slot actions are aggregated)\n        accepted_services (chex.Array): Number of accepted services\n        accepted_bitrate (chex.Array): Accepted bitrate\n        \"\"\"\n    current_time: chex.Scalar\n    holding_time: chex.Scalar\n    arrival_time: chex.Scalar\n    total_timesteps: chex.Scalar\n    total_requests: chex.Scalar\n    graph: jraph.GraphsTuple\n    full_link_slot_mask: chex.Array\n    accepted_services: chex.Array\n    accepted_bitrate: chex.Array\n    total_bitrate: chex.Array\n    list_of_requests: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.GNModelEnvParams","title":"<code>GNModelEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment state for GN model environments.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment state for GN model environments.\n    \"\"\"\n    ref_lambda: chex.Scalar = struct.field(pytree_node=False)\n    max_spans: chex.Scalar = struct.field(pytree_node=False)\n    max_span_length: chex.Scalar = struct.field(pytree_node=False)\n    nonlinear_coeff: chex.Scalar = struct.field(pytree_node=False)\n    raman_gain_slope: chex.Scalar = struct.field(pytree_node=False)\n    attenuation: chex.Scalar = struct.field(pytree_node=False)\n    attenuation_bar: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_coeff: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_slope: chex.Scalar = struct.field(pytree_node=False)\n    transceiver_snr: chex.Array = struct.field(pytree_node=False)\n    amplifier_noise_figure: chex.Array = struct.field(pytree_node=False)\n    coherent: bool = struct.field(pytree_node=False)\n    num_roadms: chex.Scalar = struct.field(pytree_node=False)\n    roadm_loss: chex.Scalar = struct.field(pytree_node=False)\n    num_spans: chex.Scalar = struct.field(pytree_node=False)\n    launch_power_type: chex.Scalar = struct.field(pytree_node=False)\n    snr_margin: chex.Scalar = struct.field(pytree_node=False)\n    max_snr: chex.Scalar = struct.field(pytree_node=False)\n    max_power: chex.Scalar = struct.field(pytree_node=False)\n    min_power: chex.Scalar = struct.field(pytree_node=False)\n    step_power: chex.Scalar = struct.field(pytree_node=False)\n    last_fit: bool = struct.field(pytree_node=False)\n    default_launch_power: chex.Scalar = struct.field(pytree_node=False)\n    mod_format_correction: bool = struct.field(pytree_node=False)\n    monitor_active_lightpaths: bool = struct.field(pytree_node=False)  # Monitor active lightpaths for throughput calculation\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n    uniform_spans: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.GNModelEnvState","title":"<code>GNModelEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    link_snr_array: chex.Array  # Available SNR on each link\n    channel_centre_bw_array: chex.Array  # Channel centre bandwidth for each active connection\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots (used for lightpath SNR calculation)\n    channel_power_array: chex.Array  # Channel power for each active connection\n    channel_centre_bw_array_prev: chex.Array  # Channel centre bandwidth for each active connection in previous timestep\n    path_index_array_prev: chex.Array  # Contains indices of lightpaths in use on slots in previous timestep\n    channel_power_array_prev: chex.Array  # Channel power for each active connection in previous timestep\n    launch_power_array: chex.Array  # Launch power array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.LogEnvState","title":"<code>LogEnvState</code>","text":"<p>Dataclass to hold environment state for logging.</p> <p>Parameters:</p> Name Type Description Default <code>env_state</code> <code>EnvState</code> <p>Environment state</p> required <code>lengths</code> <code>Scalar</code> <p>Lengths</p> required <code>returns</code> <code>Scalar</code> <p>Returns</p> required <code>cum_returns</code> <code>Scalar</code> <p>Cumulative returns</p> required <code>episode_lengths</code> <code>Scalar</code> <p>Episode lengths</p> required <code>episode_returns</code> <code>Scalar</code> <p>Episode returns</p> required <code>accepted_services</code> <code>Scalar</code> <p>Accepted services</p> required <code>accepted_bitrate</code> <code>Scalar</code> <p>Accepted bitrate</p> required <code>done</code> <code>Scalar</code> <p>Done</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass LogEnvState:\n    \"\"\"Dataclass to hold environment state for logging.\n\n    Args:\n        env_state (EnvState): Environment state\n        lengths (chex.Scalar): Lengths\n        returns (chex.Scalar): Returns\n        cum_returns (chex.Scalar): Cumulative returns\n        episode_lengths (chex.Scalar): Episode lengths\n        episode_returns (chex.Scalar): Episode returns\n        accepted_services (chex.Scalar): Accepted services\n        accepted_bitrate (chex.Scalar): Accepted bitrate\n        done (chex.Scalar): Done\n    \"\"\"\n    env_state: EnvState\n    lengths: float\n    returns: float\n    cum_returns: float\n    accepted_services: int\n    accepted_bitrate: float\n    total_bitrate: float\n    utilisation: float\n    done: bool\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.MultiBandRSAEnvParams","title":"<code>MultiBandRSAEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_start: chex.Scalar = struct.field(pytree_node=False)\n    gap_width: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.MultiBandRSAEnvState","title":"<code>MultiBandRSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RMSAGNModelEnvParams","title":"<code>RMSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulations_array: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RMSAGNModelEnvState","title":"<code>RMSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulation_format_index_array: chex.Array  # Modulation format index for each active connection\n    modulation_format_index_array_prev: chex.Array  # Modulation format index for each active connection in previous timestep\n    mod_format_mask: chex.Array  # Modulation format mask\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RSAEnvParams","title":"<code>RSAEnvParams</code>","text":"<p>               Bases: <code>EnvParams</code></p> <p>Dataclass to hold environment parameters for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>Scalar</code> <p>Number of nodes</p> required <code>num_links</code> <code>Scalar</code> <p>Number of links</p> required <code>link_resources</code> <code>Scalar</code> <p>Number of link resources</p> required <code>k_paths</code> <code>Scalar</code> <p>Number of paths</p> required <code>mean_service_holding_time</code> <code>Scalar</code> <p>Mean service holding time</p> required <code>load</code> <code>Scalar</code> <p>Load</p> required <code>arrival_rate</code> <code>Scalar</code> <p>Arrival rate</p> required <code>path_link_array</code> <code>Array</code> <p>Path link array</p> required <code>random_traffic</code> <code>bool</code> <p>Random traffic matrix for RSA on each reset (else uniform or custom)</p> required <code>max_slots</code> <code>Scalar</code> <p>Maximum number of slots</p> required <code>path_se_array</code> <code>Array</code> <p>Path spectral efficiency array</p> required <code>deterministic_requests</code> <code>bool</code> <p>If True, use deterministic requests</p> required <code>multiple_topologies</code> <code>bool</code> <p>If True, use multiple topologies</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvParams(EnvParams):\n    \"\"\"Dataclass to hold environment parameters for RSA.\n\n    Args:\n        num_nodes (chex.Scalar): Number of nodes\n        num_links (chex.Scalar): Number of links\n        link_resources (chex.Scalar): Number of link resources\n        k_paths (chex.Scalar): Number of paths\n        mean_service_holding_time (chex.Scalar): Mean service holding time\n        load (chex.Scalar): Load\n        arrival_rate (chex.Scalar): Arrival rate\n        path_link_array (chex.Array): Path link array\n        random_traffic (bool): Random traffic matrix for RSA on each reset (else uniform or custom)\n        max_slots (chex.Scalar): Maximum number of slots\n        path_se_array (chex.Array): Path spectral efficiency array\n        deterministic_requests (bool): If True, use deterministic requests\n        multiple_topologies (bool): If True, use multiple topologies\n    \"\"\"\n    num_nodes: chex.Scalar = struct.field(pytree_node=False)\n    num_links: chex.Scalar = struct.field(pytree_node=False)\n    link_resources: chex.Scalar = struct.field(pytree_node=False)\n    k_paths: chex.Scalar = struct.field(pytree_node=False)\n    mean_service_holding_time: chex.Scalar = struct.field(pytree_node=False)\n    load: chex.Scalar = struct.field(pytree_node=False)\n    arrival_rate: chex.Scalar = struct.field(pytree_node=False)\n    path_link_array: chex.Array = struct.field(pytree_node=False)\n    random_traffic: bool = struct.field(pytree_node=False)\n    max_slots: chex.Scalar = struct.field(pytree_node=False)\n    path_se_array: chex.Array = struct.field(pytree_node=False)\n    deterministic_requests: bool = struct.field(pytree_node=False)\n    multiple_topologies: bool = struct.field(pytree_node=False)\n    log_actions: bool = struct.field(pytree_node=False)\n    disable_node_features: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RSAEnvState","title":"<code>RSAEnvState</code>","text":"<p>               Bases: <code>EnvState</code></p> <p>Dataclass to hold environment state for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>request_array</code> <code>Array</code> <p>Request array</p> required <code>link_slot_departure_array</code> <code>Array</code> <p>Link slot departure array</p> required <code>link_slot_mask</code> <code>Array</code> <p>Link slot mask</p> required <code>traffic_matrix</code> <code>Array</code> <p>Traffic matrix</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvState(EnvState):\n    \"\"\"Dataclass to hold environment state for RSA.\n\n    Args:\n        link_slot_array (chex.Array): Link slot array\n        request_array (chex.Array): Request array\n        link_slot_departure_array (chex.Array): Link slot departure array\n        link_slot_mask (chex.Array): Link slot mask\n        traffic_matrix (chex.Array): Traffic matrix\n    \"\"\"\n    link_slot_array: chex.Array\n    request_array: chex.Array\n    link_slot_departure_array: chex.Array\n    link_slot_mask: chex.Array\n    traffic_matrix: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RSAGNModelEnvParams","title":"<code>RSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RSA with GN model.\n    \"\"\"\n    min_snr: chex.Scalar = struct.field(pytree_node=False)\n    fec_threshold: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RSAGNModelEnvState","title":"<code>RSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    active_lightpaths_array: chex.Array  # Active lightpath array. 1 x M array. Each value is a lightpath index. Used to calculate total throughput.\n    active_lightpaths_array_departure: chex.Array  # Active lightpath array departure time.\n    throughput: chex.Array  # Current network throughput\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RSAMultibandEnvParams","title":"<code>RSAMultibandEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RSAMultibandEnvState","title":"<code>RSAMultibandEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.RWALightpathReuseEnvState","title":"<code>RWALightpathReuseEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RWA with lightpath reuse.</p> <p>Parameters:</p> Name Type Description Default <code>path_index_array</code> <code>Array</code> <p>Contains indices of lightpaths in use on slots</p> required <code>path_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of each lightpath</p> required <code>link_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of lightpath on each link-slot</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RWALightpathReuseEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RWA with lightpath reuse.\n\n    Args:\n        path_index_array (chex.Array): Contains indices of lightpaths in use on slots\n        path_capacity_array (chex.Array): Contains remaining capacity of each lightpath\n        link_capacity_array (chex.Array): Contains remaining capacity of lightpath on each link-slot\n    \"\"\"\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots\n    path_capacity_array: chex.Array  # Contains remaining capacity of each lightpath\n    link_capacity_array: chex.Array  # Contains remaining capacity of lightpath on each link-slot\n    time_since_last_departure: chex.Array  # Time since last departure\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.VONEEnvParams","title":"<code>VONEEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_resources</code> <code>Scalar</code> <p>Number of node resources</p> required <code>max_edges</code> <code>Scalar</code> <p>Maximum number of edges</p> required <code>min_node_resources</code> <code>Scalar</code> <p>Minimum number of node resources</p> required <code>max_node_resources</code> <code>Scalar</code> <p>Maximum number of node resources</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for VONE.\n\n    Args:\n        node_resources (chex.Scalar): Number of node resources\n        max_edges (chex.Scalar): Maximum number of edges\n        min_node_resources (chex.Scalar): Minimum number of node resources\n        max_node_resources (chex.Scalar): Maximum number of node resources\n    \"\"\"\n    node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_edges: chex.Scalar = struct.field(pytree_node=False)\n    min_node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_node_resources: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.VONEEnvState","title":"<code>VONEEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_capacity_array</code> <code>Array</code> <p>Node capacity array</p> required <code>node_resource_array</code> <code>Array</code> <p>Node resource array</p> required <code>node_departure_array</code> <code>Array</code> <p>Node departure array</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>action_history</code> <code>Array</code> <p>Action history</p> required <code>node_mask_s</code> <code>Array</code> <p>Node mask for source node</p> required <code>node_mask_d</code> <code>Array</code> <p>Node mask for destination node</p> required <code>virtual_topology_patterns</code> <code>Array</code> <p>Virtual topology patterns</p> required <code>values_nodes</code> <code>Array</code> <p>Values for nodes</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for VONE.\n\n    Args:\n        node_capacity_array (chex.Array): Node capacity array\n        node_resource_array (chex.Array): Node resource array\n        node_departure_array (chex.Array): Node departure array\n        action_counter (chex.Array): Action counter\n        action_history (chex.Array): Action history\n        node_mask_s (chex.Array): Node mask for source node\n        node_mask_d (chex.Array): Node mask for destination node\n        virtual_topology_patterns (chex.Array): Virtual topology patterns\n        values_nodes (chex.Array): Values for nodes\n    \"\"\"\n    node_capacity_array: chex.Array\n    node_resource_array: chex.Array\n    node_departure_array: chex.Array\n    action_counter: chex.Array\n    action_history: chex.Array\n    node_mask_s: chex.Array\n    node_mask_d: chex.Array\n    virtual_topology_patterns: chex.Array\n    values_nodes: chex.Array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.aggregate_slots","title":"<code>aggregate_slots(full_mask, params)</code>","text":"<p>Aggregate slot mask to reduce action space. Only used if the --aggregate_slots flag is set to &gt; 1. Aggregated action is valid if there is one valid slot action within the aggregated action window.</p> <p>Parameters:</p> Name Type Description Default <code>full_mask</code> <code>Array</code> <p>slot mask</p> required <code>params</code> <code>EnvParams</code> <p>environment parameters</p> required <p>Returns:</p> Name Type Description <code>agg_mask</code> <code>Array</code> <p>aggregated slot mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef aggregate_slots(full_mask: chex.Array, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Aggregate slot mask to reduce action space. Only used if the --aggregate_slots flag is set to &gt; 1.\n    Aggregated action is valid if there is one valid slot action within the aggregated action window.\n\n    Args:\n        full_mask: slot mask\n        params: environment parameters\n\n    Returns:\n        agg_mask: aggregated slot mask\n    \"\"\"\n\n    num_actions = math.ceil(params.link_resources/params.aggregate_slots)\n    agg_mask = jnp.zeros((params.k_paths, num_actions), dtype=LARGE_FLOAT_DTYPE)\n\n    def get_max(i, mask_val):\n        \"\"\"Get maximum value of array slice of length aggregate_slots.\"\"\"\n        mask_slice = jax.lax.dynamic_slice(\n                mask_val,\n                (0, i * params.aggregate_slots,),\n                (1,  params.aggregate_slots,),\n            )\n        max_slice = jnp.max(mask_slice).reshape(1, -1)\n        return max_slice\n\n    def update_window_max(i, val):\n        \"\"\"Update ith index 'agg_mask' with max of ith slice of length aggregate_slots from 'full_mask'.\n\n        Args:\n            i: increments as += aggregate_slots\n            val: tuple of (agg_mask, path_mask, path_index).\n        Returns:\n            new_agg_mask: agg_mask is updated with max of path_mask for window size aggregate_slots\n            mask: mask is unchanged\n            path_index: path_index is unchanged\n        \"\"\"\n        agg_mask = val[0]\n        full_mask = val[1]\n        path_index = val[2]\n        new_agg_mask = jax.lax.dynamic_update_slice(\n            agg_mask,\n            get_max(i, full_mask),\n            (path_index, i),\n        )\n        return new_agg_mask, full_mask, path_index\n\n    def apply_to_path_mask(i, val):\n        \"\"\"\n        Loop through each path for num_actions steps and get_window_max at each step.\n\n        Args:\n            i: path index\n            val: tuple of (agg_mask, mask) where mask is original link-slot mask and agg_mask is resulting aggregated mask\n        Returns:\n            new_agg_mask: agg_mask is updated with aggregated path mask\n            mask: mask is unchanged\n        \"\"\"\n        val = (\n            val[0],  # aggregated mask (to be updated)\n            val[1][i].reshape(1, -1),  # mask for path i\n            i  # path index\n        )\n        new_agg_mask = jax.lax.fori_loop(\n            0,\n            num_actions,\n            update_window_max,\n            val,\n        )[0]\n        return new_agg_mask, full_mask\n\n    return jax.lax.fori_loop(\n            0,\n            params.k_paths,\n            apply_to_path_mask,\n            (agg_mask, full_mask),\n        )\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.calculate_path_capacity","title":"<code>calculate_path_capacity(path_length, min_request=100, scale_factor=1.0, alpha=0.0002, NF=4.5, B=10000000000000.0, R_s=100000000000.0, beta_2=-2.17e-26, gamma=0.0012, L_s=100000.0, lambda0=1.55e-06)</code>","text":"<p>From Nevin JOCN paper 2022: https://discovery.ucl.ac.uk/id/eprint/10175456/1/RL_JOCN_accepted.pdf</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def calculate_path_capacity(\n        path_length,\n        min_request=100,  # Minimum data rate request size\n        scale_factor=1.0,  # Scale factor for link capacity\n        alpha=0.2e-3, # Fibre attenuation coefficient\n        NF=4.5,  # Amplifier noise figure\n        B=10e12,  # Total modulated bandwidth\n        R_s=100e9,  # Symbol rate\n        beta_2=-21.7e-27,  # Dispersion parameter\n        gamma=1.2e-3,  # Nonlinear coefficient\n        L_s=100e3,  # Span length\n        lambda0=1550e-9,  # Wavelength\n):\n    \"\"\"From Nevin JOCN paper 2022: https://discovery.ucl.ac.uk/id/eprint/10175456/1/RL_JOCN_accepted.pdf\"\"\"\n    alpha_lin = alpha / 4.343  # Linear attenuation coefficient\n    N_spans = jnp.floor(path_length * 1e3 / L_s)  # Number of fibre spans on path\n    L_eff = (1 - jnp.exp(-alpha_lin * L_s)) / alpha_lin  # Effective length of span in m\n    sigma_2_ase = (jnp.exp(alpha_lin * L_s) - 1) * 10**(NF/10) * 6.626e-34 * 2.998e8 * R_s / lambda0  # ASE noise power\n    span_NSR = jnp.cbrt(2 * sigma_2_ase**2 * alpha_lin * gamma**2 * L_eff**2 *\n                        jnp.log(jnp.pi**2 * jnp.abs(beta_2) * B**2 / alpha_lin) / (jnp.pi * jnp.abs(beta_2) * R_s**2))  # Noise-to-signal ratio per span\n    path_NSR = jnp.where(N_spans &lt; 1, 1, N_spans) * span_NSR  # Noise-to-signal ratio per path\n    path_capacity = 2 * R_s/1e9 * jnp.log2(1 + 1/path_NSR)  # Capacity of path in Gbps\n    # Round link capacity down to nearest increment of minimum request size and apply scale factor\n    path_capacity = jnp.floor(path_capacity * scale_factor / min_request) * min_request\n    return path_capacity\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.calculate_path_stats","title":"<code>calculate_path_stats(state, params, request)</code>","text":"<p>For use in DeepRMSA agent observation space. Calculate: 1. Size of 1st suitable free spectrum block 2. Index of 1st suitable free spectrum block 3. Required slots on path 4. Avg. free block size 5. Free slots</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>stats</code> <code>Array</code> <p>Array of calculated path statistics</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef calculate_path_stats(state: EnvState, params: EnvParams, request: chex.Array) -&gt; chex.Array:\n    \"\"\"For use in DeepRMSA agent observation space.\n    Calculate:\n    1. Size of 1st suitable free spectrum block\n    2. Index of 1st suitable free spectrum block\n    3. Required slots on path\n    4. Avg. free block size\n    5. Free slots\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        stats: Array of calculated path statistics\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_val = jnp.zeros((params.k_paths, 5), dtype=LARGE_FLOAT_DTYPE)\n    # TODO - check if the normalisation is useful\n    def body_fun(i, val):\n        link_resources = jnp.array(params.link_resources, dtype=LARGE_FLOAT_DTYPE)\n        slot_size = jnp.array(params.slot_size, dtype=LARGE_FLOAT_DTYPE)\n        slots = get_path_slots(state.link_slot_array, params, nodes_sd, i)\n        se = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else jnp.array([1], dtype=SMALL_INT_DTYPE)\n        req_slots = jnp.squeeze(required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband))\n        req_slots_norm = req_slots * slot_size / jnp.max(params.values_bw.val)\n        free_slots_norm = jnp.sum(jnp.where(slots == zero, one, zero), promote_integers=False) / link_resources\n        block_sizes = find_block_sizes(slots)\n        first_block_index = jnp.argmax(block_sizes &gt;= req_slots)\n        first_block_index_norm = first_block_index.astype(LARGE_FLOAT_DTYPE) / link_resources\n        first_block_size_norm = jnp.squeeze(\n            jax.lax.dynamic_slice(block_sizes, (first_block_index,), (1,))\n        ) / req_slots.astype(LARGE_FLOAT_DTYPE)\n        avg_block_size_norm = (jnp.sum(block_sizes) /\n                               jnp.max(jnp.array([jnp.sum(find_block_starts(slots), promote_integers=False), 1])) /\n                               req_slots)\n        val = jax.lax.dynamic_update_slice(\n            val,\n            jnp.array([[\n                first_block_size_norm,\n                first_block_index_norm,\n                req_slots_norm,\n                avg_block_size_norm.astype(LARGE_FLOAT_DTYPE),\n                free_slots_norm\n            ]]),\n            (i, 0)\n        )  # N.B. that all values are normalised\n        return val\n\n    stats = jax.lax.fori_loop(\n            0,\n            params.k_paths,\n            body_fun,\n            init_val,\n        )\n\n    return stats\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_action_rmsa_gn_model","title":"<code>check_action_rmsa_gn_model(state, action, params)</code>","text":"<p>Check if action is valid for RSA GN model Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters     action (chex.Array): Action array Returns:     bool: True if action is invalid, False if action is valid</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef check_action_rmsa_gn_model(state: EnvState, action: Optional[chex.Array], params: EnvParams) -&gt; bool:\n    \"\"\"Check if action is valid for RSA GN model\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        action (chex.Array): Action array\n    Returns:\n        bool: True if action is invalid, False if action is valid\n    \"\"\"\n    # Check if action is valid\n    # TODO - log failure reasons in info\n    snr_sufficient_check = check_snr_sufficient(state, params)\n    spectrum_reuse_check = check_no_spectrum_reuse(state.link_slot_array)\n    # jax.debug.print(\"spectrum_reuse_check {}\", spectrum_reuse_check, ordered=True)\n    # jax.debug.print(\"snr_sufficient_check {}\", snr_sufficient_check, ordered=True)\n    return jnp.any(jnp.stack((\n        spectrum_reuse_check,\n        snr_sufficient_check,\n    )))\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_action_rsa","title":"<code>check_action_rsa(state)</code>","text":"<p>Check if action is valid. Combines checks for: - no spectrum reuse</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_action_rsa(state):\n    \"\"\"Check if action is valid.\n    Combines checks for:\n    - no spectrum reuse\n\n    Args:\n        state: current state\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(jnp.stack((\n        check_no_spectrum_reuse(state.link_slot_array),\n    )))\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_action_rwalr","title":"<code>check_action_rwalr(state, action, params)</code>","text":"<p>Combines checks for: - no spectrum reuse - lightpath available and existing</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_action_rwalr(state: EnvState, action: chex.Array, params: EnvParams) -&gt; bool:\n    \"\"\"Combines checks for:\n    - no spectrum reuse\n    - lightpath available and existing\n\n    Args:\n        state: Environment state\n\n    Returns:\n        bool: True if check failed, False if check passed\n\n    \"\"\"\n    return jnp.any(jnp.stack((\n        check_no_spectrum_reuse(state.link_slot_array),\n        jnp.logical_not(check_lightpath_available_and_existing(state, params, action)[0]),\n    )))\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_all_nodes_assigned","title":"<code>check_all_nodes_assigned(node_departure_array, total_requested_nodes)</code>","text":"<p>Count negative values on each node (row) in node departure array, sum them, must equal total requested_nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>Node departure array (N x R) where N is number of nodes and R is number of resources</p> required <code>total_requested_nodes</code> <code>int</code> <p>Total requested nodes (int)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_all_nodes_assigned(node_departure_array: chex.Array, total_requested_nodes: int) -&gt; bool:\n    \"\"\"Count negative values on each node (row) in node departure array, sum them, must equal total requested_nodes.\n\n    Args:\n        node_departure_array: Node departure array (N x R) where N is number of nodes and R is number of resources\n        total_requested_nodes: Total requested nodes (int)\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.sum(jnp.sum(jnp.where(node_departure_array &lt; 0, 1, 0), axis=1)) != total_requested_nodes\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_lightpath_available_and_existing","title":"<code>check_lightpath_available_and_existing(state, params, action)</code>","text":"<p>Check if lightpath is available and existing. Available means that the lightpath does not use slots occupied by a different lightpath. Existing means that the lightpath has already been established.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>lightpath_available_check</code> <code>Tuple[Array, Array, Array, Array]</code> <p>True if lightpath is available</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef check_lightpath_available_and_existing(state: EnvState, params: EnvParams, action: chex.Array) -&gt; (\n        Tuple)[chex.Array, chex.Array, chex.Array, chex.Array]:\n    \"\"\"Check if lightpath is available and existing.\n    Available means that the lightpath does not use slots occupied by a different lightpath.\n    Existing means that the lightpath has already been established.\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        lightpath_available_check: True if lightpath is available\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_index, initial_slot_index = process_path_action(state, params, action)\n    path = get_paths(params, nodes_sd)[path_index]\n    # Get unique lightpath index\n    lightpath_index = get_lightpath_index(params, nodes_sd, path_index)\n    # Get mask for slots that lightpath will occupy\n    # negative numbers used so as not to conflict with lightpath indices\n    new_lightpath_mask = vmap_set_path_links(\n        jnp.full((params.num_links, 1), -2), path, 0, 1, -1\n    )\n    path_index_array = state.path_index_array[:, initial_slot_index].reshape(-1, 1)\n    masked_path_index_array = jnp.where(\n        new_lightpath_mask == -1, path_index_array, -2\n    )\n    lightpath_mask = jnp.where(\n        path_index_array == lightpath_index, -1, -2\n    )  # Allow current lightpath\n    lightpath_existing_check = jnp.array_equal(lightpath_mask, new_lightpath_mask)  # True if all slots are same\n    lightpath_mask = jnp.where(masked_path_index_array == -1, -1, lightpath_mask)  # Allow empty slots\n    # True if all slots are same or empty\n    lightpath_available_check = jnp.logical_or(\n        jnp.array_equal(lightpath_mask, new_lightpath_mask), lightpath_existing_check\n    )\n    curr_lightpath_capacity = jnp.max(\n        jnp.where(new_lightpath_mask == -1, state.link_capacity_array[:, initial_slot_index].reshape(-1, 1), 0)\n    )\n    return lightpath_available_check, lightpath_existing_check, curr_lightpath_capacity, lightpath_index\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_min_two_nodes_assigned","title":"<code>check_min_two_nodes_assigned(node_departure_array)</code>","text":"<p>Count negative values on each node (row) in node departure array, sum them, must be 2 or greater. This check is important if e.g. an action contains 2 nodes the same therefore only assigns 1 node. Return False if check passed, True if check failed</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>Node departure array (N x R) where N is number of nodes and R is number of resources</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_min_two_nodes_assigned(node_departure_array: chex.Array):\n    \"\"\"Count negative values on each node (row) in node departure array, sum them, must be 2 or greater.\n    This check is important if e.g. an action contains 2 nodes the same therefore only assigns 1 node.\n    Return False if check passed, True if check failed\n\n    Args:\n        node_departure_array: Node departure array (N x R) where N is number of nodes and R is number of resources\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.sum(jnp.sum(jnp.where(node_departure_array &lt; 0, 1, 0), axis=1)) &lt;= 1\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_no_spectrum_reuse","title":"<code>check_no_spectrum_reuse(link_slot_array)</code>","text":"<p>slot-=1 when used, should be zero when unoccupied, so check if any &lt; -1 in slot array.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <p>Link slot array (L x S) where L is number of links and S is number of slots</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_no_spectrum_reuse(link_slot_array):\n    \"\"\"slot-=1 when used, should be zero when unoccupied, so check if any &lt; -1 in slot array.\n\n    Args:\n        link_slot_array: Link slot array (L x S) where L is number of links and S is number of slots\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(link_slot_array &lt; -1)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_node_capacities","title":"<code>check_node_capacities(capacity_array)</code>","text":"<p>Sum selected nodes array and check less than node resources.</p> <p>Parameters:</p> Name Type Description Default <code>capacity_array</code> <code>Array</code> <p>Node capacity array (N x 1) where N is number of nodes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_node_capacities(capacity_array: chex.Array) -&gt; bool:\n    \"\"\"Sum selected nodes array and check less than node resources.\n\n    Args:\n        capacity_array: Node capacity array (N x 1) where N is number of nodes\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(capacity_array &lt; 0)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_snr_sufficient","title":"<code>check_snr_sufficient(state, params)</code>","text":"<p>Check if SNR is sufficient for all connections Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters Returns:     jnp.array: 1 if SNR is sufficient for connection else 0</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_snr_sufficient(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Check if SNR is sufficient for all connections\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: 1 if SNR is sufficient for connection else 0\n    \"\"\"\n    # TODO - this check needs to be faster!\n    required_snr_array = get_required_snr_se_kurtosis_array(state.modulation_format_index_array, 2, params)\n    # Transform lightpath index array by getting lightpath value, getting path-link array, and summing inverse link SNRs\n    lightpath_snr_array = get_lightpath_snr(state, params)\n    check_snr_sufficient = jnp.where(lightpath_snr_array &gt;= required_snr_array, 0, 1)\n    # jax.debug.print(\"check_snr_sufficient {}\", check_snr_sufficient, ordered=True)\n    # jax.debug.print(\"required_snr_array {}\", required_snr_array, ordered=True)\n    # jax.debug.print(\"lightpath_snr_array {}\", lightpath_snr_array, ordered=True)\n    # jax.debug.print(\"state.modulation_format_index_array {}\", state.modulation_format_index_array, ordered=True)\n    # jax.debug.print(\"state.channel_centre_bw_array {}\", state.channel_centre_bw_array, ordered=True)\n    # jax.debug.print(\"state.channel_power_array {}\", state.channel_power_array, ordered=True)\n    return jnp.any(check_snr_sufficient)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_topology","title":"<code>check_topology(action_history, topology_pattern)</code>","text":"<p>Check that each unique virtual node (as indicated by topology pattern) is assigned to a consistent physical node i.e. start and end node of ring is same physical node. Method: For each node index in topology pattern, mask action history with that index, then find max value in masked array. If max value is not the same for all values for that virtual node in action history, then return 1, else 0. Array should be all zeroes at the end, so do an any() check on that. e.g. virtual topology pattern = [2,1,3,1,4,1,2]  3 node ring action history = [0,34,4,0,3,1,0] meaning v node \"2\" goes p node 0, v node \"3\" goes p node 4, v node \"4\" goes p node 3 The numbers in-between relate to the slot action. If any value in the array is 1, a virtual node is assigned to multiple different physical nodes. Need to check from both perspectives: 1. For each virtual node, check that all physical nodes are the same 2. For each physical node, check that all virtual nodes are the same</p> <p>Parameters:</p> Name Type Description Default <code>action_history</code> <p>Action history</p> required <code>topology_pattern</code> <p>Topology pattern</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_topology(action_history, topology_pattern):\n    \"\"\"Check that each unique virtual node (as indicated by topology pattern) is assigned to a consistent physical node\n    i.e. start and end node of ring is same physical node.\n    Method:\n    For each node index in topology pattern, mask action history with that index, then find max value in masked array.\n    If max value is not the same for all values for that virtual node in action history, then return 1, else 0.\n    Array should be all zeroes at the end, so do an any() check on that.\n    e.g. virtual topology pattern = [2,1,3,1,4,1,2]  3 node ring\n    action history = [0,34,4,0,3,1,0]\n    meaning v node \"2\" goes p node 0, v node \"3\" goes p node 4, v node \"4\" goes p node 3\n    The numbers in-between relate to the slot action.\n    If any value in the array is 1, a virtual node is assigned to multiple different physical nodes.\n    Need to check from both perspectives:\n    1. For each virtual node, check that all physical nodes are the same\n    2. For each physical node, check that all virtual nodes are the same\n\n    Args:\n        action_history: Action history\n        topology_pattern: Topology pattern\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    def loop_func_virtual(i, val):\n        # Get indices of physical node in action history that correspond to virtual node i\n        masked_val = jnp.where(i == topology_pattern, val, -1)\n        # Get maximum value at those indices (should all be same)\n        max_node = jnp.max(masked_val)\n        # For relevant indices, if max value then return 0 else 1\n        val = jnp.where(masked_val != -1, masked_val != max_node, val)\n        return val\n    def loop_func_physical(i, val):\n        # Get indices of virtual nodes in topology pattern that correspond to physical node i\n        masked_val = jnp.where(i == action_history, val, -1)\n        # Get maximum value at those indices (should all be same)\n        max_node = jnp.max(masked_val)\n        # For relevant indices, if max value then return 0 else 1\n        val = jnp.where(masked_val != -1, masked_val != max_node, val)\n        return val\n    topology_pattern = topology_pattern[::2]  # Only look at node indices, not slot actions\n    action_history = action_history[::2]\n    check_virtual = jax.lax.fori_loop(jnp.min(topology_pattern), jnp.max(topology_pattern)+1, loop_func_virtual, action_history)\n    check_physical = jax.lax.fori_loop(jnp.min(action_history), jnp.max(action_history)+1, loop_func_physical, topology_pattern)\n    check = jnp.concatenate((check_virtual, check_physical))\n    return jnp.any(check)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_unique_nodes","title":"<code>check_unique_nodes(node_departure_array)</code>","text":"<p>Count negative values on each node (row) in node departure array, must not exceed 1.</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>Node departure array (N x R) where N is number of nodes and R is number of resources</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef check_unique_nodes(node_departure_array: chex.Array) -&gt; bool:\n    \"\"\"Count negative values on each node (row) in node departure array, must not exceed 1.\n\n    Args:\n        node_departure_array: Node departure array (N x R) where N is number of nodes and R is number of resources\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(jnp.sum(jnp.where(node_departure_array &lt; zero, one, zero), axis=1, promote_integers=False) &gt; one)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.check_vone_action","title":"<code>check_vone_action(state, remaining_actions, total_requested_nodes)</code>","text":"<p>Check if action is valid. Combines checks for: - sufficient node capacities - unique nodes assigned - minimum two nodes assigned - all requested nodes assigned - correct topology pattern - no spectrum reuse</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>current state</p> required <code>remaining_actions</code> <p>remaining actions</p> required <code>total_requested_nodes</code> <p>total requested nodes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_vone_action(state, remaining_actions, total_requested_nodes):\n    \"\"\"Check if action is valid.\n    Combines checks for:\n    - sufficient node capacities\n    - unique nodes assigned\n    - minimum two nodes assigned\n    - all requested nodes assigned\n    - correct topology pattern\n    - no spectrum reuse\n\n    Args:\n        state: current state\n        remaining_actions: remaining actions\n        total_requested_nodes: total requested nodes\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    checks = jnp.stack((\n        check_node_capacities(state.node_capacity_array),\n        check_unique_nodes(state.node_departure_array),\n        # TODO (VONE) - Remove two nodes check if impairs performance\n        #  (check_all_nodes_assigned is sufficient but fails after last action of request instead of earlier)\n        check_min_two_nodes_assigned(state.node_departure_array),\n        jax.lax.cond(\n            jnp.equal(remaining_actions, jnp.array(1)),\n            lambda x: check_all_nodes_assigned(*x),\n            lambda x: jnp.array(False),\n            (state.node_departure_array, total_requested_nodes)\n        ),\n        jax.lax.cond(\n            jnp.equal(remaining_actions, jnp.array(1)),\n            lambda x: check_topology(*x),\n            lambda x: jnp.array(False),\n            (state.action_history, state.request_array[1])\n        ),\n        check_no_spectrum_reuse(state.link_slot_array),\n    ))\n    #jax.debug.print(\"Checks: {}\", checks, ordered=True)\n    return jnp.any(checks)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.convert_node_probs_to_traffic_matrix","title":"<code>convert_node_probs_to_traffic_matrix(node_probs)</code>","text":"<p>Convert list of node probabilities to symmetric traffic matrix.</p> <p>Parameters:</p> Name Type Description Default <code>node_probs</code> <code>list</code> <p>node probabilities</p> required <p>Returns:</p> Name Type Description <code>traffic_matrix</code> <code>Array</code> <p>traffic matrix</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def convert_node_probs_to_traffic_matrix(node_probs: list) -&gt; chex.Array:\n    \"\"\"Convert list of node probabilities to symmetric traffic matrix.\n\n    Args:\n        node_probs: node probabilities\n\n    Returns:\n        traffic_matrix: traffic matrix\n    \"\"\"\n    matrix = jnp.outer(node_probs, node_probs).astype(SMALL_FLOAT_DTYPE)\n    # Set lead diagonal to zero\n    matrix = jnp.where(jnp.eye(matrix.shape[0]) == 1, 0, matrix)\n    matrix = normalise_traffic_matrix(matrix)\n    return matrix\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.create_run_name","title":"<code>create_run_name(config)</code>","text":"<p>Create name for run based on config flags</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def create_run_name(config: Union[box.Box, dict]) -&gt; str:\n    \"\"\"Create name for run based on config flags\"\"\"\n    env_type = config[\"env_type\"]\n    topology = config[\"topology_name\"]\n    slots = config[\"link_resources\"]\n    gnn = \"_GNN\" if config[\"USE_GNN\"] else \"\"\n    incremental = \"_INC\" if config[\"incremental_loading\"] else \"\"\n    run_name = f\"{env_type}_{topology}_{slots}{gnn}{incremental}\".upper()\n    if config[\"EVAL_HEURISTIC\"]:\n        run_name += f\"_{config['path_heuristic']}\"\n        if env_type.lower() == \"vone\":\n            run_name += f\"_{config['node_heuristic']}\"\n    elif config[\"EVAL_MODEL\"]:\n        run_name += f\"_EVAL\"\n    return run_name\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.decrement_action_counter","title":"<code>decrement_action_counter(state)</code>","text":"<p>Decrement action counter in-place. Used in VONE environments.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def decrement_action_counter(state):\n    \"\"\"Decrement action counter in-place. Used in VONE environments.\"\"\"\n    state.action_counter.at[-1].add(-1)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.finalise_action_rsa","title":"<code>finalise_action_rsa(state, params)</code>","text":"<p>Turn departure times positive.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef finalise_action_rsa(state: EnvState, params: Optional[EnvParams]):\n    \"\"\"Turn departure times positive.\n\n    Args:\n        state: current state\n\n    Returns:\n        state: updated state\n    \"\"\"\n    _, requested_datarate = read_rsa_request(state.request_array)\n    state = state.replace(\n        link_slot_departure_array=make_positive(state.link_slot_departure_array),\n        accepted_services=state.accepted_services + 1,\n        accepted_bitrate=state.accepted_bitrate + requested_datarate[0],\n        total_bitrate=state.total_bitrate + requested_datarate[0]\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.finalise_action_rwalr","title":"<code>finalise_action_rwalr(state, params)</code>","text":"<p>Turn departure times positive.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef finalise_action_rwalr(state: EnvState, params: Optional[EnvParams]):\n    \"\"\"Turn departure times positive.\n\n    Args:\n        state: current state\n\n    Returns:\n        state: updated state\n    \"\"\"\n    _, requested_datarate = read_rsa_request(state.request_array)\n    state = state.replace(\n        link_slot_departure_array=make_positive(state.link_slot_departure_array),\n        accepted_services=state.accepted_services + 1,\n        accepted_bitrate=state.accepted_bitrate + requested_datarate[0],\n        total_bitrate=state.total_bitrate + requested_datarate[0]\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.finalise_vone_action","title":"<code>finalise_vone_action(state)</code>","text":"<p>Turn departure times positive.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef finalise_vone_action(state):\n    \"\"\"Turn departure times positive.\n\n    Args:\n        state: current state\n\n    Returns:\n        state: updated state\n    \"\"\"\n    state = state.replace(\n        node_departure_array=make_positive(state.node_departure_array),\n        link_slot_departure_array=make_positive(state.link_slot_departure_array),\n        accepted_services=state.accepted_services + 1,\n        accepted_bitrate=state.accepted_bitrate  # TODO - get sum of bitrates for requested links\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.format_vone_slot_request","title":"<code>format_vone_slot_request(state, action)</code>","text":"<p>Format slot request for VONE action into format (source-node, slot, destination-node).</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <code>action</code> <code>Array</code> <p>action to format</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: formatted request</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def format_vone_slot_request(state: EnvState, action: chex.Array) -&gt; chex.Array:\n    \"\"\"Format slot request for VONE action into format (source-node, slot, destination-node).\n\n    Args:\n        state: current state\n        action: action to format\n\n    Returns:\n        chex.Array: formatted request\n    \"\"\"\n    remaining_actions = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.action_counter, 2, 1))\n    full_request = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.request_array, 0, 1))\n    unformatted_request = jax.lax.dynamic_slice_in_dim(full_request, (remaining_actions - 1) * 2, 3)\n    node_s = jax.lax.dynamic_slice_in_dim(action, 0, 1)\n    requested_slots = jax.lax.dynamic_slice_in_dim(unformatted_request, 1, 1)\n    node_d = jax.lax.dynamic_slice_in_dim(action, 2, 1)\n    formatted_request = jnp.concatenate((node_s, requested_slots, node_d))\n    return formatted_request\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.generate_arrival_holding_times","title":"<code>generate_arrival_holding_times(key, params)</code>","text":"<p>Generate arrival and holding times based on Poisson distributed events. To understand how sampling from e^-x can be transformed to sample from lambdae^-(x/lambda) see: https://en.wikipedia.org/wiki/Inverse_transform_sampling#Examples Basically, inverse transform sampling is used to sample from a distribution with CDF F(x). The CDF of the exponential distribution (lambdae^-{lambdax}) is F(x) = 1 - e^-{lambdax}. Therefore, the inverse CDF is x = -ln(1-u)/lambda, where u is sample from uniform distribution. Therefore, we need to divide jax.random.exponential() by lambda in order to scale the standard exponential CDF. Experimental histograms of this method compared to random.expovariate() in Python's random library show that the two methods are equivalent. Also see: https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html https://jax.readthedocs.io/en/latest/_autosummary/jax.random.exponential.html</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>PRNG key</p> required <code>params</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>arrival_time</code> <p>Arrival time</p> <code>holding_time</code> <p>Holding time</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef generate_arrival_holding_times(key, params):\n    \"\"\"\n    Generate arrival and holding times based on Poisson distributed events.\n    To understand how sampling from e^-x can be transformed to sample from lambda*e^-(x/lambda) see:\n    https://en.wikipedia.org/wiki/Inverse_transform_sampling#Examples\n    Basically, inverse transform sampling is used to sample from a distribution with CDF F(x).\n    The CDF of the exponential distribution (lambda*e^-{lambda*x}) is F(x) = 1 - e^-{lambda*x}.\n    Therefore, the inverse CDF is x = -ln(1-u)/lambda, where u is sample from uniform distribution.\n    Therefore, we need to divide jax.random.exponential() by lambda in order to scale the standard exponential CDF.\n    Experimental histograms of this method compared to random.expovariate() in Python's random library show that\n    the two methods are equivalent.\n    Also see: https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html\n    https://jax.readthedocs.io/en/latest/_autosummary/jax.random.exponential.html\n\n    Args:\n        key: PRNG key\n        params: Environment parameters\n\n    Returns:\n        arrival_time: Arrival time\n        holding_time: Holding time\n    \"\"\"\n    key_arrival, key_holding = jax.random.split(key, 2)\n    arrival_time = jax.random.exponential(key_arrival, shape=(1,), dtype=SMALL_FLOAT_DTYPE) \\\n                   / params.arrival_rate  # Divide because it is rate (lambda)\n    if params.truncate_holding_time:\n        # For DeepRMSA, need to generate holding times that are less than 2*mean_service_holding_time\n        key_holding = jax.random.split(key, 5)\n        holding_times = jax.vmap(lambda x: jax.random.exponential(x, shape=(1,)) \\\n                                * params.mean_service_holding_time)(key_holding)\n        holding_times = jnp.where(holding_times &lt; 2*params.mean_service_holding_time, holding_times, zero)\n        # Get first non-zero value in holding_times\n        non_zero_index = jnp.nonzero(holding_times, size=1)[0][0]\n        holding_time = jax.lax.dynamic_slice(jnp.squeeze(holding_times), (non_zero_index,), (1,))\n    else:\n        holding_time = jax.random.exponential(key_holding, shape=(1,), dtype=SMALL_FLOAT_DTYPE) \\\n                       * params.mean_service_holding_time  # Multiply because it is mean (1/lambda)\n    return arrival_time, holding_time\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.generate_vone_request","title":"<code>generate_vone_request(key, state, params)</code>","text":"<p>Generate a new request for the VONE environment. The request has two rows. The first row shows the node and slot values. The first three elements of the second row show the number of unique nodes, the total number of steps, and the remaining steps. These first three elements comprise the action counter. The remaining elements of the second row show the virtual topology pattern, i.e. the connectivity of the virtual topology.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef generate_vone_request(key: chex.PRNGKey, state: EnvState, params: EnvParams):\n    \"\"\"Generate a new request for the VONE environment.\n    The request has two rows. The first row shows the node and slot values.\n    The first three elements of the second row show the number of unique nodes, the total number of steps, and the remaining steps.\n    These first three elements comprise the action counter.\n    The remaining elements of the second row show the virtual topology pattern, i.e. the connectivity of the virtual topology.\n    \"\"\"\n    shape = params.max_edges*2+1  # shape of request array\n    key_topology, key_node, key_slot, key_times = jax.random.split(key, 4)\n    # Randomly select topology, node resources, slot resources\n    pattern = jax.random.choice(key_topology, state.virtual_topology_patterns)\n    action_counter = jax.lax.dynamic_slice(pattern, (0,), (3,))\n    topology_pattern = jax.lax.dynamic_slice(pattern, (3,), (pattern.shape[0]-3,))\n    selected_node_values = jax.random.choice(key_node, state.values_nodes, shape=(shape,))\n    selected_bw_values = jax.random.choice(key_slot, params.values_bw.val, shape=(shape,))\n    # Create a mask for odd and even indices\n    mask = jnp.tile(jnp.array([0, 1]), (shape+1) // 2)[:shape]\n    # Vectorized conditional replacement using mask\n    first_row = jnp.where(mask, selected_bw_values, selected_node_values)\n    # Make sure node request values are consistent for same virtual nodes\n    first_row = jax.lax.fori_loop(\n        2,  # Lowest node index in virtual topology requests is 2\n        shape,  # Highest possible node index in virtual topology requests is shape-1\n        lambda i, x: jnp.where(topology_pattern == i, selected_node_values[i], x),\n        first_row\n    )\n    # Mask out unused part of request array\n    first_row = jnp.where(topology_pattern == 0, 0, first_row)\n    # Set times\n    arrival_time, holding_time = generate_arrival_holding_times(key, params)\n    state = state.replace(\n        holding_time=holding_time,\n        current_time=state.current_time + arrival_time,\n        action_counter=action_counter,\n        request_array=jnp.vstack((first_row, topology_pattern)),\n        action_history=init_action_history(params),\n        total_requests=state.total_requests + 1\n    )\n    state = remove_expired_node_requests(state, params) if not params.incremental_loading else state\n    state = remove_expired_services_rsa(state, params) if not params.incremental_loading else state\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_best_modulation_format","title":"<code>get_best_modulation_format(state, path, initial_slot_index, launch_power, params)</code>","text":"<p>Get best modulation format for lightpath. \"Best\" is the highest order that has SNR requirements below available. Try each modulation format, calculate SNR for each, then return the highest order possible. Args:     state (EnvState): Environment state     path (chex.Array): Path array     initial_slot_index (int): Initial slot index     params (EnvParams): Environment parameters Returns:     jnp.array: Acceptable modulation format indices</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(3,))\ndef get_best_modulation_format(state: EnvState, path: chex.Array, initial_slot_index: int, launch_power: chex.Array, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get best modulation format for lightpath. \"Best\" is the highest order that has SNR requirements below available.\n    Try each modulation format, calculate SNR for each, then return the highest order possible.\n    Args:\n        state (EnvState): Environment state\n        path (chex.Array): Path array\n        initial_slot_index (int): Initial slot index\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Acceptable modulation format indices\n    \"\"\"\n    _, requested_datarate = read_rsa_request(state.request_array)\n    mod_format_count = params.modulations_array.val.shape[0]\n    acceptable_mod_format_indices = jnp.full((mod_format_count,), -2)\n\n    def acceptable_modulation_format(i, acceptable_format_indices):\n        req_snr = params.modulations_array.val[i][2] + params.snr_margin\n        se = params.modulations_array.val[i][1]\n        req_slots = required_slots(requested_datarate, se, params.slot_size, params.guardband)\n        # TODO - need to check we don't overwrite values in already occupied slots\n        # Possible approaches:\n        # Check slot occupancy? Probably would need to iterate through for num_slots, but that's an issue\n        # What about we allocate and then fix up later, e.g. could it be possible to just add the modulation format on top without\n        # check sum of path links prior to assigning?\n        #\n        new_state = state.replace(\n            channel_power_array=vmap_set_path_links(\n                state.channel_power_array, path, initial_slot_index, req_slots, launch_power),\n            channel_centre_bw_array=vmap_set_path_links(\n                state.channel_centre_bw_array, path, initial_slot_index, req_slots, params.slot_size)\n        )\n        snr_value = get_minimum_snr_of_channels_on_path(new_state, path, initial_slot_index, req_slots, params)\n        # jax.debug.print(\"snr_value {}\", snr_value, ordered=True)\n        # jax.debug.print(\"req_snr {}\", req_snr, ordered=True)\n        acceptable_format_index = jnp.where(snr_value &gt;= req_snr, i, -1).reshape((1,))\n        acceptable_format_indices = jax.lax.dynamic_update_slice(acceptable_format_indices, acceptable_format_index, (i,))\n        # jax.debug.print(\"acceptable_format_indices {}\", acceptable_format_indices, ordered=True)\n        return acceptable_format_indices\n\n    acceptable_mod_format_indices = jax.lax.fori_loop(\n        0,\n        mod_format_count,\n        acceptable_modulation_format,\n        acceptable_mod_format_indices\n    )\n    return acceptable_mod_format_indices\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_best_modulation_format_simple","title":"<code>get_best_modulation_format_simple(state, path, initial_slot_index, params)</code>","text":"<p>Get modulation format for lightpath. Assume worst case (least Gaussian) modulation format when calculating SNR. Args:     state (EnvState): Environment state     path (chex.Array): Path array     initial_slot_index (int): Initial slot index     params (EnvParams): Environment parameters Returns:     jnp.array: Acceptable modulation format indices</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(3,))\ndef get_best_modulation_format_simple(\n        state: RSAGNModelEnvState, path: chex.Array, initial_slot_index: int, params: RSAGNModelEnvParams\n) -&gt; chex.Array:\n    \"\"\"Get modulation format for lightpath.\n    Assume worst case (least Gaussian) modulation format when calculating SNR.\n    Args:\n        state (EnvState): Environment state\n        path (chex.Array): Path array\n        initial_slot_index (int): Initial slot index\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Acceptable modulation format indices\n    \"\"\"\n    link_snr_array = get_snr_link_array(state, params)\n    snr_value = get_snr_for_path(path, link_snr_array, params)[initial_slot_index] - params.snr_margin  # Margin\n    mod_format_count = params.modulations_array.val.shape[0]\n    acceptable_mod_format_indices = jnp.arange(mod_format_count)\n    req_snr = params.modulations_array.val[:, 2] + params.snr_margin\n    acceptable_mod_format_indices = jnp.where(snr_value &gt;= req_snr,\n                                              acceptable_mod_format_indices,\n                                              jnp.full((mod_format_count,), -2))\n    return acceptable_mod_format_indices\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_centre_frequency","title":"<code>get_centre_frequency(initial_slot_index, num_slots, params)</code>","text":"<p>Get centre frequency for new lightpath</p> <p>Parameters:</p> Name Type Description Default <code>initial_slot_index</code> <code>Array</code> <p>Centre frequency of first slot</p> required <code>num_slots</code> <code>float</code> <p>Number of slots</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Centre frequency for new lightpath</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef get_centre_frequency(initial_slot_index: int, num_slots: int, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Get centre frequency for new lightpath\n\n    Args:\n        initial_slot_index (chex.Array): Centre frequency of first slot\n        num_slots (float): Number of slots\n        params (RSAGNModelEnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Centre frequency for new lightpath\n    \"\"\"\n    slot_centres = (jnp.arange(params.link_resources) - (params.link_resources - 1) / 2) * params.slot_size\n    return slot_centres[initial_slot_index] + ((params.slot_size * (num_slots - 1)) / 2)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_edge_disjoint_paths","title":"<code>get_edge_disjoint_paths(graph)</code>","text":"<p>Get edge disjoint paths between all nodes in graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>graph</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>edge disjoint paths (path is list of edges)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def get_edge_disjoint_paths(graph: nx.Graph) -&gt; dict:\n    \"\"\"Get edge disjoint paths between all nodes in graph.\n\n    Args:\n        graph: graph\n\n    Returns:\n        dict: edge disjoint paths (path is list of edges)\n    \"\"\"\n    result = {n: {} for n in graph}\n    for n1, n2 in itertools.combinations(graph, 2):\n        # Sort by number of links in path\n        # TODO - sort by path length\n        result[n1][n2] = sorted(list(nx.edge_disjoint_paths(graph, n1, n2)), key=len)\n        result[n2][n1] = sorted(list(nx.edge_disjoint_paths(graph, n2, n1)), key=len)\n    return result\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_launch_power","title":"<code>get_launch_power(state, path_action, power_action, params)</code>","text":"<p>Get launch power for new lightpath. N.B. launch power is specified in dBm but is converted to linear units when stored in channel_power_array. This func returns linear units (mW). Path action is used to determine the launch power in the case of tabular launch power type. Power action is used to determine the launch power in the case of RL launch power type. During masking, power action is set as state.launch_power_array[0], which is set by the RL agent. Args:     state (EnvState): Environment state     path_action (chex.Array): Action specifying path index (0 to k_paths-1)     power_action (chex.Array): Action specifying launch power in dBm     params (EnvParams): Environment parameters Returns:     chex.Array: Launch power for new lightpath</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_launch_power(state: EnvState, path_action: chex.Array, power_action: chex.Array, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get launch power for new lightpath. N.B. launch power is specified in dBm but is converted to linear units\n    when stored in channel_power_array. This func returns linear units (mW).\n    Path action is used to determine the launch power in the case of tabular launch power type.\n    Power action is used to determine the launch power in the case of RL launch power type. During masking,\n    power action is set as state.launch_power_array[0], which is set by the RL agent.\n    Args:\n        state (EnvState): Environment state\n        path_action (chex.Array): Action specifying path index (0 to k_paths-1)\n        power_action (chex.Array): Action specifying launch power in dBm\n        params (EnvParams): Environment parameters\n    Returns:\n        chex.Array: Launch power for new lightpath\n    \"\"\"\n    k_path_index, _ = process_path_action(state, params, path_action)\n    if params.launch_power_type == 1:  # Fixed\n        return state.launch_power_array[0]\n    elif params.launch_power_type == 2:  # Tabular (one row per path)\n        nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n        source, dest = nodes_sd\n        i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n        return state.launch_power_array[i+k_path_index]\n    elif params.launch_power_type == 3:  # RL\n        return power_action\n    elif params.launch_power_type == 4:  # Scaled\n        nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n        source, dest = nodes_sd\n        i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n        # Get path length\n        link_length_array = jnp.sum(params.link_length_array.val, axis=1, promote_integers=False)\n        path_length = jnp.sum(link_length_array[i+k_path_index], promote_integers=False)\n        path_link_array = jnp.unpackbits(params.path_link_array.val)[:, params.num_links] if params.pack_path_bits \\\n            else params.path_link_array.val\n        maximum_path_length = jnp.max(jnp.dot(path_link_array, params.link_length_array.val))\n        return state.launch_power_array[0] * (path_length / maximum_path_length)\n    else:\n        raise ValueError(\"Invalid launch power type. Check params.launch_power_type\")\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_lightpath_snr","title":"<code>get_lightpath_snr(state, params)</code>","text":"<p>Get SNR for each link on path. N.B. that in most cases it is more efficient to calculate the SNR for every possible path, rather than a slot-by-slot basis. But in some cases slot-by-slot is better i.e. when kN(N-1)/2 &gt; LS Args:     state (RSAGNModelEnvState): Environment state     params (RSAGNModelEnvParams): Environment parameters</p> <p>Returns:</p> Type Description <code>Array</code> <p>chex.array: SNR for each link on path</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def get_lightpath_snr(state: RSAGNModelEnvParams, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Get SNR for each link on path.\n    N.B. that in most cases it is more efficient to calculate the SNR for every possible path, rather than a slot-by-slot basis.\n    But in some cases slot-by-slot is better i.e. when k*N(N-1)/2 &gt; L*S\n    Args:\n        state (RSAGNModelEnvState): Environment state\n        params (RSAGNModelEnvParams): Environment parameters\n\n    Returns:\n        chex.array: SNR for each link on path\n    \"\"\"\n    # Get the SNR for the channel that the path occupies\n    path_snr_array = jax.vmap(get_snr_for_path, in_axes=(0, None, None))(params.path_link_array.val, state.link_snr_array, params)\n    # Where value in path_index_array matches index of path_snr_array, substitute in SNR value\n    slot_indices = jnp.arange(params.link_resources)\n    lightpath_snr_array = jax.vmap(jax.vmap(lambda x, si: path_snr_array[x][si], in_axes=(0, 0)), in_axes=(0, None))(state.path_index_array, slot_indices)\n    return lightpath_snr_array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_minimum_snr_of_channels_on_path","title":"<code>get_minimum_snr_of_channels_on_path(state, path, slot_index, req_slots, params)</code>","text":"<p>Get the minimum value of the SNR on newly assigned channels. N.B. this requires the link_snr_array to have already been calculated and present in state.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef get_minimum_snr_of_channels_on_path(\n        state: RSAGNModelEnvState, path: chex.Array, slot_index: chex.Array, req_slots: int, params: RSAGNModelEnvParams\n) -&gt; chex.Array:\n    \"\"\"Get the minimum value of the SNR on newly assigned channels.\n    N.B. this requires the link_snr_array to have already been calculated and present in state.\"\"\"\n    snr_value_all_channels = get_snr_for_path(path, state.link_snr_array, params)\n    min_snr_value_sub_channels = jnp.min(\n        jnp.concatenate([\n            snr_value_all_channels[slot_index].reshape((1,)),\n            snr_value_all_channels[slot_index + req_slots - 1].reshape((1,))\n        ], axis=0)\n    )\n    return min_snr_value_sub_channels\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_num_spectral_features","title":"<code>get_num_spectral_features(n_nodes)</code>","text":"<p>Heuristic for number of spectral features based on graph size.</p> <p>Parameters:</p> Name Type Description Default <code>n_nodes</code> <code>int</code> <p>Number of nodes in the graph</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of spectral features to use, clamped between 3 and 15.</p> <code>int</code> <p>Follows log2(n_nodes) scaling as reasonable default.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_num_spectral_features(n_nodes: int) -&gt; int:\n    \"\"\"Heuristic for number of spectral features based on graph size.\n\n    Args:\n        n_nodes: Number of nodes in the graph\n\n    Returns:\n        Number of spectral features to use, clamped between 3 and 15.\n        Follows log2(n_nodes) scaling as reasonable default.\n    \"\"\"\n    return jnp.minimum(jnp.maximum(3, jnp.floor(jnp.log2(n_nodes))), 15).astype(int)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_path_from_path_index_array","title":"<code>get_path_from_path_index_array(path_index_array, path_link_array)</code>","text":"<p>Get path from path index array. Args:     path_index_array (chex.Array): Path index array     path_link_array (chex.Array): Path link array</p> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.array: path index values replaced with binary path-link arrays</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_path_from_path_index_array(path_index_array: chex.Array, path_link_array: chex.Array) -&gt; chex.Array:\n    \"\"\"Get path from path index array.\n    Args:\n        path_index_array (chex.Array): Path index array\n        path_link_array (chex.Array): Path link array\n\n    Returns:\n        jnp.array: path index values replaced with binary path-link arrays\n    \"\"\"\n    # TODO - support unpacking bits (if this function ends up being used)\n    def get_index_from_link(link):\n        return jax.vmap(lambda x: path_link_array[x], in_axes=(0,))(link)\n\n    return jax.vmap(get_index_from_link, in_axes=(0,))(path_index_array)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_path_index_array","title":"<code>get_path_index_array(params, nodes)</code>","text":"<p>Indices of paths between source and destination from path array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_path_index_array(params, nodes):\n    \"\"\"Indices of paths between source and destination from path array\"\"\"\n    # get source and destination nodes in order (for accurate indexing of path-link array)\n    source, dest = nodes.astype(LARGE_INT_DTYPE)\n    i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n    index_array = jax.lax.dynamic_slice(jnp.arange(0, params.path_link_array.shape[0], dtype=LARGE_INT_DTYPE), (i,), (params.k_paths,))\n    return index_array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_path_indices","title":"<code>get_path_indices(s, d, k, N, directed=False)</code>","text":"<p>Get path indices for a given source, destination and number of paths. If source &gt; destination and the graph is directed (two fibres per link, one in each direction) then an offset is added to the index to get the path in the other direction (the offset is the total number source-dest pairs).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>int</code> <p>Source node index</p> required <code>d</code> <code>int</code> <p>Destination node index</p> required <code>k</code> <code>int</code> <p>Number of paths</p> required <code>N</code> <code>int</code> <p>Number of nodes</p> required <code>directed</code> <code>bool</code> <p>Whether graph is directed. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.array: Start index on path-link array for candidate paths</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2, 3, 4))\ndef get_path_indices(s: int, d: int, k: int, N: int, directed: bool = False) -&gt; chex.Array:\n    \"\"\"Get path indices for a given source, destination and number of paths.\n    If source &gt; destination and the graph is directed (two fibres per link, one in each direction) then an offset is\n    added to the index to get the path in the other direction (the offset is the total number source-dest pairs).\n\n    Args:\n        s (int): Source node index\n        d (int): Destination node index\n        k (int): Number of paths\n        N (int): Number of nodes\n        directed (bool, optional): Whether graph is directed. Defaults to False.\n\n    Returns:\n        jnp.array: Start index on path-link array for candidate paths\n    \"\"\"\n    node_indices = jnp.arange(N, dtype=LARGE_INT_DTYPE)\n    indices_to_s = jnp.where(node_indices &lt; s, node_indices, jnp.array(0, dtype=LARGE_INT_DTYPE))\n    indices_to_d = jnp.where(node_indices &lt; d, node_indices, jnp.array(0, dtype=LARGE_INT_DTYPE))\n    # If two fibres per link, add offset to index to get fibre in other direction if source &gt; destination\n    directed_offset = directed * (s &gt; d) * N * (N - 1) * k / 2\n    # The following equation is based on the combinations formula\n    forward = ((N * s + d - jnp.sum(indices_to_s, promote_integers=False) - 2 * s - 1) * k)\n    backward = ((N * d + s - jnp.sum(indices_to_d, promote_integers=False) - 2 * d - 1) * k)\n    return forward * (s &lt; d) + backward * (s &gt; d) + directed_offset.astype(LARGE_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_path_slots","title":"<code>get_path_slots(link_slot_array, params, nodes_sd, i, agg_func='max')</code>","text":"<p>Get slots on each constitutent link of path from link_slot_array (L x S), then aggregate to get (S x 1) representation of slots on path.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>link-slot array</p> required <code>params</code> <code>EnvParams</code> <p>environment parameters</p> required <code>nodes_sd</code> <code>Array</code> <p>source-destination nodes</p> required <code>i</code> <code>int</code> <p>path index</p> required <code>agg_func</code> <code>str</code> <p>aggregation function (max or sum). If max, result will be available slots on path. If sum, result will contain information on edge features.</p> <code>'max'</code> <p>Returns:</p> Name Type Description <code>slots</code> <code>Array</code> <p>slots on path</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 4))\ndef get_path_slots(link_slot_array: chex.Array, params: EnvParams, nodes_sd: chex.Array, i: int, agg_func: str = \"max\") -&gt; chex.Array:\n    \"\"\"Get slots on each constitutent link of path from link_slot_array (L x S),\n    then aggregate to get (S x 1) representation of slots on path.\n\n    Args:\n        link_slot_array: link-slot array\n        params: environment parameters\n        nodes_sd: source-destination nodes\n        i: path index\n        agg_func: aggregation function (max or sum).\n            If max, result will be available slots on path.\n            If sum, result will contain information on edge features.\n\n    Returns:\n        slots: slots on path\n    \"\"\"\n    path = get_paths(params, nodes_sd)[i]\n    path = path.reshape((params.num_links, 1))\n    # Get links and collapse to single dimension\n    num_slots = params.link_resources if agg_func == \"max\" else math.ceil(params.link_resources/params.aggregate_slots)\n    slots = jnp.where(path, link_slot_array, jnp.zeros(num_slots, dtype=LARGE_FLOAT_DTYPE))\n    # Make any -1s positive then get max for each slot across links\n    if agg_func == \"max\":\n        # Use this for getting slots from link_slot_array\n        slots = jnp.max(jnp.absolute(slots), axis=0)\n    elif agg_func == \"sum\":\n        # TODO - consider using an RNN (or S5) to aggregate edge features\n        # Use this (or alternative) for aggregating edge features from GNN\n        slots = jnp.sum(slots, axis=0, promote_integers=False)\n    elif agg_func == \"mean\":\n        # Use this for getting mean value in slot index along path\n        slots = jnp.mean(slots, axis=0)\n    else:\n        raise ValueError(\"agg_func must be 'max' or 'sum' or 'mean'\")\n    return slots\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_paths","title":"<code>get_paths(params, nodes)</code>","text":"<p>Get k paths between source and destination</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_paths(params, nodes):\n    \"\"\"Get k paths between source and destination\"\"\"\n    index_array = get_path_index_array(params, nodes)\n    paths = jnp.take(params.path_link_array.val, index_array, axis=0)\n    if params.pack_path_bits:  # Unpack the bit-packed paths\n        paths = jnp.unpackbits(paths, axis=1)[:, :params.num_links]\n    return paths\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_paths_obs_gn_model","title":"<code>get_paths_obs_gn_model(state, params)</code>","text":"<p>Get observation space for launch power optimization (with numerical stability).</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_paths_obs_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    # TODO - make this just show the stats from just one path at a time\n    \"\"\"Get observation space for launch power optimization (with numerical stability).\"\"\"\n    request_array = state.request_array.reshape((-1,))\n    path_stats = calculate_path_stats(state, params, request_array)\n    # Remove first 3 items of path stats for each path\n    path_stats = path_stats[:, 3:]\n    link_length_array = jnp.sum(params.link_length_array.val, axis=1, promote_integers=False)\n    lightpath_snr_array = get_lightpath_snr(state, params)\n    nodes_sd, requested_datarate = read_rsa_request(request_array)\n    source, dest = nodes_sd\n\n    def calculate_gn_path_stats(k_path_index, init_val):\n        # Get path index\n        path_index = get_path_indices(source, dest, params.k_paths, params.num_nodes,\n                                      directed=params.directed_graph) + k_path_index\n        path_link_array = jnp.unpackbits(params.path_link_array.val, axis=1)[:, :params.num_links] if params.pack_path_bits \\\n            else params.path_link_array.val\n        path = path_link_array[path_index]\n        path_length = jnp.dot(path, link_length_array)\n        max_path_length = jnp.max(jnp.dot(path_link_array, link_length_array))\n        path_length_norm = path_length / max_path_length\n        max_path_length_hops = jnp.max(jnp.sum(path_link_array, axis=1, promote_integers=False))\n        path_length_hops_norm = jnp.sum(path, promote_integers=False).astype(LARGE_FLOAT_DTYPE) / max_path_length_hops\n        # Connections on path\n        num_connections = jnp.where(path == 1, jnp.where(state.channel_power_array &gt; 0, one, zero).sum(axis=1), zero).sum()\n        num_connections_norm = num_connections / jnp.array(params.link_resources, dtype=LARGE_FLOAT_DTYPE)\n        # Mean power of connections on path\n        # make path with row length equal to link_resource (+1 to avoid zero division)\n        mean_power_norm = (jnp.where(path == one, state.channel_power_array.sum(axis=1), zero).sum() /\n                           (jnp.where(num_connections &gt; zero, num_connections, one) * params.max_power))\n        # Mean SNR of connections on the path links\n        max_snr = jnp.array(50, dtype=LARGE_FLOAT_DTYPE)  # Nominal value for max GSNR in dB\n        mean_snr_norm = (jnp.where(path == one, lightpath_snr_array.sum(axis=1), zero).sum(promote_integers=False) /\n                         (jnp.where(num_connections &gt; zero, num_connections, one) * max_snr))\n        return jax.lax.dynamic_update_slice(\n            init_val,\n            jnp.array([[\n                path_length,\n                path_length_hops_norm,\n                num_connections_norm,\n                mean_power_norm,\n                mean_snr_norm\n            ]]),\n            (k_path_index, 0),\n        )\n\n    gn_path_stats = jnp.zeros((params.k_paths, 5), dtype=LARGE_FLOAT_DTYPE)\n    gn_path_stats = jax.lax.fori_loop(\n        0, params.k_paths, calculate_gn_path_stats, gn_path_stats\n    )\n    all_stats = jnp.concatenate([path_stats, gn_path_stats], axis=1)\n    return jnp.concatenate(\n        (\n            jnp.array([source]),\n            requested_datarate / 100.,\n            jnp.array([dest]),\n            jnp.reshape(state.holding_time, (-1,)),\n            jnp.reshape(all_stats, (-1,)),\n        ),\n        axis=0,\n    )\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_paths_se","title":"<code>get_paths_se(params, nodes)</code>","text":"<p>Get max. spectral efficiency of modulation format on k paths between source and destination</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_paths_se(params, nodes):\n    \"\"\"Get max. spectral efficiency of modulation format on k paths between source and destination\"\"\"\n    # get source and destination nodes in order (for accurate indexing of path-link array)\n    index_array = get_path_index_array(params, nodes)\n    return jnp.take(params.path_se_array.val, index_array, axis=0)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_required_snr_se_kurtosis_array","title":"<code>get_required_snr_se_kurtosis_array(modulation_format_index_array, col_index, params)</code>","text":"<p>Convert modulation format index to required SNR or spectral efficiency. Modulation format index array contains the index of the modulation format used by the channel. The modulation index references a row in the modulations array, which contains SNR and SE values.</p> <p>Parameters:</p> Name Type Description Default <code>modulation_format_index_array</code> <code>Array</code> <p>Modulation format index array</p> required <code>col_index</code> <code>int</code> <p>Column index for required SNR or spectral efficiency</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jnp.array: Required SNR for each channel (min. SNR for empty channel (mod. index 0))</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2,))\ndef get_required_snr_se_kurtosis_array(modulation_format_index_array: chex.Array, col_index: int, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Convert modulation format index to required SNR or spectral efficiency.\n    Modulation format index array contains the index of the modulation format used by the channel.\n    The modulation index references a row in the modulations array, which contains SNR and SE values.\n\n    Args:\n        modulation_format_index_array (chex.Array): Modulation format index array\n        col_index (int): Column index for required SNR or spectral efficiency\n        params (RSAGNModelEnvParams): Environment parameters\n\n    Returns:\n        jnp.array: Required SNR for each channel (min. SNR for empty channel (mod. index 0))\n    \"\"\"\n    return jax.vmap(get_required_snr_se_kurtosis_on_link, in_axes=(0, None, None))(modulation_format_index_array, col_index, params)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_snr_link_array","title":"<code>get_snr_link_array(state, params)</code>","text":"<p>Get SNR per link Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters Returns:     jnp.array: SNR per link</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_snr_link_array(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get SNR per link\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: SNR per link\n    \"\"\"\n\n    def get_link_snr(link_index, state, params):\n        # Get channel power, channel centre, bandwidth, and noise figure\n        link_lengths = params.link_length_array[link_index, :]\n        num_spans = jnp.ceil(jnp.sum(link_lengths)*1e3 / params.max_span_length).astype(MED_INT_DTYPE)\n        if params.mod_format_correction:\n            mod_format_link = state.modulation_format_index_array[link_index, :]\n            kurtosis_link = get_required_snr_se_kurtosis_on_link(mod_format_link, 4, params)\n            se_link = get_required_snr_se_kurtosis_on_link(mod_format_link, 1, params)\n        else:\n            kurtosis_link = jnp.zeros(params.link_resources)\n            se_link = jnp.ones(params.link_resources)\n        bw_link = state.channel_centre_bw_array[link_index, :]\n        ch_power_link = state.channel_power_array[link_index, :]\n        required_slots_link = get_required_slots_on_link(bw_link, se_link, params)\n        ch_centres_link = get_centre_freq_on_link(jnp.arange(params.link_resources), required_slots_link, params)\n\n        # Calculate SNR\n        P = dict(\n            num_channels=params.link_resources,\n            num_spans=num_spans,\n            max_spans=params.max_spans,\n            ref_lambda=params.ref_lambda,\n            length=link_lengths,\n            attenuation_i=jnp.array(params.attenuation),\n            attenuation_bar_i=jnp.array(params.attenuation_bar),\n            nonlinear_coeff=jnp.array(params.nonlinear_coeff),\n            raman_gain_slope_i=jnp.array(params.raman_gain_slope),\n            dispersion_coeff=jnp.array(params.dispersion_coeff),\n            dispersion_slope=jnp.array(params.dispersion_slope),\n            coherent=params.coherent,\n            num_roadms=params.num_roadms,\n            roadm_loss=params.roadm_loss,\n            amplifier_noise_figure=params.amplifier_noise_figure.val,\n            transceiver_snr=params.transceiver_snr.val,\n            mod_format_correction=params.mod_format_correction,\n            ch_power_w_i=ch_power_link,\n            ch_centre_i=ch_centres_link*1e9,\n            ch_bandwidth_i=bw_link*1e9,\n            excess_kurtosis_i=kurtosis_link,\n            uniform_spans=params.uniform_spans,\n        )\n        snr = isrs_gn_model.get_snr(**P)[0]\n\n        return snr\n\n    link_snr_array = jax.vmap(get_link_snr, in_axes=(0, None, None))(jnp.arange(params.num_links), state, params)\n    link_snr_array = jnp.nan_to_num(link_snr_array, nan=1e-5)\n    return link_snr_array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.get_spectral_features","title":"<code>get_spectral_features(laplacian, num_features)</code>","text":"<p>Compute spectral node features from symmetric normalized graph Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>adj</code> <p>Adjacency matrix of the graph</p> required <code>num_features</code> <code>int</code> <p>Number of eigenvector features to extract</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (n_nodes, num_features) containing eigenvectors corresponding</p> <code>ndarray</code> <p>to the smallest non-zero eigenvalues of the graph Laplacian.</p> Notes <ul> <li>Skips trivial eigenvectors (those with near-zero eigenvalues)</li> <li>Eigenvectors are ordered by ascending eigenvalue magnitude</li> <li>Runtime is O(n^3) - use only for small/medium graphs</li> <li>Eigenvector signs are arbitrary (may vary between runs)</li> </ul> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def get_spectral_features(laplacian: jnp.array, num_features: int) -&gt; jnp.ndarray:\n    \"\"\"Compute spectral node features from symmetric normalized graph Laplacian.\n\n    Args:\n        adj: Adjacency matrix of the graph\n        num_features: Number of eigenvector features to extract\n\n    Returns:\n        Array of shape (n_nodes, num_features) containing eigenvectors corresponding\n        to the smallest non-zero eigenvalues of the graph Laplacian.\n\n    Notes:\n        - Skips trivial eigenvectors (those with near-zero eigenvalues)\n        - Eigenvectors are ordered by ascending eigenvalue magnitude\n        - Runtime is O(n^3) - use only for small/medium graphs\n        - Eigenvector signs are arbitrary (may vary between runs)\n    \"\"\"\n    n_nodes = laplacian.shape[0]\n    eigenvalues, eigenvectors = jnp.linalg.eigh(laplacian)\n    return eigenvectors[:, :num_features].astype(LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_action_rmsa_gn_model","title":"<code>implement_action_rmsa_gn_model(state, action, params)</code>","text":"<p>Implement action for RSA GN model. Update following arrays: - link_slot_array - link_slot_departure_array - link_snr_array - modulation_format_index_array - channel_power_array - active_path_array Args:     state (EnvState): Environment state     action (chex.Array): Action tuple (first is path action, second is launch_power)     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rmsa_gn_model(\n        state: RSAGNModelEnvState, action: chex.Array, params: RSAGNModelEnvParams\n) -&gt; EnvState:\n    \"\"\"Implement action for RSA GN model. Update following arrays:\n    - link_slot_array\n    - link_slot_departure_array\n    - link_snr_array\n    - modulation_format_index_array\n    - channel_power_array\n    - active_path_array\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action tuple (first is path action, second is launch_power)\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_action, power_action = action\n    path_action = path_action.astype(MED_INT_DTYPE)\n    k_path_index, initial_slot_index = process_path_action(state, params, path_action)\n    lightpath_index = get_lightpath_index(params, nodes_sd, k_path_index)\n    path = get_paths(params, nodes_sd)[k_path_index]\n    launch_power = get_launch_power(state, path_action, power_action, params)\n    # TODO(GN MODEL) - get mod. format based on maximum reach\n    mod_format_index = jax.lax.dynamic_slice(\n        state.mod_format_mask, (path_action,), (1,)\n    ).astype(MED_INT_DTYPE)[0]\n    se = params.modulations_array.val[mod_format_index][1]\n    num_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)\n    # Update link_slot_array and link_slot_departure_array, then other arrays\n    state = implement_path_action(state, path, initial_slot_index, num_slots)\n    state = state.replace(\n        path_index_array=vmap_set_path_links(state.path_index_array, path, initial_slot_index, num_slots-params.guardband, lightpath_index),\n        channel_power_array=vmap_set_path_links(state.channel_power_array, path, initial_slot_index, num_slots-params.guardband, launch_power),\n        modulation_format_index_array=vmap_set_path_links(state.modulation_format_index_array, path, initial_slot_index, num_slots-params.guardband, mod_format_index),\n        channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, initial_slot_index, num_slots-params.guardband, params.slot_size),\n    )\n    # Update link_snr_array\n    state = state.replace(link_snr_array=get_snr_link_array(state, params))\n    # jax.debug.print(\"launch_power {}\", launch_power, ordered=True)\n    # jax.debug.print(\"mod_format_index {}\", mod_format_index, ordered=True)\n    # jax.debug.print(\"initial_slot_index {}\", initial_slot_index, ordered=True)\n    # jax.debug.print(\"state.mod_format_mask {}\", state.mod_format_mask, ordered=True)\n    # jax.debug.print(\"path_snr {}\", get_snr_for_path(path, state.link_snr_array, params), ordered=True)\n    # jax.debug.print(\"required_snr {}\", params.modulations_array.val[mod_format_index][2] + params.snr_margin, ordered=True)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_action_rsa","title":"<code>implement_action_rsa(state, action, params)</code>","text":"<p>Implement action to assign slots on links.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <code>action</code> <code>Array</code> <p>action to implement</p> required <code>params</code> <code>EnvParams</code> <p>environment parameters</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rsa(\n        state: EnvState,\n        action: chex.Array,\n        params: EnvParams,\n) -&gt; EnvState:\n    \"\"\"Implement action to assign slots on links.\n\n    Args:\n        state: current state\n        action: action to implement\n        params: environment parameters\n\n    Returns:\n        state: updated state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_index, initial_slot_index = process_path_action(state, params, action)\n    path = get_paths(params, nodes_sd)[path_index]\n    if params.__class__.__name__ == \"RWALightpathReuseEnvParams\":\n        state = state.replace(\n            link_capacity_array=vmap_update_path_links(\n                state.link_capacity_array, path, initial_slot_index, 1, requested_datarate\n            )\n        )\n        # TODO (Dynamic-RWALR) - to support diverse requested_datarates for RWA-LR, need to update masking\n        # TODO (Dynamic-RWALR) - In order to enable dynamic RWA with lightpath reuse (as opposed to just incremental loading),\n        #  need to keep track of active requests OR just randomly remove connections\n        #  (could do this by using the link_slot_departure array in a novel way... i.e. don't fill it with departure time but current bw)\n        capacity_mask = jnp.where(state.link_capacity_array &lt;= 0., -1., 0.)\n        over_capacity_mask = jnp.where(state.link_capacity_array &lt; 0., -1., 0.)\n        total_mask = capacity_mask + over_capacity_mask\n        state = state.replace(\n            link_slot_array=total_mask,\n            link_slot_departure_array=vmap_update_path_links(state.link_slot_departure_array, path,\n                                                                       initial_slot_index, 1,\n                                                                       state.current_time + state.holding_time)\n        )\n    else:\n        se = get_paths_se(params, nodes_sd)[path_index] if params.consider_modulation_format else one\n        num_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)\n        state = implement_path_action(state, path, initial_slot_index, num_slots)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_action_rsa_gn_model","title":"<code>implement_action_rsa_gn_model(state, action, params)</code>","text":"<p>Implement action for RSA GN model. Update following arrays: - link_slot_array - link_slot_departure_array - link_snr_array - modulation_format_index_array - channel_power_array - active_path_array Args:     state (EnvState): Environment state     action (chex.Array): Action tuple (first is path action, second is launch_power)     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rsa_gn_model(\n        state: RSAGNModelEnvState, action: chex.Array, params: RSAGNModelEnvParams\n) -&gt; EnvState:\n    \"\"\"Implement action for RSA GN model. Update following arrays:\n    - link_slot_array\n    - link_slot_departure_array\n    - link_snr_array\n    - modulation_format_index_array\n    - channel_power_array\n    - active_path_array\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action tuple (first is path action, second is launch_power)\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_action, power_action = action\n    path_action = path_action.astype(MED_INT_DTYPE)\n    k_path_index, initial_slot_index = process_path_action(state, params, path_action)\n    lightpath_index = get_lightpath_index(params, nodes_sd, k_path_index)\n    path = get_paths(params, nodes_sd)[k_path_index]\n    launch_power = get_launch_power(state, path_action, power_action, params)\n    num_slots = required_slots(requested_datarate, 1, params.slot_size, guardband=params.guardband)\n    # Update link_slot_array and link_slot_departure_array, then other arrays\n    state = implement_path_action(state, path, initial_slot_index, num_slots)\n    state = state.replace(\n        path_index_array=vmap_set_path_links(state.path_index_array, path, initial_slot_index, num_slots-params.guardband, lightpath_index),\n        channel_power_array=vmap_set_path_links(state.channel_power_array, path, initial_slot_index, num_slots-params.guardband, launch_power),\n        # TODO - update this to use separate arrays to track channel centres and bandwidths and update with bandwidth (that may or may not equal slot size)\n        channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, initial_slot_index, num_slots-params.guardband, params.slot_size),\n    )\n    if params.monitor_active_lightpaths:\n        state = state.replace(\n            active_lightpaths_array=update_active_lightpaths_array(state, lightpath_index, initial_slot_index, num_slots-params.guardband),\n            active_lightpaths_array_departure=update_active_lightpaths_array_departure(state, -state.current_time-state.holding_time),\n        )\n        # No need to check SNR until end of episode\n        return state\n    # Update link_snr_array\n    state = state.replace(link_snr_array=get_snr_link_array(state, params))\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_action_rwalr","title":"<code>implement_action_rwalr(state, action, params)</code>","text":"<p>For use in RWALightpathReuseEnv. Update link_slot_array and link_slot_departure_array to reflect new lightpath assignment. Update link_capacity_array with new capacity if lightpath is available. Undo link_capacity_update if over capacity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>action</code> <code>Array</code> <p>Action array</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rwalr(state: EnvState, action: chex.Array, params: EnvParams) -&gt; EnvState:\n    \"\"\"For use in RWALightpathReuseEnv.\n    Update link_slot_array and link_slot_departure_array to reflect new lightpath assignment.\n    Update link_capacity_array with new capacity if lightpath is available.\n    Undo link_capacity_update if over capacity.\n\n    Args:\n        state: Environment state\n        action: Action array\n        params: Environment parameters\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_index, initial_slot_index = process_path_action(state, params, action)\n    path = get_paths(params, nodes_sd)[path_index]\n    lightpath_available_check, lightpath_existing_check, curr_lightpath_capacity, lightpath_index = (\n        check_lightpath_available_and_existing(state, params, action)\n    )\n    # Get path capacity - request\n    lightpath_capacity = jax.lax.cond(\n        lightpath_existing_check,\n        lambda x: curr_lightpath_capacity - requested_datarate,  # Subtract requested_datarate from current lightpath\n        lambda x: jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.path_capacity_array, x, 1)) - requested_datarate,  # Get initial capacity of lightpath - request\n        lightpath_index\n    )\n    # Update link_capacity_array with new capacity if lightpath is available\n    state = jax.lax.cond(\n        lightpath_available_check,\n        lambda x: x.replace(\n            link_capacity_array=vmap_set_path_links(\n                state.link_capacity_array, path, initial_slot_index, 1, lightpath_capacity\n            ),\n            path_index_array=vmap_set_path_links(\n                state.path_index_array, path, initial_slot_index, 1, lightpath_index\n            ),\n        ),\n        lambda x: x,\n        state\n    )\n    capacity_mask = jnp.where(state.link_capacity_array &lt;= 0., -1., 0.)\n    over_capacity_mask = jnp.where(state.link_capacity_array &lt; 0., -1., 0.)\n    # Undo link_capacity_update if over capacity\n    # N.B. this will fail if requested capacity is greater than total original capacity of lightpath\n    lightpath_capacity_before_action = jax.lax.cond(\n        lightpath_existing_check,\n        lambda x: curr_lightpath_capacity,  # Subtract requested_datarate from current lightpath\n        lambda x: 1e6,  # Empty slots have high capacity (1e6)\n        # Get initial capacity of lightpath - request\n        None,\n    )\n    state = state.replace(\n        link_capacity_array=jnp.where(over_capacity_mask == -1, lightpath_capacity_before_action, state.link_capacity_array)\n    )\n    # Total mask will be 0 if space still available, -1 if capacity is zero or -2 if over capacity\n    total_mask = capacity_mask + over_capacity_mask\n    # Update link_slot_array and link_slot_departure_array\n    state = state.replace(\n        link_slot_array=total_mask,\n        link_slot_departure_array=vmap_update_path_links(state.link_slot_departure_array, path,\n                                                                 initial_slot_index, 1,\n                                                                 state.current_time + state.holding_time)\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_node_action","title":"<code>implement_node_action(state, s_node, d_node, s_request, d_request, n=2)</code>","text":"<p>Update node capacity, node resource and node departure arrays</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>current state</p> required <code>s_node</code> <code>int</code> <p>source node</p> required <code>d_node</code> <code>int</code> <p>destination node</p> required <code>s_request</code> <code>int</code> <p>source node request</p> required <code>d_request</code> <code>int</code> <p>destination node request</p> required <code>n</code> <code>int</code> <p>number of nodes to implement. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>State</code> <code>EnvState</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def implement_node_action(state: EnvState, s_node: chex.Array, d_node: chex.Array, s_request: chex.Array, d_request: chex.Array, n=2) -&gt; EnvState:\n    \"\"\"Update node capacity, node resource and node departure arrays\n\n    Args:\n        state (State): current state\n        s_node (int): source node\n        d_node (int): destination node\n        s_request (int): source node request\n        d_request (int): destination node request\n        n (int, optional): number of nodes to implement. Defaults to 2.\n\n    Returns:\n        State: updated state\n    \"\"\"\n    node_indices = jnp.arange(state.node_capacity_array.shape[0])\n\n    curr_selected_nodes = jnp.zeros(state.node_capacity_array.shape[0])\n    # d_request -ve so that selected node is +ve (so that argmin works correctly for node resource array update)\n    # curr_selected_nodes is N x 1 array, with requested node resources at index of selected node\n    curr_selected_nodes = update_node_array(node_indices, curr_selected_nodes, d_node, -d_request)\n    curr_selected_nodes = jax.lax.cond(n == 2, lambda x: update_node_array(*x), lambda x: x[1], (node_indices, curr_selected_nodes, s_node, -s_request))\n\n    node_capacity_array = state.node_capacity_array - curr_selected_nodes\n\n    node_resource_array = vmap_update_node_resources(state.node_resource_array, curr_selected_nodes)\n\n    node_departure_array = vmap_update_node_departure(state.node_departure_array, curr_selected_nodes, -state.current_time-state.holding_time)\n\n    state = state.replace(\n        node_capacity_array=node_capacity_array,\n        node_resource_array=node_resource_array,\n        node_departure_array=node_departure_array\n    )\n\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_path_action","title":"<code>implement_path_action(state, path, initial_slot_index, num_slots)</code>","text":"<p>Update link-slot and link-slot departure arrays. Times are set to negative until turned positive by finalisation (after checks).</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>current state</p> required <code>path</code> <code>int</code> <p>path to implement</p> required <code>initial_slot_index</code> <code>int</code> <p>initial slot index</p> required <code>num_slots</code> <code>int</code> <p>number of slots to implement</p> required Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def implement_path_action(state: EnvState, path: chex.Array, initial_slot_index: chex.Array, num_slots: chex.Array) -&gt; EnvState:\n    \"\"\"Update link-slot and link-slot departure arrays.\n    Times are set to negative until turned positive by finalisation (after checks).\n\n    Args:\n        state (State): current state\n        path (int): path to implement\n        initial_slot_index (int): initial slot index\n        num_slots (int): number of slots to implement\n    \"\"\"\n    state = state.replace(\n        link_slot_array=vmap_update_path_links(state.link_slot_array, path, initial_slot_index, num_slots, one),\n        link_slot_departure_array=vmap_update_path_links(state.link_slot_departure_array, path, initial_slot_index, num_slots, state.current_time+state.holding_time)\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.implement_vone_action","title":"<code>implement_vone_action(state, action, total_actions, remaining_actions, params)</code>","text":"<p>Implement action to assign nodes (1, 2, or 0 nodes assigned per action) and assign slots and links for lightpath.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <code>action</code> <code>Array</code> <p>action to implement (node, node, path_slot_action)</p> required <code>total_actions</code> <code>Scalar</code> <p>total number of actions to implement for current request</p> required <code>remaining_actions</code> <code>Scalar</code> <p>remaining actions to implement</p> required <code>k</code> <p>number of paths to consider</p> required <code>N</code> <p>number of nodes to assign</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(4,))\ndef implement_vone_action(\n        state: EnvState,\n        action: chex.Array,\n        total_actions: chex.Scalar,\n        remaining_actions: chex.Scalar,\n        params: EnvParams,\n):\n    \"\"\"Implement action to assign nodes (1, 2, or 0 nodes assigned per action) and assign slots and links for lightpath.\n\n    Args:\n        state: current state\n        action: action to implement (node, node, path_slot_action)\n        total_actions: total number of actions to implement for current request\n        remaining_actions: remaining actions to implement\n        k: number of paths to consider\n        N: number of nodes to assign\n\n    Returns:\n        state: updated state\n    \"\"\"\n    request = jax.lax.dynamic_slice(state.request_array[0], ((remaining_actions-1)*2, ), (3, ))\n    node_request_s = jax.lax.dynamic_slice(request, (2, ), (1, ))\n    requested_datarate = jax.lax.dynamic_slice(request, (1,), (1,))\n    node_request_d = jax.lax.dynamic_slice(request, (0, ), (1, ))\n    nodes = action[::2]\n    path_index, initial_slot_index = process_path_action(state, params, action[1])\n    path = get_paths(params, nodes)[path_index]\n    se = get_paths_se(params, nodes)[path_index] if params.consider_modulation_format else jnp.array([1])\n    num_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)\n\n    # jax.debug.print(\"state.request_array {}\", state.request_array, ordered=True)\n    # jax.debug.print(\"path {}\", path, ordered=True)\n    # jax.debug.print(\"slots {}\", jnp.max(jnp.where(path.reshape(-1,1) == 1, state.link_slot_array, jnp.zeros(params.num_links).reshape(-1,1)), axis=0), ordered=True)\n    # jax.debug.print(\"path_index {}\", path_index, ordered=True)\n    # jax.debug.print(\"initial_slot_index {}\", initial_slot_index, ordered=True)\n    # jax.debug.print(\"requested_datarate {}\", requested_datarate, ordered=True)\n    # jax.debug.print(\"request {}\", request, ordered=True)\n    # jax.debug.print(\"se {}\", se, ordered=True)\n    # jax.debug.print(\"num_slots {}\", num_slots, ordered=True)\n\n    n_nodes = jax.lax.cond(\n        total_actions == remaining_actions,\n        lambda x: 2, lambda x: 1,\n        (total_actions, remaining_actions))\n    path_action_only_check = path_action_only(state.request_array[1], state.action_counter, remaining_actions)\n\n    state = jax.lax.cond(\n        path_action_only_check,\n        lambda x: x[0],\n        lambda x: implement_node_action(x[0], x[1], x[2], x[3], x[4], n=x[5]),\n        (state, nodes[0], nodes[1], node_request_s, node_request_d, n_nodes)\n    )\n\n    state = implement_path_action(state, path, initial_slot_index, num_slots)\n\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_action_counter","title":"<code>init_action_counter()</code>","text":"<p>Initialize action counter. First index is num unique nodes, second index is total steps, final is remaining steps until completion of request. Only used in VONE environments.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_action_counter():\n    \"\"\"Initialize action counter.\n    First index is num unique nodes, second index is total steps, final is remaining steps until completion of request.\n    Only used in VONE environments.\n    \"\"\"\n    return jnp.zeros(3, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_action_history","title":"<code>init_action_history(params)</code>","text":"<p>Initialize action history</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_action_history(params: EnvParams):\n    \"\"\"Initialize action history\"\"\"\n    return jnp.full(params.max_edges*2+1, -1, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_active_lightpaths_array","title":"<code>init_active_lightpaths_array(params)</code>","text":"<p>Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array. M is MIN(max_requests, num_links * link_resources / min_slots). min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:     jnp.array: Active path array (default value -1, empty path)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_active_lightpaths_array(params: RSAGNModelEnvParams):\n    \"\"\"Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array.\n    M is MIN(max_requests, num_links * link_resources / min_slots).\n    min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.\n\n    Args:\n        params (RSAGNModelEnvParams): Environment parameters\n    Returns:\n        jnp.array: Active path array (default value -1, empty path)\n    \"\"\"\n    total_slots = params.num_links * params.link_resources  # total slots on networks\n    min_slots = jnp.max(params.values_bw.val) / params.slot_size  # minimum number of slots required for lightpath\n    return jnp.full((int(total_slots / min_slots), 3), -1, dtype=LARGE_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_active_lightpaths_array_departure","title":"<code>init_active_lightpaths_array_departure(params)</code>","text":"<p>Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array. M is MIN(max_requests, num_links * link_resources / min_slots). min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:     jnp.array: Active path array (default value -1, empty path)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_active_lightpaths_array_departure(params: RSAGNModelEnvParams):\n    \"\"\"Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array.\n    M is MIN(max_requests, num_links * link_resources / min_slots).\n    min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.\n\n    Args:\n        params (RSAGNModelEnvParams): Environment parameters\n    Returns:\n        jnp.array: Active path array (default value -1, empty path)\n    \"\"\"\n    total_slots = params.num_links * params.link_resources  # total slots on networks\n    min_slots = jnp.max(params.values_bw.val) / params.slot_size  # minimum number of slots required for lightpath\n    return jnp.full((int(total_slots / min_slots), 3), 0., dtype=SMALL_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_active_path_array","title":"<code>init_active_path_array(params)</code>","text":"<p>Initialise active path array. Stores details of full path utilised by lightpath on each frequency slot. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Active path array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_active_path_array(params: EnvParams):\n    \"\"\"Initialise active path array. Stores details of full path utilised by lightpath on each frequency slot.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Active path array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources, params.num_links), -1, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_channel_centre_bw_array","title":"<code>init_channel_centre_bw_array(params)</code>","text":"<p>Initialise channel centre array. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Channel centre array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_channel_centre_bw_array(params: EnvParams):\n    \"\"\"Initialise channel centre array.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Channel centre array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources), 0., dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_channel_power_array","title":"<code>init_channel_power_array(params)</code>","text":"<p>Initialise channel power array.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:     jnp.array: Channel power array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_channel_power_array(params: EnvParams):\n    \"\"\"Initialise channel power array.\n\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Channel power array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources), 0., dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_graph_tuple","title":"<code>init_graph_tuple(state, params, adj, exclude_source_dest=False)</code>","text":"<p>Initialise graph tuple for use with Jraph GNNs. Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters     adj (jnp.array): Adjacency matrix of the graph Returns:     jraph.GraphsTuple: Graph tuple</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 3))\ndef init_graph_tuple(state: EnvState, params: EnvParams, adj: jnp.array, exclude_source_dest: bool=False) -&gt; jraph.GraphsTuple:\n    \"\"\"Initialise graph tuple for use with Jraph GNNs.\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        adj (jnp.array): Adjacency matrix of the graph\n    Returns:\n        jraph.GraphsTuple: Graph tuple\n    \"\"\"\n    senders = params.edges.val.T[0]\n    receivers = params.edges.val.T[1]\n\n    # Get source and dest from request array\n    source_dest, datarate = read_rsa_request(state.request_array)\n    # Global feature is normalised data rate of current request\n    globals = jnp.array([datarate / jnp.max(params.values_bw.val)], dtype=LARGE_FLOAT_DTYPE)\n\n    if exclude_source_dest:\n        source_dest_features = jnp.zeros((params.num_nodes, 2), dtype=LARGE_FLOAT_DTYPE)\n    else:\n        source, dest = source_dest[0], source_dest[2]\n        # One-hot encode source and destination (2 additional features)\n        source_dest_features = jnp.zeros((params.num_nodes, 2), dtype=LARGE_FLOAT_DTYPE)\n        source_dest_features = source_dest_features.at[source.astype(MED_INT_DTYPE), 0].set(1)\n        source_dest_features = source_dest_features.at[dest.astype(MED_INT_DTYPE), 1].set(-1)\n\n    spectral_features = get_spectral_features(adj, num_features=3)\n\n    # For dynamic traffic, edge_features are normalised remaining holding time instead of link_slot_array\n    holding_time_edge_features = state.link_slot_departure_array / params.mean_service_holding_time\n\n    if params.__class__.__name__ in [\"RSAGNModelEnvParams\", \"RMSAGNModelEnvParams\"]:\n        # Normalize by max parameters (converted to linear units)\n        max_power = isrs_gn_model.from_dbm(params.max_power)\n        normalized_power = jnp.round(state.channel_power_array / max_power, 3)\n        max_snr = isrs_gn_model.from_db(params.max_snr)\n        normalized_snr = jnp.round(state.link_snr_array / max_snr, 3)\n        edge_features = jnp.stack([normalized_snr, normalized_power], axis=-1)\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n    elif params.__class__.__name__ == \"VONEEnvParams\":\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        node_features = getattr(state, \"node_capacity_array\", jnp.zeros(params.num_nodes, dtype=LARGE_FLOAT_DTYPE))\n        node_features = node_features.reshape(-1, 1)\n        node_features = jnp.concatenate([node_features, spectral_features, source_dest_features], axis=-1)\n    else:\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        # [n_edges] or [n_edges, ...]\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n\n    if params.disable_node_features:\n        node_features = jnp.zeros((1,), dtype=LARGE_FLOAT_DTYPE)\n\n    # Handle undirected graphs (duplicate edges after normalization)\n    if not params.directed_graph:\n        senders_ = jnp.concatenate([senders, receivers])\n        receivers = jnp.concatenate([receivers, senders])\n        senders = senders_\n        edge_features = jnp.repeat(edge_features, 2, axis=0)\n\n    return jraph.GraphsTuple(\n        nodes=node_features,\n        edges=edge_features,\n        senders=senders,\n        receivers=receivers,\n        n_node=jnp.reshape(params.num_nodes, (1,)),\n        n_edge=jnp.reshape(len(senders), (1,)),\n        globals=globals,\n    )\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_link_capacity_array","title":"<code>init_link_capacity_array(params)</code>","text":"<p>Initialise link capacity array. Represents available data rate for lightpath on each link. Default is high value (1e6) for unoccupied slots. Once lightpath established, capacity is determined by corresponding entry in path capacity array.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_capacity_array(params):\n    \"\"\"Initialise link capacity array. Represents available data rate for lightpath on each link.\n    Default is high value (1e6) for unoccupied slots. Once lightpath established, capacity is determined by\n    corresponding entry in path capacity array.\"\"\"\n    return jnp.full((params.num_links, params.link_resources), 1e6)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_link_length_array","title":"<code>init_link_length_array(graph)</code>","text":"<p>Initialise link length array. Args:     graph (nx.Graph): NetworkX graph Returns:</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_length_array(graph: nx.Graph) -&gt; chex.Array:\n    \"\"\"Initialise link length array.\n    Args:\n        graph (nx.Graph): NetworkX graph\n    Returns:\n\n    \"\"\"\n    link_lengths = []\n    for edge in sorted(graph.edges):\n        link_lengths.append(graph.edges[edge][\"weight\"])\n    return jnp.array(link_lengths, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_link_length_array_gn_model","title":"<code>init_link_length_array_gn_model(graph, max_span_length, max_spans)</code>","text":"<p>Initialise link length array for environements that use GN model of physical layer. We assume each link has spans of equal length.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>NetworkX graph</p> required <p>Returns:     jnp.array: Link length array (L x max_spans)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_length_array_gn_model(graph: nx.Graph, max_span_length: int,  max_spans: int) -&gt; chex.Array:\n    \"\"\"Initialise link length array for environements that use GN model of physical layer.\n    We assume each link has spans of equal length.\n\n    Args:\n        graph (nx.Graph): NetworkX graph\n    Returns:\n        jnp.array: Link length array (L x max_spans)\n    \"\"\"\n    link_lengths = []\n    directed = graph.is_directed()\n    graph = graph.to_undirected()\n    edges = sorted(graph.edges)\n    for edge in edges:\n        link_lengths.append(graph.edges[edge][\"weight\"])\n    if directed:\n        for edge in edges:\n            link_lengths.append(graph.edges[edge][\"weight\"])\n    span_length_array = []\n    for length in link_lengths:\n        num_spans = math.ceil(length / max_span_length)\n        avg_span_length = length / num_spans\n        span_lengths = [avg_span_length] * num_spans\n        span_lengths.extend([0] * (max_spans - num_spans))\n        span_length_array.append(span_lengths)\n    return jnp.array(span_length_array, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_link_slot_array","title":"<code>init_link_slot_array(params)</code>","text":"<p>Initialize empty (all zeroes) link-slot array. 0 means slot is free, -1 means occupied. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Link slot array (E x S) where E is number of edges and S is number of slots</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_link_slot_array(params: EnvParams):\n    \"\"\"Initialize empty (all zeroes) link-slot array. 0 means slot is free, -1 means occupied.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Link slot array (E x S) where E is number of edges and S is number of slots\"\"\"\n    return jnp.zeros((params.num_links, params.link_resources), dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_link_slot_mask","title":"<code>init_link_slot_mask(params, agg=1)</code>","text":"<p>Initialize link mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef init_link_slot_mask(params: EnvParams, agg: int = 1):\n    \"\"\"Initialize link mask\"\"\"\n    return jnp.ones(params.k_paths*math.ceil(params.link_resources / agg), dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_link_snr_array","title":"<code>init_link_snr_array(params)</code>","text":"<p>Initialise signal-to-noise ratio (SNR) array. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: SNR array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_snr_array(params: EnvParams):\n    \"\"\"Initialise signal-to-noise ratio (SNR) array.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: SNR array\n    \"\"\"\n    # The SNR is kept in linear units to allow summation of 1/SNR across links\n    return jnp.full((params.num_links, params.link_resources), -1e5, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_mod_format_mask","title":"<code>init_mod_format_mask(params)</code>","text":"<p>Initialize link mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_mod_format_mask(params: EnvParams):\n    \"\"\"Initialize link mask\"\"\"\n    return jnp.full((params.k_paths*params.link_resources,), -1.0, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_modulation_format_index_array","title":"<code>init_modulation_format_index_array(params)</code>","text":"<p>Initialise modulation format index array. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Modulation format index array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_modulation_format_index_array(params: EnvParams):\n    \"\"\"Initialise modulation format index array.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Modulation format index array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources), -1, dtype=MED_INT_DTYPE)  # -1 so that highest order is assumed (closest to Gaussian)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_modulations_array","title":"<code>init_modulations_array(modulations_filepath=None)</code>","text":"<p>Initialise array of maximum spectral efficiency for modulation format on path.</p> <p>Parameters:</p> Name Type Description Default <code>modulations_filepath</code> <code>str</code> <p>Path to CSV file containing modulation formats. Defaults to None.</p> <code>None</code> <p>Returns:     jnp.array: Array of maximum spectral efficiency for modulation format on path.     First two columns are maximum path length and spectral efficiency.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_modulations_array(modulations_filepath: str = None):\n    \"\"\"Initialise array of maximum spectral efficiency for modulation format on path.\n\n    Args:\n        modulations_filepath (str, optional): Path to CSV file containing modulation formats. Defaults to None.\n    Returns:\n        jnp.array: Array of maximum spectral efficiency for modulation format on path.\n        First two columns are maximum path length and spectral efficiency.\n    \"\"\"\n    f = pathlib.Path(modulations_filepath) if modulations_filepath else (\n            pathlib.Path(__file__).parents[1].absolute() / \"data\" / \"modulations\" / \"modulations.csv\")\n    modulations = np.genfromtxt(f, delimiter=',')\n    # Drop empty first row (headers) and column (name)\n    modulations = modulations[1:, 1:]\n    return jnp.array(modulations, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_node_capacity_array","title":"<code>init_node_capacity_array(params)</code>","text":"<p>Initialize node array with uniform resources. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Node capacity array (N x 1) where N is number of nodes</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_node_capacity_array(params: EnvParams):\n    \"\"\"Initialize node array with uniform resources.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Node capacity array (N x 1) where N is number of nodes\"\"\"\n    return jnp.array([params.node_resources] * params.num_nodes, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_node_mask","title":"<code>init_node_mask(params)</code>","text":"<p>Initialize node mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_node_mask(params: EnvParams):\n    \"\"\"Initialize node mask\"\"\"\n    return jnp.ones(params.num_nodes, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_node_resource_array","title":"<code>init_node_resource_array(params)</code>","text":"<p>Array to track node resources occupied by virtual nodes</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_node_resource_array(params: EnvParams):\n    \"\"\"Array to track node resources occupied by virtual nodes\"\"\"\n    return jnp.zeros((params.num_nodes, params.node_resources), dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_path_capacity_array","title":"<code>init_path_capacity_array(link_length_array, path_link_array, min_request=1, scale_factor=1.0, alpha=0.0002, NF=4.5, B=10000000000000.0, R_s=100000000000.0, beta_2=-2.17e-26, gamma=0.0012, L_s=100000.0, lambda0=1.55e-06)</code>","text":"<p>Calculated from Nevin paper: https://api.repository.cam.ac.uk/server/api/core/bitstreams/b80e7a9c-a86b-4b30-a6d6-05017c60b0c8/content</p> <p>Parameters:</p> Name Type Description Default <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>path_link_array</code> <code>Array</code> <p>Array of links on paths</p> required <code>min_request</code> <code>int</code> <p>Minimum data rate request size. Defaults to 100 GBps.</p> <code>1</code> <code>scale_factor</code> <code>float</code> <p>Scale factor for link capacity. Defaults to 1.0.</p> <code>1.0</code> <code>alpha</code> <code>float</code> <p>Fibre attenuation coefficient. Defaults to 0.2e-3 /m</p> <code>0.0002</code> <code>NF</code> <code>float</code> <p>Amplifier noise figure. Defaults to 4.5 dB.</p> <code>4.5</code> <code>B</code> <code>float</code> <p>Total modulated bandwidth. Defaults to 10e12 Hz.</p> <code>10000000000000.0</code> <code>R_s</code> <code>float</code> <p>Symbol rate. Defaults to 100e9 Baud.</p> <code>100000000000.0</code> <code>beta_2</code> <code>float</code> <p>Dispersion parameter. Defaults to -21.7e-27 s^2/m.</p> <code>-2.17e-26</code> <code>gamma</code> <code>float</code> <p>Nonlinear coefficient. Defaults to 1.2e-3 /W/m.</p> <code>0.0012</code> <code>L_s</code> <code>float</code> <p>Span length. Defaults to 100e3 m.</p> <code>100000.0</code> <code>lambda0</code> <code>float</code> <p>Wavelength. Defaults to 1550e-9 m.</p> <code>1.55e-06</code> <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Array of link capacities in Gbps</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_capacity_array(\n        link_length_array: chex.Array,\n        path_link_array: chex.Array,\n        min_request=1,  # Minimum data rate request size\n        scale_factor=1.0,  # Scale factor for link capacity\n        alpha=0.2e-3,  # Fibre attenuation coefficient\n        NF=4.5,  # Amplifier noise figure\n        B=10e12,  # Total modulated bandwidth\n        R_s=100e9,  # Symbol rate\n        beta_2=-21.7e-27,  # Dispersion parameter\n        gamma=1.2e-3,  # Nonlinear coefficient\n        L_s=100e3,  # span length\n        lambda0=1550e-9,  # Wavelength\n) -&gt; chex.Array:\n    \"\"\"Calculated from Nevin paper:\n    https://api.repository.cam.ac.uk/server/api/core/bitstreams/b80e7a9c-a86b-4b30-a6d6-05017c60b0c8/content\n\n    Args:\n        link_length_array (chex.Array): Array of link lengths\n        path_link_array (chex.Array): Array of links on paths\n        min_request (int, optional): Minimum data rate request size. Defaults to 100 GBps.\n        scale_factor (float, optional): Scale factor for link capacity. Defaults to 1.0.\n        alpha (float, optional): Fibre attenuation coefficient. Defaults to 0.2e-3 /m\n        NF (float, optional): Amplifier noise figure. Defaults to 4.5 dB.\n        B (float, optional): Total modulated bandwidth. Defaults to 10e12 Hz.\n        R_s (float, optional): Symbol rate. Defaults to 100e9 Baud.\n        beta_2 (float, optional): Dispersion parameter. Defaults to -21.7e-27 s^2/m.\n        gamma (float, optional): Nonlinear coefficient. Defaults to 1.2e-3 /W/m.\n        L_s (float, optional): Span length. Defaults to 100e3 m.\n        lambda0 (float, optional): Wavelength. Defaults to 1550e-9 m.\n\n    Returns:\n        chex.Array: Array of link capacities in Gbps\n    \"\"\"\n    path_length_array = jnp.dot(path_link_array, link_length_array)\n    path_capacity_array = calculate_path_capacity(\n        path_length_array,\n        min_request=min_request,\n        scale_factor=scale_factor,\n        alpha=alpha,\n        NF=NF,\n        B=B,\n        R_s=R_s,\n        beta_2=beta_2,\n        gamma=gamma,\n        L_s=L_s,\n        lambda0=lambda0,\n    )\n    return path_capacity_array.astype(MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_path_index_array","title":"<code>init_path_index_array(params)</code>","text":"<p>Initialise path index array. Represents index of lightpath occupying each slot.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_index_array(params):\n    \"\"\"Initialise path index array. Represents index of lightpath occupying each slot.\"\"\"\n    return jnp.full((params.num_links, params.link_resources), -1)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_path_length_array","title":"<code>init_path_length_array(path_link_array, graph)</code>","text":"<p>Initialise path length array.</p> <p>Parameters:</p> Name Type Description Default <code>path_link_array</code> <code>Array</code> <p>Path-link array</p> required <code>graph</code> <code>Graph</code> <p>NetworkX graph</p> required <p>Returns:     chex.Array: Path length array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_length_array(path_link_array: chex.Array, graph: nx.Graph) -&gt; chex.Array:\n    \"\"\"Initialise path length array.\n\n    Args:\n        path_link_array (chex.Array): Path-link array\n        graph (nx.Graph): NetworkX graph\n    Returns:\n        chex.Array: Path length array\n    \"\"\"\n    link_length_array = init_link_length_array(graph)\n    path_lengths = jnp.dot(path_link_array, link_length_array)\n    return path_lengths\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_path_link_array","title":"<code>init_path_link_array(graph, k, disjoint=False, weight='weight', directed=False, modulations_array=None, rwa_lr=False, scale_factor=1.0, path_snr=False)</code>","text":"<p>Initialise path-link array. Each path is defined by a link utilisation array (one row in the path-link array). 1 indicates link corresponding to index is used, 0 indicates not used.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>NetworkX graph</p> required <code>k</code> <code>int</code> <p>Number of paths</p> required <code>disjoint</code> <code>bool</code> <p>Whether to use edge-disjoint paths. Defaults to False.</p> <code>False</code> <code>weight</code> <code>str</code> <p>Sort paths by edge attribute. Defaults to \"weight\".</p> <code>'weight'</code> <code>directed</code> <code>bool</code> <p>Whether graph is directed. Defaults to False.</p> <code>False</code> <code>modulations_array</code> <code>Array</code> <p>Array of maximum spectral efficiency for modulation format on path. Defaults to None.</p> <code>None</code> <code>rwa_lr</code> <code>bool</code> <p>Whether the environment is RWA with lightpath reuse (affects path ordering).</p> <code>False</code> <code>path_snr</code> <code>bool</code> <p>If GN model is used, include extra row of zeroes for unutilised paths</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Path-link array (N(N-1)*k x E) where N is number of nodes, E is number of edges, k is number of shortest paths</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_link_array(\n        graph: nx.Graph,\n        k: int,\n        disjoint: bool = False,\n        weight: str = \"weight\",\n        directed: bool = False,\n        modulations_array: chex.Array = None,\n        rwa_lr: bool = False,\n        scale_factor: float = 1.0,\n        path_snr: bool = False,\n) -&gt; chex.Array:\n    \"\"\"Initialise path-link array.\n    Each path is defined by a link utilisation array (one row in the path-link array).\n    1 indicates link corresponding to index is used, 0 indicates not used.\n\n    Args:\n        graph (nx.Graph): NetworkX graph\n        k (int): Number of paths\n        disjoint (bool, optional): Whether to use edge-disjoint paths. Defaults to False.\n        weight (str, optional): Sort paths by edge attribute. Defaults to \"weight\".\n        directed (bool, optional): Whether graph is directed. Defaults to False.\n        modulations_array (chex.Array, optional): Array of maximum spectral efficiency for modulation format on path. Defaults to None.\n        rwa_lr (bool, optional): Whether the environment is RWA with lightpath reuse (affects path ordering).\n        path_snr (bool, optional): If GN model is used, include extra row of zeroes for unutilised paths\n        to ensure correct SNR calculation for empty paths (path index -1).\n\n    Returns:\n        chex.Array: Path-link array (N(N-1)*k x E) where N is number of nodes, E is number of edges, k is number of shortest paths\n    \"\"\"\n    def get_k_shortest_paths(g, source, target, k, weight):\n        return list(\n            islice(nx.shortest_simple_paths(g, source, target, weight=weight), k)\n        )\n\n    def get_k_disjoint_shortest_paths(g, source, target, k, weight):\n        k_paths_disjoint_unsorted = list(nx.edge_disjoint_paths(g, source, target))\n        k_paths_shortest = get_k_shortest_paths(g, source, target, k, weight=weight)\n\n        # Keep disjoint paths and add unique shortest paths until k paths reached\n        disjoint_ids = [tuple(path) for path in k_paths_disjoint_unsorted]\n        k_paths = k_paths_disjoint_unsorted\n        for path in k_paths_shortest:\n            if tuple(path) not in disjoint_ids:\n                k_paths.append(path)\n        k_paths = k_paths[:k]\n        return k_paths\n\n    paths = []\n    edges = sorted(graph.edges)\n\n    # Get the k-shortest paths for each node pair\n    k_path_collections = []\n    get_paths = get_k_disjoint_shortest_paths if disjoint else get_k_shortest_paths\n    for node_pair in combinations(graph.nodes, 2):\n\n        k_paths = get_paths(graph, node_pair[0], node_pair[1], k, weight=weight)\n        k_path_collections.append(k_paths)\n\n    if directed:  # Get paths in reverse direction\n        for node_pair in combinations(graph.nodes, 2):\n            k_paths_rev = get_paths(graph, node_pair[1], node_pair[0], k, weight=weight)\n            k_path_collections.append(k_paths_rev)\n\n    # Sort the paths for each node pair\n    max_missing_paths = 0\n    for k_paths in k_path_collections:\n\n        source, dest = k_paths[0][0], k_paths[0][-1]\n\n        # Sort the paths by # of hops then by length, or just length\n        path_lengths = [nx.path_weight(graph, path, weight='weight') for path in k_paths]\n        path_num_links = [len(path) - 1 for path in k_paths]\n\n        # Get maximum spectral efficiency for modulation format on path\n        if modulations_array is not None and rwa_lr is not True:\n            se_of_path = []\n            modulations_array = modulations_array[::-1]\n            for length in path_lengths:\n                for modulation in modulations_array:\n                    if length &lt;= modulation[0]:\n                        se_of_path.append(modulation[1])\n                        break\n            # Sorting by the num_links/se instead of just path length is observed to improve performance\n            path_weighting = [num_links/se for se, num_links in zip(se_of_path, path_num_links)]\n        elif rwa_lr:\n            path_capacity = [float(calculate_path_capacity(path_length, scale_factor=scale_factor)) for path_length in path_lengths]\n            path_weighting = [num_links/path_capacity for num_links, path_capacity in zip(path_num_links, path_capacity)]\n        elif weight is None:\n            path_weighting = path_num_links\n        else:\n            path_weighting = path_lengths\n\n        # if less then k unique paths, add empty paths\n        empty_path = [0] * len(graph.edges)\n        num_missing_paths = k - len(k_paths)\n        max_missing_paths = max(max_missing_paths, num_missing_paths)\n        k_paths = k_paths + [empty_path] * num_missing_paths\n        path_weighting = path_weighting + [1e6] * num_missing_paths\n        path_lengths = path_lengths + [1e6] * num_missing_paths\n\n        # Sort by number of links then by length (or just by length if weight is specified)\n        unsorted_paths = zip(k_paths, path_weighting, path_lengths)\n        k_paths_sorted = [(source, dest, weighting, path) for path, weighting, _ in sorted(unsorted_paths, key=lambda x: (x[1], 1/x[2]) if weight is None else x[2])]\n\n        # Keep only first k paths\n        k_paths_sorted = k_paths_sorted[:k]\n\n        prev_link_usage = empty_path\n        for k_path in k_paths_sorted:\n            k_path = k_path[-1]\n            link_usage = [0]*len(graph.edges)  # Initialise empty path\n            if sum(k_path) == 0:\n                link_usage = prev_link_usage\n            else:\n                for i in range(len(k_path)-1):\n                    s, d = k_path[i], k_path[i + 1]\n                    for edge_index, edge in enumerate(edges):\n                        condition = (edge[0] == s and edge[1] == d) if directed else \\\n                            ((edge[0] == s and edge[1] == d) or (edge[0] == d and edge[1] == s))\n                        if condition:\n                            link_usage[edge_index] = 1\n            path = link_usage\n            prev_link_usage = link_usage\n            paths.append(path)\n\n    # If using GN model, add extra row of zeroes for empty paths for SNR calculation\n    if path_snr:\n        empty_path = [0] * len(graph.edges)\n        paths.append(empty_path)\n\n    return jnp.array(paths, dtype=SMALL_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_path_se_array","title":"<code>init_path_se_array(path_length_array, modulations_array)</code>","text":"<p>Initialise array of maximum spectral efficiency for highest-order modulation format on path.</p> <p>Parameters:</p> Name Type Description Default <code>path_length_array</code> <code>array</code> <p>Array of path lengths</p> required <code>modulations_array</code> <code>array</code> <p>Array of maximum spectral efficiency for modulation format on path</p> required <p>Returns:</p> Type Description <p>jnp.array: Array of maximum spectral efficiency for on path</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_se_array(path_length_array, modulations_array):\n    \"\"\"Initialise array of maximum spectral efficiency for highest-order modulation format on path.\n\n    Args:\n        path_length_array (jnp.array): Array of path lengths\n        modulations_array (jnp.array): Array of maximum spectral efficiency for modulation format on path\n\n    Returns:\n        jnp.array: Array of maximum spectral efficiency for on path\n    \"\"\"\n    se_list = []\n    # Flip the modulation array so that the shortest path length is first\n    modulations_array = modulations_array[::-1]\n    for length in path_length_array:\n        for modulation in modulations_array:\n            if length &lt;= modulation[0]:\n                se_list.append(modulation[1])\n                break\n    return jnp.array(se_list, dtype=SMALL_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_rsa_request_array","title":"<code>init_rsa_request_array()</code>","text":"<p>Initialize request array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_rsa_request_array():\n    \"\"\"Initialize request array\"\"\"\n    return jnp.zeros(3, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_traffic_matrix","title":"<code>init_traffic_matrix(key, params)</code>","text":"<p>Initialize traffic matrix. Allows for random traffic matrix or uniform traffic matrix. Source-dest traffic requests are sampled probabilistically from the resulting traffic matrix.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>PRNGKey</code> <p>PRNG key</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <p>jnp.array: Traffic matrix</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef init_traffic_matrix(key: chex.PRNGKey, params: EnvParams):\n    \"\"\"Initialize traffic matrix. Allows for random traffic matrix or uniform traffic matrix.\n    Source-dest traffic requests are sampled probabilistically from the resulting traffic matrix.\n\n    Args:\n        key (chex.PRNGKey): PRNG key\n        params (EnvParams): Environment parameters\n\n    Returns:\n        jnp.array: Traffic matrix\n    \"\"\"\n    if params.random_traffic:\n        traffic_matrix = jax.random.uniform(key, shape=(params.num_nodes, params.num_nodes), dtype=SMALL_FLOAT_DTYPE)\n    else:\n        traffic_matrix = jnp.ones((params.num_nodes, params.num_nodes), dtype=SMALL_FLOAT_DTYPE)\n    diag_elements = jnp.diag_indices_from(traffic_matrix)\n    # Set main diagonal to zero so no requests from node to itself\n    traffic_matrix = traffic_matrix.at[diag_elements].set(0)\n    traffic_matrix = normalise_traffic_matrix(traffic_matrix)\n    return traffic_matrix\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_transceiver_amplifier_noise_arrays","title":"<code>init_transceiver_amplifier_noise_arrays(link_resources, ref_lambda, slot_size, noise_data_filepath=None)</code>","text":"<p>Initialise transceiver and amplifier noise arrays. Args:     link_resources (int): Number of link resources     ref_lambda (float): Reference wavelength     slot_size (float): Slot size     noise_data_filepath (str, optional): Path to CSV file containing modulation formats. Defaults to None. Returns:     Tuple[chex.Array, chex.Array]: Transceiver noise array, Amplifier noise array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_transceiver_amplifier_noise_arrays(\n        link_resources: int,\n        ref_lambda: float,\n        slot_size: float,\n        noise_data_filepath: str = None\n) -&gt; Tuple[chex.Array, chex.Array]:\n    \"\"\"Initialise transceiver and amplifier noise arrays.\n    Args:\n        link_resources (int): Number of link resources\n        ref_lambda (float): Reference wavelength\n        slot_size (float): Slot size\n        noise_data_filepath (str, optional): Path to CSV file containing modulation formats. Defaults to None.\n    Returns:\n        Tuple[chex.Array, chex.Array]: Transceiver noise array, Amplifier noise array\n    \"\"\"\n    f = pathlib.Path(noise_data_filepath) if noise_data_filepath else (\n            pathlib.Path(__file__).parents[1].absolute() / \"data\" / \"gn_model\" / \"transceiver_amplifier_data.csv\")\n    noise_data = np.genfromtxt(f, delimiter=',')\n    # Drop empty first row (headers) and column (name)\n    noise_data = noise_data[1:, 1:]\n    # Columns are: wavelength_min_nm,wavelength_max_nm,frequency_min_ghz,frequency_max_ghz,NF_ASE_dB,SNR_TRX_dB\n    frequency_min_ghz = noise_data[:, 2]\n    frequency_max_ghz = noise_data[:, 3]\n    amplifier_noise_db = noise_data[:, 4]  # NF_ASE_dB\n    transceiver_snr_db = noise_data[:, 5]  # SNR_TRX_dB\n\n    # Define slot centres in GHz relative to central wavelength\n    slot_centres = (jnp.arange(link_resources) - (link_resources - 1) / 2) * slot_size\n\n    # Transform relative slot centres to absolute frequencies in GHz\n    ref_frequency_ghz = c / ref_lambda / 1e9\n    slot_frequencies_ghz = ref_frequency_ghz + slot_centres\n\n    # Initialize output arrays\n    transceiver_snr_array = jnp.zeros(link_resources)\n    amplifier_noise_figure_array = jnp.zeros(link_resources)\n\n    # For each slot, find which band it belongs to\n    for i, freq in enumerate(slot_frequencies_ghz):\n        # Find the band this frequency falls into\n        for j in range(len(frequency_min_ghz)):\n            if frequency_min_ghz[j] &lt;= freq &lt;= frequency_max_ghz[j]:\n                transceiver_snr_array = transceiver_snr_array.at[i].set(transceiver_snr_db[j])\n                amplifier_noise_figure_array = amplifier_noise_figure_array.at[i].set(amplifier_noise_db[j])\n                break\n        else:\n            # If frequency is outside all bands, could raise error or use default\n            raise ValueError(f\"Frequency {freq} GHz is outside the defined bands\")\n\n    return transceiver_snr_array, amplifier_noise_figure_array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_virtual_topology_patterns","title":"<code>init_virtual_topology_patterns(pattern_names)</code>","text":"<p>Initialise virtual topology patterns. First 3 digits comprise the \"action counter\": first index is num unique nodes, second index is total steps, final is remaining steps until completion of request. Remaining digits define the topology pattern, with 1 to indicate links and other positive integers are node indices.</p> <p>Parameters:</p> Name Type Description Default <code>pattern_names</code> <code>list</code> <p>List of virtual topology pattern names</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Array of virtual topology patterns</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_virtual_topology_patterns(pattern_names: str) -&gt; chex.Array:\n    \"\"\"Initialise virtual topology patterns.\n    First 3 digits comprise the \"action counter\": first index is num unique nodes, second index is total steps,\n    final is remaining steps until completion of request.\n    Remaining digits define the topology pattern, with 1 to indicate links and other positive integers are node indices.\n\n    Args:\n        pattern_names (list): List of virtual topology pattern names\n\n    Returns:\n        chex.Array: Array of virtual topology patterns\n    \"\"\"\n    patterns = []\n    # TODO - Allow 2 node requests in VONE (check if any modifications necessary other than below)\n    #if \"2_bus\" in pattern_names:\n    #    patterns.append([2, 1, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0])\n    if \"3_bus\" in pattern_names:\n        patterns.append([3, 2, 2, 2, 1, 3, 1, 4])\n    if \"3_ring\" in pattern_names:\n        patterns.append([3, 3, 3, 2, 1, 3, 1, 4, 1, 2])\n    if \"4_bus\" in pattern_names:\n        patterns.append([4, 3, 3, 2, 1, 3, 1, 4, 1, 5])\n    if \"4_ring\" in pattern_names:\n        patterns.append([4, 4, 4, 2, 1, 3, 1, 4, 1, 5, 1, 2])\n    if \"5_bus\" in pattern_names:\n        patterns.append([5, 4, 4, 2, 1, 3, 1, 4, 1, 5, 1, 6])\n    if \"5_ring\" in pattern_names:\n        patterns.append([5, 5, 5, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 2])\n    if \"6_bus\" in pattern_names:\n        patterns.append([6, 5, 5, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7])\n    max_length = max([len(pattern) for pattern in patterns])\n    # Pad patterns with zeroes to match longest\n    for pattern in patterns:\n        pattern.extend([0]*(max_length-len(pattern)))\n    return jnp.array(patterns, dtype=SMALL_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.init_vone_request_array","title":"<code>init_vone_request_array(params)</code>","text":"<p>Initialize request array either with uniform resources</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_vone_request_array(params: EnvParams):\n    \"\"\"Initialize request array either with uniform resources\"\"\"\n    return jnp.zeros((2, params.max_edges*2+1,), dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.make_graph","title":"<code>make_graph(topology_name='conus', topology_directory=None)</code>","text":"<p>Create graph from topology definition. Topologies must be defined in JSON format in the topologies directory and named as the topology name with .json extension.</p> <p>Parameters:</p> Name Type Description Default <code>topology_name</code> <code>str</code> <p>topology name</p> <code>'conus'</code> <code>topology_directory</code> <code>str</code> <p>topology directory</p> <code>None</code> <p>Returns:</p> Name Type Description <code>graph</code> <p>graph</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def make_graph(topology_name: str = \"conus\", topology_directory: str = None):\n    \"\"\"Create graph from topology definition.\n    Topologies must be defined in JSON format in the topologies directory and\n    named as the topology name with .json extension.\n\n    Args:\n        topology_name: topology name\n        topology_directory: topology directory\n\n    Returns:\n        graph: graph\n    \"\"\"\n    topology_path = pathlib.Path(topology_directory) if topology_directory else (\n            pathlib.Path(__file__).parents[1].absolute() / \"data\" / \"topologies\")\n    # Create topology\n    if topology_name == \"4node\":\n        # 4 node ring\n        graph = nx.from_numpy_array(np.array([[0, 1, 0, 1],\n                                            [1, 0, 1, 0],\n                                               [0, 1, 0, 1],\n                                               [1, 0, 1, 0]]))\n        # Add edge weights to graph\n        nx.set_edge_attributes(graph, {(0, 1): 4, (1, 2): 3, (2, 3): 2, (3, 0): 1}, \"weight\")\n    elif topology_name == \"7node\":\n        # 7 node ring\n        graph = nx.from_numpy_array(jnp.array([[0, 1, 0, 0, 0, 0, 1],\n                                               [1, 0, 1, 0, 0, 0, 0],\n                                               [0, 1, 0, 1, 0, 0, 0],\n                                               [0, 0, 1, 0, 1, 0, 0],\n                                               [0, 0, 0, 1, 0, 1, 0],\n                                               [0, 0, 0, 0, 1, 0, 1],\n                                               [1, 0, 0, 0, 0, 1, 0]]))\n        # Add edge weights to graph\n        nx.set_edge_attributes(graph, {(0, 1): 4, (1, 2): 3, (2, 3): 2, (3, 4): 1, (4, 5): 2, (5, 6): 3, (6, 0): 4}, \"weight\")\n    else:\n        with open(topology_path / f\"{topology_name}.json\") as f:\n            graph = nx.node_link_graph(json.load(f))\n    return graph\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.mask_nodes","title":"<code>mask_nodes(state, num_nodes)</code>","text":"<p>Returns mask of valid actions for node selection. 1 for valid action, 0 for invalid action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>num_nodes</code> <code>Scalar</code> <p>Number of nodes</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_nodes(state: EnvState, num_nodes: chex.Scalar) -&gt; EnvState:\n    \"\"\"Returns mask of valid actions for node selection. 1 for valid action, 0 for invalid action.\n\n    Args:\n        state: Environment state\n        num_nodes: Number of nodes\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    total_actions = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.action_counter, 1, 1))\n    remaining_actions = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.action_counter, 2, 1))\n    full_request = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.request_array, 0, 1))\n    virtual_topology = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.request_array, 1, 1))\n    request = jax.lax.dynamic_slice_in_dim(full_request, (remaining_actions - 1) * 2, 3)\n    node_request_s = jax.lax.dynamic_slice_in_dim(request, 2, 1)\n    node_request_d = jax.lax.dynamic_slice_in_dim(request, 0, 1)\n    prev_action = jax.lax.dynamic_slice_in_dim(state.action_history, (remaining_actions) * 2, 3)\n    prev_dest = jax.lax.dynamic_slice_in_dim(prev_action, 0, 1)\n    node_indices = jnp.arange(0, num_nodes)\n    # Get requested indices from request array virtual topology\n    requested_indices = jax.lax.dynamic_slice_in_dim(virtual_topology, (remaining_actions-1)*2, 3)\n    requested_index_d = jax.lax.dynamic_slice_in_dim(requested_indices, 0, 1)\n    # Get index of previous selected node\n    prev_selected_node = jnp.where(virtual_topology == requested_index_d, state.action_history, jnp.full(virtual_topology.shape, -1))\n    # will be current index if node only occurs once in virtual topology or will be different index if occurs more than once\n    prev_selected_index = jnp.argmax(prev_selected_node).astype(MED_INT_DTYPE)\n    prev_selected_node_d = jax.lax.dynamic_slice_in_dim(state.action_history, prev_selected_index, 1)\n\n    # If first action, source and dest both to be assigned -&gt; just mask all nodes based on resources\n    # Thereafter, source must be previous dest. Dest can be any node (except previous allocations).\n    state = state.replace(\n        node_mask_s=jax.lax.cond(\n            jnp.equal(remaining_actions, total_actions),\n            lambda x: jnp.where(\n                state.node_capacity_array &gt;= node_request_s,\n                x,\n                jnp.zeros(num_nodes)\n            ),\n            lambda x: jnp.where(\n                node_indices == prev_dest,\n                x,\n                jnp.zeros(num_nodes)\n            ),\n            jnp.ones(num_nodes),\n        )\n    )\n    state = state.replace(\n        node_mask_d=jnp.where(\n            state.node_capacity_array &gt;= node_request_d,\n            jnp.ones(num_nodes),\n            jnp.zeros(num_nodes)\n        )\n    )\n    # If not first move, set node_mask_d to zero wherever node_mask_s is 1\n    # to avoid same node selection for s and d\n    state = state.replace(\n        node_mask_d=jax.lax.cond(\n            jnp.equal(remaining_actions, total_actions),\n            lambda x: x,\n            lambda x: jnp.where(\n                state.node_mask_s == 1,\n                jnp.zeros(num_nodes),\n                x\n            ),\n            state.node_mask_d,\n        )\n    )\n\n    def mask_previous_selections(i, val):\n        # Disallow previously allocated nodes\n        update_slice = lambda j, x: jax.lax.dynamic_update_slice_in_dim(x, jnp.array([0.]), j, axis=0)\n        val = jax.lax.cond(\n            i % 2 == 0,\n            lambda x: update_slice(x[0][i], x[1]),  # i is node request index\n            lambda x: update_slice(x[0][i+1], x[1]),  # i is slot request index (so add 1 to get next node)\n            (state.action_history, val),\n        )\n        return val\n\n    state = state.replace(\n        node_mask_d=jax.lax.fori_loop(\n            remaining_actions*2,\n            state.action_history.shape[0]-1,\n            mask_previous_selections,\n            state.node_mask_d\n        )\n    )\n    # If requested node index is new then disallow previously allocated nodes\n    # If not new, then must match previously allocated node for that index\n    state = state.replace(\n        node_mask_d=jax.lax.cond(\n            jnp.squeeze(prev_selected_node_d) &gt;= 0,\n            lambda x: jnp.where(\n                node_indices == prev_selected_node_d,\n                x[1],\n                x[0],\n            ),\n            lambda x: x[2],\n            (jnp.zeros(num_nodes), jnp.ones(num_nodes), state.node_mask_d),\n        )\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.mask_slots","title":"<code>mask_slots(state, params, request)</code>","text":"<p>Returns binary mask of valid actions. 1 for valid action, 0 for invalid action.</p> <ol> <li>Check request for source and destination nodes</li> <li>For each path:<ul> <li>Get current slots on path (with padding on end to avoid out of bounds)</li> <li>Get mask for required slots on path</li> <li>Multiply through current slots with required slots mask to check if slots available on path</li> <li>Remove padding from mask</li> <li>Return path mask</li> </ul> </li> <li>Update total mask with path mask</li> <li>If aggregate_slots &gt; 1, aggregate slot mask to reduce action space</li> </ol> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_slots(state: EnvState, params: EnvParams, request: chex.Array) -&gt; EnvState:\n    \"\"\"Returns binary mask of valid actions. 1 for valid action, 0 for invalid action.\n\n    1. Check request for source and destination nodes\n    2. For each path:\n        - Get current slots on path (with padding on end to avoid out of bounds)\n        - Get mask for required slots on path\n        - Multiply through current slots with required slots mask to check if slots available on path\n        - Remove padding from mask\n        - Return path mask\n    3. Update total mask with path mask\n    4. If aggregate_slots &gt; 1, aggregate slot mask to reduce action space\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_mask = jnp.zeros((params.link_resources * params.k_paths), dtype=LARGE_FLOAT_DTYPE)\n\n    def mask_path(i, mask):\n        # Get slots for path\n        slots = get_path_slots(state.link_slot_array, params, nodes_sd, i)\n        # Add padding to slots at end\n        slots = jnp.concatenate((slots, jnp.ones(params.max_slots, dtype=LARGE_FLOAT_DTYPE)))\n        # Convert bandwidth to slots for each path\n        spectral_efficiency = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else one\n        requested_slots = required_slots(requested_datarate, spectral_efficiency, params.slot_size, guardband=params.guardband)\n        # Get mask used to check if request will fit slots\n        request_mask = get_request_mask(requested_slots[0], params)\n\n        def check_slots_available(j, val):\n            # Multiply through by request mask to check if slots available\n            request_slice = jax.lax.dynamic_slice(val, (j,), (params.max_slots,))\n            slot_sum = jnp.sum(request_mask * request_slice, promote_integers=False) &lt;= zero\n            slot_sum = slot_sum.reshape((1,)).astype(LARGE_FLOAT_DTYPE)\n            return jax.lax.dynamic_update_slice(val, slot_sum, (j,))\n\n        # Mask out slots that are not valid\n        path_mask = jax.lax.fori_loop(\n            0,\n            int(params.link_resources+1),  # No need to check last requested_slots-1 slots\n            check_slots_available,\n            slots,\n        )\n        # Cut off padding\n        path_mask = jax.lax.dynamic_slice(path_mask, (0,), (params.link_resources,))\n        # Update total mask with path mask\n        mask = jax.lax.dynamic_update_slice(mask, path_mask, (i * params.link_resources,))\n        return mask\n\n    # Loop over each path\n    link_slot_mask = jax.lax.fori_loop(0, params.k_paths, mask_path, init_mask)\n    if params.aggregate_slots &gt; 1:\n        # Full link slot mask is used in process_path_action to get the correct slot from the aggregated slot action\n        state = state.replace(full_link_slot_mask=link_slot_mask)\n        link_slot_mask, _ = aggregate_slots(link_slot_mask.reshape(params.k_paths, -1), params)\n        link_slot_mask = link_slot_mask.reshape(-1)\n    state = state.replace(link_slot_mask=link_slot_mask)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.mask_slots_rmsa_gn_model","title":"<code>mask_slots_rmsa_gn_model(state, params, request)</code>","text":"<p>For use in RSAGNModelEnv. 1. For each path:     1.1 Get path slots     1.2 Get launch power</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>RSAGNModelEnvState</code> <p>Environment state</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_slots_rmsa_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams, request: chex.Array) -&gt; EnvState:\n    \"\"\"For use in RSAGNModelEnv.\n    1. For each path:\n        1.1 Get path slots\n        1.2 Get launch power\n\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_mask = jnp.zeros((params.link_resources * params.k_paths))\n\n    def mask_path(i, mask):\n        path = get_paths(params, nodes_sd)[i]\n        # Get slots for path\n        slots = get_path_slots(state.link_slot_array, params, nodes_sd, i)\n        # Add padding to slots at end\n        # 0 means slot is free, 1 is occupied\n        slots = jnp.concatenate((slots, jnp.ones(params.max_slots)))\n        launch_power = get_launch_power(state, i, state.launch_power_array[i], params)\n        lightpath_index = get_lightpath_index(params, nodes_sd, i)\n\n        # This function checks through each available modulation format, checks the first and last available slots,\n        # calculates the SNR, checks it meets the requirements, and returns the resulting mask\n        def check_modulation_format(mod_format_index, init_path_mask):\n            se = params.modulations_array.val[mod_format_index][1]\n            req_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)[0]\n            bandwidth_per_subchannel = params.slot_size\n            req_snr = params.modulations_array.val[mod_format_index][2] + params.snr_margin\n            # Get mask used to check if request will fit slots\n            request_mask = get_request_mask(req_slots, params)\n\n            def check_slots_available(j, val):\n                # Multiply through by request mask to check if slots available\n                slot_sum = jnp.sum(request_mask * jax.lax.dynamic_slice(val, (j,), (params.max_slots,)), promote_integers=False) &lt;= 0\n                slot_sum = slot_sum.reshape((1,)).astype(LARGE_FLOAT_DTYPE)\n                return jax.lax.dynamic_update_slice(val, slot_sum, (j,))\n\n            # Mask out slots that are not valid\n            slot_mask = jax.lax.fori_loop(\n                0,\n                int(params.link_resources + 1),  # No need to check last requested_slots-1 slots\n                check_slots_available,\n                slots,\n            )\n            # Cut off padding\n            slot_mask = jax.lax.dynamic_slice(slot_mask, (0,), (params.link_resources,))\n            # Check first and last available slots for suitability\n            ff_path_mask = jnp.concatenate((slot_mask, jnp.ones((1,))), axis=0)\n            lf_path_mask = jnp.concatenate((jnp.ones((1,)), slot_mask), axis=0)\n            first_available_slot_index = jnp.argmax(ff_path_mask)\n            last_available_slot_index = params.link_resources - jnp.argmax(jnp.flip(lf_path_mask)) - 1\n            # Assign \"req_slots\" subchannels (each with bandwidth = slot width) for the first and last possible slots\n            ff_temp_state = state.replace(\n                channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, first_available_slot_index, req_slots, bandwidth_per_subchannel),\n                channel_power_array=vmap_set_path_links(state.channel_power_array, path, first_available_slot_index, req_slots, launch_power),\n                path_index_array=vmap_set_path_links(state.path_index_array, path, first_available_slot_index, req_slots, lightpath_index),\n                modulation_format_index_array=vmap_set_path_links(state.modulation_format_index_array, path, first_available_slot_index, req_slots, mod_format_index),\n            )\n            lf_temp_state = state.replace(\n                channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, last_available_slot_index, req_slots, bandwidth_per_subchannel),\n                channel_power_array=vmap_set_path_links(state.channel_power_array, path, last_available_slot_index, req_slots, launch_power),\n                path_index_array=vmap_set_path_links(state.path_index_array, path, last_available_slot_index, req_slots, lightpath_index),\n                modulation_format_index_array=vmap_set_path_links(state.modulation_format_index_array, path, last_available_slot_index, req_slots, mod_format_index),\n            )\n            ff_temp_state = ff_temp_state.replace(link_snr_array=get_snr_link_array(ff_temp_state, params))\n            lf_temp_state = lf_temp_state.replace(link_snr_array=get_snr_link_array(lf_temp_state, params))\n            # Take the minimum value of SNR from all the subchannels\n            ff_snr_value = get_minimum_snr_of_channels_on_path(\n                ff_temp_state, path, first_available_slot_index, req_slots, params\n            )\n            lf_snr_value = get_minimum_snr_of_channels_on_path(\n                lf_temp_state, path, last_available_slot_index, req_slots, params\n            )\n            # Check that other paths SNR is still sufficient (True if failure)\n            ff_snr_check = 1 - check_action_rmsa_gn_model(ff_temp_state, None, params)\n            lf_snr_check = 1 - check_action_rmsa_gn_model(lf_temp_state, None, params)\n            ff_check = (ff_snr_value &gt;= req_snr) * ff_snr_check\n            lf_check = (lf_snr_value &gt;= req_snr) * lf_snr_check\n\n            slot_indices = jnp.arange(params.link_resources, dtype=MED_INT_DTYPE)\n            mod_format_mask = jnp.where(slot_indices == first_available_slot_index, ff_check, False)\n            mod_format_mask = jnp.where(slot_indices == last_available_slot_index, lf_check, mod_format_mask)\n            path_mask = jnp.where(mod_format_mask, mod_format_index, init_path_mask)\n            # jax.debug.print(\"ff_snr_check {}\", ff_snr_check, ordered=True)\n            # jax.debug.print(\"lf_snr_check {}\", lf_snr_check, ordered=True)\n            # jax.debug.print(\"ff_snr_value {}\", ff_snr_value, ordered=True)\n            # jax.debug.print(\"lf_snr_value {}\", lf_snr_value, ordered=True)\n            # jax.debug.print(\"first_available_slot_index {}\", first_available_slot_index, ordered=True)\n            # jax.debug.print(\"last_available_slot_index {}\", last_available_slot_index, ordered=True)\n            # jax.debug.print(\"req_snr {}\", req_snr, ordered=True)\n            # jax.debug.print(\"mod_format_mask {}\", mod_format_mask, ordered=True)\n            # jax.debug.print(\"path_mask {}\", path_mask, ordered=True)\n            return path_mask\n\n        path_mask = jax.lax.fori_loop(0, params.modulations_array.val.shape[0], check_modulation_format, jnp.full((params.link_resources,), -1., dtype=LARGE_FLOAT_DTYPE))\n\n        # Update total mask with path mask\n        mask = jax.lax.dynamic_update_slice(mask, path_mask, (i * params.link_resources,))\n        return mask\n\n    # Loop over each path\n    mod_format_mask = jax.lax.fori_loop(0, params.k_paths, mask_path, init_mask)\n    link_slot_mask = jnp.where(mod_format_mask &gt;= 0, 1.0, 0.0)\n    if params.aggregate_slots &gt; 1:\n        # Full link slot mask is used in process_path_action to get the correct slot from the aggregated slot action\n        state = state.replace(full_link_slot_mask=link_slot_mask)\n        link_slot_mask, _ = aggregate_slots(link_slot_mask.reshape(params.k_paths, -1), params)\n        link_slot_mask = link_slot_mask.reshape(-1)\n    state = state.replace(\n        link_slot_mask=link_slot_mask,\n        mod_format_mask=mod_format_mask,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.mask_slots_rwalr","title":"<code>mask_slots_rwalr(state, params, request)</code>","text":"<p>For use in RWALightpathReuseEnv. Each lightpath has a maximum capacity defined in path_capacity_array. This is updated when a lightpath is assigned. If remaining path capacity is less than current request, corresponding link-slots are masked out. If link-slot is in use by another lightpath for a different source and destination node (even if not full) it is masked out. Step 1: - Mask out slots that are not valid based on path capacity (check link_capacity_array) Step 2: - Mask out slots that are not valid based on lightpath reuse (check path_index_array)</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_slots_rwalr(state: EnvState, params: EnvParams, request: chex.Array) -&gt; EnvState:\n    \"\"\"For use in RWALightpathReuseEnv.\n    Each lightpath has a maximum capacity defined in path_capacity_array. This is updated when a lightpath is assigned.\n    If remaining path capacity is less than current request, corresponding link-slots are masked out.\n    If link-slot is in use by another lightpath for a different source and destination node (even if not full) it is masked out.\n    Step 1:\n    - Mask out slots that are not valid based on path capacity (check link_capacity_array)\n    Step 2:\n    - Mask out slots that are not valid based on lightpath reuse (check path_index_array)\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_mask = jnp.zeros((params.link_resources * params.k_paths))\n    source, dest = nodes_sd\n    path_start_index = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n    #jax.debug.print(\"path_start_index {}\", path_start_index, ordered=True)\n    #jax.debug.print(\"link_capacity_array {}\", state.link_capacity_array, ordered=True)\n\n    def mask_path(i, mask):\n        # Step 1 - mask capacity\n        capacity_mask = jnp.where(state.link_capacity_array &lt; requested_datarate, 1., 0.)\n        #jax.debug.print(\"capacity_mask {}\", capacity_mask, ordered=True)\n        capacity_slots = get_path_slots(capacity_mask, params, nodes_sd, i)\n        #jax.debug.print(\"capacity_slots {}\", capacity_slots, ordered=True)\n        # Step 2 - mask lightpath reuse\n        lightpath_index = path_start_index + i\n        #jax.debug.print(\"lightpath_index {}\", lightpath_index, ordered=True)\n        lightpath_mask = jnp.where(state.path_index_array == lightpath_index, 0., 1.)  # Allow current lightpath\n        #jax.debug.print(\"lightpath_mask {}\", lightpath_mask, ordered=True)\n        lightpath_mask = jnp.where(state.path_index_array == -1, 0., lightpath_mask)  # Allow empty slots\n        #jax.debug.print(\"lightpath_mask {}\", lightpath_mask, ordered=True)\n        lightpath_slots = get_path_slots(lightpath_mask, params, nodes_sd, i)\n        #jax.debug.print(\"lightpath_slots {}\", lightpath_slots, ordered=True)\n        # Step 3 combine masks\n        path_mask = jnp.max(jnp.stack((capacity_slots, lightpath_slots)), axis=0)\n        # Swap zeros for ones\n        path_mask = jnp.where(path_mask == 0, 1., 0.)\n        #jax.debug.print(\"path_mask {}\", path_mask, ordered=True)\n        mask = jax.lax.dynamic_update_slice(mask, path_mask, (i * params.link_resources,))\n        return mask\n\n    # Loop over each path\n    link_slot_mask = jax.lax.fori_loop(0, params.k_paths, mask_path, init_mask)\n    if params.aggregate_slots &gt; 1:\n        # Full link slot mask is used in process_path_action to get the correct slot from the aggregated slot action\n        state = state.replace(full_link_slot_mask=link_slot_mask)\n        link_slot_mask, _ = aggregate_slots(link_slot_mask.reshape(params.k_paths, -1), params)\n        link_slot_mask = link_slot_mask.reshape(-1)\n    state = state.replace(link_slot_mask=link_slot_mask)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.normalise_traffic_matrix","title":"<code>normalise_traffic_matrix(traffic_matrix)</code>","text":"<p>Normalise traffic matrix to sum to 1</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def normalise_traffic_matrix(traffic_matrix):\n    \"\"\"Normalise traffic matrix to sum to 1\"\"\"\n    traffic_matrix /= jnp.sum(traffic_matrix, promote_integers=False)\n    return traffic_matrix\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.pad_array","title":"<code>pad_array(array, fill_value)</code>","text":"<p>Pad a ragged multidimensional array to rectangular shape. Used for training on multiple topologies. Source: https://codereview.stackexchange.com/questions/222623/pad-a-ragged-multidimensional-array-to-rectangular-shape</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <p>array to pad</p> required <code>fill_value</code> <p>value to fill with</p> required <p>Returns:</p> Name Type Description <code>result</code> <p>padded array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def pad_array(array, fill_value):\n    \"\"\"\n    Pad a ragged multidimensional array to rectangular shape.\n    Used for training on multiple topologies.\n    Source: https://codereview.stackexchange.com/questions/222623/pad-a-ragged-multidimensional-array-to-rectangular-shape\n\n    Args:\n        array: array to pad\n        fill_value: value to fill with\n\n    Returns:\n        result: padded array\n    \"\"\"\n\n    def get_dimensions(array, level=0):\n        yield level, len(array)\n        try:\n            for row in array:\n                yield from get_dimensions(row, level + 1)\n        except TypeError: #not an iterable\n            pass\n\n    def get_max_shape(array):\n        dimensions = defaultdict(int)\n        for level, length in get_dimensions(array):\n            dimensions[level] = max(dimensions[level], length)\n        return [value for _, value in sorted(dimensions.items())]\n\n    def iterate_nested_array(array, index=()):\n        try:\n            for idx, row in enumerate(array):\n                yield from iterate_nested_array(row, (*index, idx))\n        except TypeError: # final level\n            yield (*index, slice(len(array))), array\n\n    dimensions = get_max_shape(array)\n    result = np.full(dimensions, fill_value)\n    for index, value in iterate_nested_array(array):\n        result[index] = value\n    return result\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.path_action_only","title":"<code>path_action_only(topology_pattern, action_counter, remaining_actions)</code>","text":"<p>This is to check if node has already been assigned, therefore just need to assign slots (n=0)</p> <p>Parameters:</p> Name Type Description Default <code>topology_pattern</code> <code>Array</code> <p>Topology pattern</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>remaining_actions</code> <code>Scalar</code> <p>Remaining actions</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if only path action, False if node action</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def path_action_only(topology_pattern: chex.Array, action_counter: chex.Array, remaining_actions: chex.Scalar):\n    \"\"\"This is to check if node has already been assigned, therefore just need to assign slots (n=0)\n\n    Args:\n        topology_pattern: Topology pattern\n        action_counter: Action counter\n        remaining_actions: Remaining actions\n\n    Returns:\n        bool: True if only path action, False if node action\n    \"\"\"\n    # Get topology segment to be assigned e.g. [2,1,4]\n    topology_segment = jax.lax.dynamic_slice(topology_pattern, ((remaining_actions-1)*2, ), (3, ))\n    topology_indices = jnp.arange(topology_pattern.shape[0])\n    # Check if the latest node in the segment is found in \"prev_assigned_topology\"\n    new_node_to_be_assigned = topology_segment[0]\n    prev_assigned_topology = jnp.where(topology_indices &gt; (action_counter[-1]-1)*2, topology_pattern, 0)\n    nodes_already_assigned_check = jnp.any(jnp.sum(jnp.where(prev_assigned_topology == new_node_to_be_assigned, 1, 0)) &gt; 0)\n    return nodes_already_assigned_check\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.poisson","title":"<code>poisson(key, lam, shape=(), dtype=dtypes.float_)</code>","text":"<p>Sample Exponential random values with given shape and float dtype.</p> <p>The values are distributed according to the probability density function:</p> <p>.. math::  f(x) = \\lambda e^{-\\lambda x}</p> <p>on the domain :math:<code>0 \\le x &lt; \\infty</code>.</p> <p>Args: key: a PRNG key used as the random key. lam: a positive float32 or float64 <code>Tensor</code> indicating the rate parameter shape: optional, a tuple of nonnegative integers representing the result   shape. Default (). dtype: optional, a float dtype for the returned values (default float64 if   jax_enable_x64 is true, otherwise float32).</p> <p>Returns: A random array with the specified shape and dtype.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2, 3))\ndef poisson(key: Union[Array, prng.PRNGKeyArray],\n            lam: ArrayLike,\n            shape: Shape = (),\n            dtype: DTypeLike = dtypes.float_) -&gt; Array:\n    r\"\"\"Sample Exponential random values with given shape and float dtype.\n\n    The values are distributed according to the probability density function:\n\n    .. math::\n     f(x) = \\lambda e^{-\\lambda x}\n\n    on the domain :math:`0 \\le x &lt; \\infty`.\n\n    Args:\n    key: a PRNG key used as the random key.\n    lam: a positive float32 or float64 `Tensor` indicating the rate parameter\n    shape: optional, a tuple of nonnegative integers representing the result\n      shape. Default ().\n    dtype: optional, a float dtype for the returned values (default float64 if\n      jax_enable_x64 is true, otherwise float32).\n\n    Returns:\n    A random array with the specified shape and dtype.\n    \"\"\"\n    key, _ = jax._src.random._check_prng_key(key)\n    if not dtypes.issubdtype(dtype, np.floating):\n        raise ValueError(f\"dtype argument to `exponential` must be a float \"\n                       f\"dtype, got {dtype}\")\n    dtype = dtypes.canonicalize_dtype(dtype)\n    shape = core.canonicalize_shape(shape)\n    return _poisson(key, lam, shape, dtype)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.process_path_action","title":"<code>process_path_action(state, params, path_action)</code>","text":"<p>Process path action to get path index and initial slot index.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>current state</p> required <code>params</code> <code>Params</code> <p>environment parameters</p> required <code>path_action</code> <code>int</code> <p>path action</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>(Array, Array)</code> <p>path index</p> <code>int</code> <code>(Array, Array)</code> <p>initial slot index</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef process_path_action(state: EnvState, params: EnvParams, path_action: chex.Array) -&gt; (chex.Array, chex.Array):\n    \"\"\"Process path action to get path index and initial slot index.\n\n    Args:\n        state (State): current state\n        params (Params): environment parameters\n        path_action (int): path action\n\n    Returns:\n        int: path index\n        int: initial slot index\n    \"\"\"\n    num_slot_actions = math.ceil(params.link_resources/params.aggregate_slots)\n    path_index = jnp.floor(path_action / num_slot_actions).astype(LARGE_INT_DTYPE).reshape(1)\n    initial_aggregated_slot_index = jnp.mod(path_action, num_slot_actions).reshape(1)\n    initial_slot_index = initial_aggregated_slot_index*params.aggregate_slots\n    if params.aggregate_slots &gt; 1:\n        # Get the path mask do a dynamic slice and get the index of first unoccupied slot in the slice\n        path_mask = jax.lax.dynamic_slice(state.full_link_slot_mask, path_index*params.link_resources, (params.link_resources,))\n        path_mask_slice = jax.lax.dynamic_slice(path_mask, initial_slot_index, (params.aggregate_slots,))\n        # Use argmax to get index of first 1 in slice of mask\n        initial_slot_index = initial_slot_index + jnp.argmax(path_mask_slice).astype(MED_INT_DTYPE)\n    return path_index[0], initial_slot_index[0]\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.read_rsa_request","title":"<code>read_rsa_request(request_array)</code>","text":"<p>Read RSA request from request array. Return source-destination nodes and bandwidth request.</p> <p>Parameters:</p> Name Type Description Default <code>request_array</code> <code>Array</code> <p>request array</p> required <p>Returns:</p> Type Description <code>Tuple[Array, Array]</code> <p>Tuple[chex.Array, chex.Array]: source-destination nodes and bandwidth request</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def read_rsa_request(request_array: chex.Array) -&gt; Tuple[chex.Array, chex.Array]:\n    \"\"\"Read RSA request from request array. Return source-destination nodes and bandwidth request.\n\n    Args:\n        request_array: request array\n\n    Returns:\n        Tuple[chex.Array, chex.Array]: source-destination nodes and bandwidth request\n    \"\"\"\n    node_s = jax.lax.dynamic_slice(request_array, (0,), (1,))\n    requested_datarate = jax.lax.dynamic_slice(request_array, (1,), (1,))\n    node_d = jax.lax.dynamic_slice(request_array, (2,), (1,))\n    nodes_sd = jnp.concatenate((node_s, node_d))\n    return nodes_sd, requested_datarate\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.remove_expired_node_requests","title":"<code>remove_expired_node_requests(state, params)</code>","text":"<p>Check for values in node_departure_array that are less than the current time but greater than zero (negative time indicates the request is not yet finalised). If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase node_capacity_array by expired resources on each node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_node_requests(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"Check for values in node_departure_array that are less than the current time but greater than zero\n    (negative time indicates the request is not yet finalised).\n    If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase\n    node_capacity_array by expired resources on each node.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    mask = jnp.where(state.node_departure_array &lt; jnp.squeeze(state.current_time), 1, 0)\n    mask = jnp.where(0 &lt; state.node_departure_array, mask, 0)\n    expired_resources = jnp.sum(jnp.where(mask == 1, state.node_resource_array, 0), axis=1, promote_integers=False)\n    state = state.replace(\n        node_capacity_array=state.node_capacity_array + expired_resources,\n        node_resource_array=jnp.where(mask == 1, 0, state.node_resource_array),\n        node_departure_array=jnp.where(mask == 1, jnp.inf, state.node_departure_array)\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.remove_expired_services_rmsa_gn_model","title":"<code>remove_expired_services_rmsa_gn_model(state, params)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rmsa_gn_model(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                      state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                      updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=jnp.where(mask_remove == one, zero, state.link_slot_array),\n        link_slot_departure_array=updated_link_slot_departure_array,\n        link_snr_array=jnp.where(mask_remove == one, zero, state.link_snr_array),\n        path_index_array=jnp.where(mask_remove == one, -one, state.path_index_array),\n        channel_centre_bw_array=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array),\n        channel_power_array=jnp.where(mask_remove == one, zero, state.channel_power_array),\n        modulation_format_index_array=jnp.where(mask_remove == one, -one, state.modulation_format_index_array),\n        path_index_array_prev=jnp.where(mask_remove == one, -one, state.path_index_array_prev),\n        channel_centre_bw_array_prev=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array_prev),\n        channel_power_array_prev=jnp.where(mask_remove == one, zero, state.channel_power_array_prev),\n        modulation_format_index_array_prev=jnp.where(mask_remove == one, -one, state.modulation_format_index_array_prev),\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.remove_expired_services_rsa","title":"<code>remove_expired_services_rsa(state, params)</code>","text":"<p>Check for values in link_slot_departure_array that are less than the current time but greater than zero (negative time indicates the request is not yet finalised). If found, set to zero in link_slot_array and link_slot_departure_array.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rsa(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"Check for values in link_slot_departure_array that are less than the current time but greater than zero\n    (negative time indicates the request is not yet finalised).\n    If found, set to zero in link_slot_array and link_slot_departure_array.\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_array = jnp.where(mask_remove == one, zero, state.link_slot_array)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                     state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                     updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=updated_link_slot_array,\n        link_slot_departure_array=updated_link_slot_departure_array,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.remove_expired_services_rsa_gn_model","title":"<code>remove_expired_services_rsa_gn_model(state, params)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rsa_gn_model(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                      state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                      updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=jnp.where(mask_remove == one, zero, state.link_slot_array),\n        link_slot_departure_array=updated_link_slot_departure_array,\n        link_snr_array=jnp.where(mask_remove == one, zero, state.link_snr_array),\n        path_index_array=jnp.where(mask_remove == one, -one, state.path_index_array),\n        channel_centre_bw_array=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array),\n        channel_power_array=jnp.where(mask_remove == one, zero, state.channel_power_array),\n        path_index_array_prev=jnp.where(mask_remove == one, -one, state.path_index_array_prev),\n        channel_centre_bw_array_prev=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array_prev),\n        channel_power_array_prev=jnp.where(mask_remove == one, zero, state.channel_power_array_prev),\n    )\n    if params.monitor_active_lightpaths:\n        # The active_lightpaths_array is set to -1 when the lightpath is not active\n        # The active_lightpaths_array_departure is set to 0 when the lightpath is not active\n        # (active_lightpaths_array is used to calculate the total throughput)\n        mask_remove = jnp.where(\n            (zero &lt;= state.active_lightpaths_array_departure) &amp; (state.active_lightpaths_array_departure &lt;= jnp.squeeze(current_time)),\n            one, zero)\n        state = state.replace(\n            active_lightpaths_array=jnp.where(mask_remove == one, -one, state.active_lightpaths_array),\n            active_lightpaths_array_departure=jnp.where(mask_remove == one, zero, state.active_lightpaths_array_departure),\n        )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.remove_expired_services_rwalr","title":"<code>remove_expired_services_rwalr(state, params)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rwalr(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                     state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                     updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=jnp.where(mask_remove == one, zero, state.link_slot_array),\n        path_index_array=jnp.where(mask_remove == one, -one, state.path_index_array),\n        link_slot_departure_array=updated_link_slot_departure_array,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.required_slots","title":"<code>required_slots(bitrate, se, channel_width, guardband=1)</code>","text":"<p>Calculate required slots for a given bitrate and spectral efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>bit_rate</code> <code>float</code> <p>Bit rate in Gbps</p> required <code>se</code> <code>float</code> <p>Spectral efficiency in bps/Hz</p> required <code>channel_width</code> <code>float</code> <p>Channel width in GHz</p> required <code>guardband</code> <code>int</code> <p>Guard band. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>int</code> <code>Array</code> <p>Required slots</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2, 3))\ndef required_slots(bitrate: float, se: int, channel_width: float, guardband: int = 1) -&gt; chex.Array:\n    \"\"\"Calculate required slots for a given bitrate and spectral efficiency.\n\n    Args:\n        bit_rate (float): Bit rate in Gbps\n        se (float): Spectral efficiency in bps/Hz\n        channel_width (float): Channel width in GHz\n        guardband (int, optional): Guard band. Defaults to 1.\n\n    Returns:\n        int: Required slots\n    \"\"\"\n    # If bitrate is zero, then required slots should be zero\n    return ((jnp.ceil(bitrate/(se*channel_width))+guardband) * (one - (bitrate == zero))).astype(MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.set_band_gaps","title":"<code>set_band_gaps(link_slot_array, params, val)</code>","text":"<p>Set band gaps in link slot array Args:     link_slot_array (chex.Array): Link slot array     params (RSAGNModelEnvParams): Environment parameters     val (int): Value to set Returns:     chex.Array: Link slot array with band gaps</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2))\ndef set_band_gaps(link_slot_array: chex.Array, params: RSAGNModelEnvParams, val: int) -&gt; chex.Array:\n    \"\"\"Set band gaps in link slot array\n    Args:\n        link_slot_array (chex.Array): Link slot array\n        params (RSAGNModelEnvParams): Environment parameters\n        val (int): Value to set\n    Returns:\n        chex.Array: Link slot array with band gaps\n    \"\"\"\n    # Create array that is size of link_slot array with values of column index\n    mask = jnp.arange(params.link_resources)\n    mask = jnp.tile(mask, (params.num_links, 1))\n    def set_band_gap(i, arr):\n        gap_start = params.gap_starts.val[i]\n        gap_end = gap_start + params.gap_widths.val[i]\n        condition = jnp.logical_and(arr &gt;= gap_start, arr &lt; gap_end)\n        arr = jnp.where(condition, -one, arr)\n        return arr\n    mask = jax.lax.fori_loop(0, params.gap_widths.val.shape[0], set_band_gap, mask)\n    link_slot_array = jnp.where(mask == -one, val, link_slot_array)\n    return link_slot_array\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.undo_action_rmsa_gn_model","title":"<code>undo_action_rmsa_gn_model(state, params)</code>","text":"<p>Undo action for RMSA GN model Args:     state (EnvState): Environment state     action (chex.Array): Action array     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef undo_action_rmsa_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; EnvState:\n    \"\"\"Undo action for RMSA GN model\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action array\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    state = undo_action_rsa(state, params)  # Undo link_slot_array and link_slot_departure_array\n    state = state.replace(\n        link_slot_array=set_band_gaps(state.link_slot_array, params, -one),  # Set C+L band gap\n        channel_centre_bw_array=state.channel_centre_bw_array_prev,\n        path_index_array=state.path_index_array_prev,\n        channel_power_array=state.channel_power_array_prev,\n        modulation_format_index_array=state.modulation_format_index_array_prev,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.undo_action_rsa","title":"<code>undo_action_rsa(state, params)</code>","text":"<p>If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation. Partial resource allocation is indicated by negative time in link slot departure array. Check for values in link_slot_departure_array that are less than zero. If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef undo_action_rsa(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation.\n    Partial resource allocation is indicated by negative time in link slot departure array.\n    Check for values in link_slot_departure_array that are less than zero.\n    If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # If departure array is negative, then undo the action\n    mask = jnp.where(state.link_slot_departure_array &lt; zero, one, zero)\n    # If link slot array is &lt; -1, then undo the action\n    # (departure might be positive because existing service had holding time after current)\n    # e.g. (time_in_array = t1 - t2) where t2 &lt; t1 and t2 = current_time + holding_time\n    # but link_slot_array = -2 due to double allocation, so undo the action\n    mask = jnp.where(state.link_slot_array &lt; -one, one, mask)\n    state = state.replace(\n        link_slot_array=jnp.where(mask == one, state.link_slot_array + one, state.link_slot_array),\n        link_slot_departure_array=jnp.where(\n            mask == one,\n            state.link_slot_departure_array + state.current_time + state.holding_time,\n            state.link_slot_departure_array),\n        total_bitrate=state.total_bitrate + read_rsa_request(state.request_array)[1][0],\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.undo_action_rsa_gn_model","title":"<code>undo_action_rsa_gn_model(state, params)</code>","text":"<p>Undo action for RSA GN model Args:     state (EnvState): Environment state     action (chex.Array): Action array     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef undo_action_rsa_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; EnvState:\n    \"\"\"Undo action for RSA GN model\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action array\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    state = undo_action_rsa(state, params)  # Undo link_slot_array and link_slot_departure_array\n    state = state.replace(\n        link_slot_array=set_band_gaps(state.link_slot_array, params, -one),  # Set C+L band gap\n        channel_centre_bw_array=state.channel_centre_bw_array_prev,\n        path_index_array=state.path_index_array_prev,\n        channel_power_array=state.channel_power_array_prev,\n    )\n    if params.monitor_active_lightpaths:\n        # If departure array is negative, then undo the action\n        mask = jnp.where(state.active_lightpaths_array_departure &lt; zero, one,  zero)\n        state = state.replace(\n            active_lightpaths_array=jnp.where(mask == one, -one, state.active_lightpaths_array),\n            active_lightpaths_array_departure=jnp.where(\n                mask == one,\n                state.active_lightpaths_array_departure + state.current_time + state.holding_time,\n                state.active_lightpaths_array_departure),\n        )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.undo_action_rwalr","title":"<code>undo_action_rwalr(state, params)</code>","text":"<p>If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation. Partial resource allocation is indicated by negative time in link slot departure array. Check for values in link_slot_departure_array that are less than zero. If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef undo_action_rwalr(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation.\n    Partial resource allocation is indicated by negative time in link slot departure array.\n    Check for values in link_slot_departure_array that are less than zero.\n    If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # If departure array is negative, then undo the action\n    mask = jnp.where(state.link_slot_departure_array &lt; zero, one, zero)\n    # If link slot array is &lt; -1, then undo the action\n    # (departure might be positive because existing service had holding time after current)\n    # e.g. (time_in_array = t1 - t2) where t2 &lt; t1 and t2 = current_time + holding_time\n    # but link_slot_array = -2 due to double allocation, so undo the action\n    mask = jnp.where(state.link_slot_array &lt; -one, one, mask)\n    state = state.replace(\n        link_slot_array=jnp.where(mask == one, state.link_slot_array + one, state.link_slot_array),\n        link_slot_departure_array=jnp.where(\n            mask == one,\n            state.link_slot_departure_array + state.current_time + state.holding_time,\n            state.link_slot_departure_array),\n        total_bitrate=state.total_bitrate + read_rsa_request(state.request_array)[1][0]\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.undo_node_action","title":"<code>undo_node_action(state)</code>","text":"<p>If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation. Partial resource allocation is indicated by negative time in node departure array. Check for values in node_departure_array that are less than zero. If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase node_capacity_array by expired resources on each node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef undo_node_action(state: EnvState) -&gt; EnvState:\n    \"\"\"If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation.\n    Partial resource allocation is indicated by negative time in node departure array.\n    Check for values in node_departure_array that are less than zero.\n    If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase\n    node_capacity_array by expired resources on each node.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # TODO - Check that node resource clash doesn't happen (so time is always negative after implementation)\n    #  and undoing always succeeds with negative time\n    mask = jnp.where(state.node_departure_array &lt; 0, 1, 0)\n    resources = jnp.sum(jnp.where(mask == 1, state.node_resource_array, 0), axis=1, promote_integers=False)\n    state = state.replace(\n        node_capacity_array=state.node_capacity_array + resources,\n        node_resource_array=jnp.where(mask == 1, 0, state.node_resource_array),\n        node_departure_array=jnp.where(mask == 1, jnp.inf, state.node_departure_array),\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.update_action_history","title":"<code>update_action_history(action_history, action_counter, action)</code>","text":"<p>Update action history by adding action to first available index starting from the end.</p> <p>Parameters:</p> Name Type Description Default <code>action_history</code> <code>Array</code> <p>Action history</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>action</code> <code>Array</code> <p>Action to add to history</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated action_history</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_action_history(action_history: chex.Array, action_counter: chex.Array, action: chex.Array) -&gt; chex.Array:\n    \"\"\"Update action history by adding action to first available index starting from the end.\n\n    Args:\n        action_history: Action history\n        action_counter: Action counter\n        action: Action to add to history\n\n    Returns:\n        Updated action_history\n    \"\"\"\n    return jax.lax.dynamic_update_slice(action_history, jnp.flip(action, axis=0).astype(MED_INT_DTYPE), ((action_counter[-1]-1)*2,))\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.update_active_lightpaths_array","title":"<code>update_active_lightpaths_array(state, path_index, initial_slot_index, num_slots)</code>","text":"<p>Update active lightpaths array with new path index. Find the first index of the array with value -1 and replace with path index. Args:     state (RSAGNModelEnvState): Environment state     path_index (int): Path index to add to active lightpaths array Returns:     jnp.array: Updated active lightpaths array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_active_lightpaths_array(state: RSAGNModelEnvState, path_index: int, initial_slot_index: int, num_slots: int) -&gt; chex.Array:\n    \"\"\"Update active lightpaths array with new path index.\n    Find the first index of the array with value -1 and replace with path index.\n    Args:\n        state (RSAGNModelEnvState): Environment state\n        path_index (int): Path index to add to active lightpaths array\n    Returns:\n        jnp.array: Updated active lightpaths array\n    \"\"\"\n    first_empty_index = jnp.argmin(state.active_lightpaths_array[:, 0])  # Just look at the first column\n    return jax.lax.dynamic_update_slice(state.active_lightpaths_array, jnp.array([[path_index, initial_slot_index, num_slots[0]]]), (first_empty_index, 0))\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.update_active_lightpaths_array_departure","title":"<code>update_active_lightpaths_array_departure(state, time)</code>","text":"<p>Update active lightpaths array with new path index. Find the first index of the array with value -1 and replace with path index. Args:     state (RSAGNModelEnvState): Environment state     time (float): Departure time Returns:     jnp.array: Updated active lightpaths array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_active_lightpaths_array_departure(state: RSAGNModelEnvState, time: float) -&gt; chex.Array:\n    \"\"\"Update active lightpaths array with new path index.\n    Find the first index of the array with value -1 and replace with path index.\n    Args:\n        state (RSAGNModelEnvState): Environment state\n        time (float): Departure time\n    Returns:\n        jnp.array: Updated active lightpaths array\n    \"\"\"\n    first_empty_index = jnp.argmin(state.active_lightpaths_array[:, 0])  # Just look at the first column\n    return jax.lax.dynamic_update_slice(state.active_lightpaths_array_departure, jnp.stack((time, time, time)), (first_empty_index, 0))\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.update_graph_tuple","title":"<code>update_graph_tuple(state, params)</code>","text":"<p>Update graph tuple for use with Jraph GNNs. Edge and node features are updated from link_slot_array and node_capacity_array respectively. Global features are updated as request_array. Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters Returns:     state (EnvState): Environment state with updated graph tuple</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_graph_tuple(state: EnvState, params: EnvParams):\n    \"\"\"Update graph tuple for use with Jraph GNNs.\n    Edge and node features are updated from link_slot_array and node_capacity_array respectively.\n    Global features are updated as request_array.\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n    Returns:\n        state (EnvState): Environment state with updated graph tuple\n    \"\"\"\n    # Get source and dest from request array\n    source_dest, datarate = read_rsa_request(state.request_array)\n    source, dest = source_dest[0], source_dest[2]\n    # Global feature is normalised data rate of current request\n    globals = jnp.array([datarate / jnp.max(params.values_bw.val)], dtype=LARGE_FLOAT_DTYPE)\n    # One-hot encode source and destination\n    source_dest_features = jnp.zeros((params.num_nodes, 2), dtype=LARGE_FLOAT_DTYPE)\n    source_dest_features = source_dest_features.at[source.astype(MED_INT_DTYPE), 0].set(1)\n    source_dest_features = source_dest_features.at[dest.astype(MED_INT_DTYPE), 1].set(-1)\n    spectral_features = state.graph.nodes[..., :3]\n    holding_time_edge_features = state.link_slot_departure_array / params.mean_service_holding_time\n\n    if params.__class__.__name__ in [\"RSAGNModelEnvParams\", \"RMSAGNModelEnvParams\"]:\n        # Normalize by max parameters (converted to linear units)\n        max_power = isrs_gn_model.from_dbm(params.max_power)\n        normalized_power = jnp.round(state.channel_power_array / max_power, 3)\n        max_snr = isrs_gn_model.from_db(params.max_snr)\n        normalized_snr = jnp.round(state.link_snr_array / max_snr, 3)\n        edge_features = jnp.stack([normalized_snr, normalized_power], axis=-1)\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n    elif params.__class__.__name__ == \"VONEEnvParams\":\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        node_features = getattr(state, \"node_capacity_array\", jnp.zeros(params.num_nodes))\n        node_features = node_features.reshape(-1, 1)\n        node_features = jnp.concatenate([node_features, spectral_features, source_dest_features], axis=-1)\n    else:\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n\n    if params.disable_node_features:\n        node_features = jnp.zeros((1,), dtype=LARGE_FLOAT_DTYPE)\n\n    edge_features = edge_features if params.directed_graph else jnp.repeat(edge_features, 2, axis=0)\n    graph = state.graph._replace(nodes=node_features, edges=edge_features, globals=globals)\n    state = state.replace(graph=graph)\n    return state\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.update_node_array","title":"<code>update_node_array(node_indices, array, node, request)</code>","text":"<p>Used to udated selected_nodes array with new requested resources on each node, for use in</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_node_array(node_indices, array, node, request):\n    \"\"\"Used to udated selected_nodes array with new requested resources on each node, for use in \"\"\"\n    return jnp.where(node_indices == node, array-request, array)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.vmap_set_path_links","title":"<code>vmap_set_path_links(link_slot_array, path, initial_slot, num_slots, value)</code>","text":"<p>Set relevant slots along links in path to val.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>path</code> <code>Array</code> <p>Path (row from path-link array that indicates links used by path)</p> required <code>initial_slot</code> <code>int</code> <p>Initial slot</p> required <code>num_slots</code> <code>int</code> <p>Number of slots</p> required <code>value</code> <code>int</code> <p>Value to set on link slot array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated link slot array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_set_path_links(link_slot_array: chex.Array, path: chex.Array, initial_slot: int, num_slots: int, value: int) -&gt; chex.Array:\n    \"\"\"Set relevant slots along links in path to val.\n\n    Args:\n        link_slot_array: Link slot array\n        path: Path (row from path-link array that indicates links used by path)\n        initial_slot: Initial slot\n        num_slots: Number of slots\n        value: Value to set on link slot array\n\n    Returns:\n        Updated link slot array\n    \"\"\"\n    return jax.vmap(set_path, in_axes=(0, 0, None, None, None))(link_slot_array, path, initial_slot, num_slots, value)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.vmap_update_node_departure","title":"<code>vmap_update_node_departure(node_departure_array, selected_nodes, value)</code>","text":"<p>Called when implementing node action. Sets request departure time (\"value\") in place of first \"inf\" i.e. unoccupied index on node departure array for selected nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>(N x R) Node departure array</p> required <code>selected_nodes</code> <code>Array</code> <p>(N x 1) Selected nodes (non-zero value on selected node indices)</p> required <code>value</code> <code>int</code> <p>Value to set on node departure array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated node departure array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_update_node_departure(node_departure_array: chex.Array, selected_nodes: chex.Array, value: int) -&gt; chex.Array:\n    \"\"\"Called when implementing node action.\n    Sets request departure time (\"value\") in place of first \"inf\" i.e. unoccupied index on node departure array for selected nodes.\n\n    Args:\n        node_departure_array: (N x R) Node departure array\n        selected_nodes: (N x 1) Selected nodes (non-zero value on selected node indices)\n        value: Value to set on node departure array\n\n    Returns:\n        Updated node departure array\n    \"\"\"\n    first_inf_indices = jnp.argmax(node_departure_array, axis=1).astype(MED_INT_DTYPE)\n    return jax.vmap(update_selected_node_departure, in_axes=(0, 0, 0, None))(node_departure_array, selected_nodes, first_inf_indices, value)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.vmap_update_node_resources","title":"<code>vmap_update_node_resources(node_resource_array, selected_nodes)</code>","text":"<p>Called when implementing node action. Sets requested node resources on selected nodes in place of first \"zero\" i.e. unoccupied index on node resource array for selected nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_resource_array</code> <p>(N x R) Node resource array</p> required <code>selected_nodes</code> <p>(N x 1) Requested resources on selected nodes</p> required <p>Returns:</p> Type Description <p>Updated node resource array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_update_node_resources(node_resource_array, selected_nodes):\n    \"\"\"Called when implementing node action.\n    Sets requested node resources on selected nodes in place of first \"zero\" i.e.\n    unoccupied index on node resource array for selected nodes.\n\n    Args:\n        node_resource_array: (N x R) Node resource array\n        selected_nodes: (N x 1) Requested resources on selected nodes\n\n    Returns:\n        Updated node resource array\n    \"\"\"\n    first_zero_indices = jnp.argmin(node_resource_array, axis=1)\n    return jax.vmap(update_selected_node_resources, in_axes=(0, 0, 0))(node_resource_array, selected_nodes, first_zero_indices)\n</code></pre>"},{"location":"reference/#xlron.environments.env_funcs.vmap_update_path_links","title":"<code>vmap_update_path_links(link_slot_array, path, initial_slot, num_slots, value)</code>","text":"<p>Update relevant slots along links in path to current_val - val.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>path</code> <code>Array</code> <p>Path (row from path-link array that indicates links used by path)</p> required <code>initial_slot</code> <code>int</code> <p>Initial slot</p> required <code>num_slots</code> <code>int</code> <p>Number of slots</p> required <code>value</code> <code>int</code> <p>Value to subtract from link slot array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated link slot array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_update_path_links(link_slot_array: chex.Array, path: chex.Array, initial_slot: int, num_slots: int, value: int) -&gt; chex.Array:\n    \"\"\"Update relevant slots along links in path to current_val - val.\n\n    Args:\n        link_slot_array: Link slot array\n        path: Path (row from path-link array that indicates links used by path)\n        initial_slot: Initial slot\n        num_slots: Number of slots\n        value: Value to subtract from link slot array\n\n    Returns:\n        Updated link slot array\n    \"\"\"\n    return jax.vmap(update_path, in_axes=(0, 0, None, None, None))(link_slot_array, path, initial_slot, num_slots, value)\n</code></pre>"},{"location":"reference/#models","title":"Models","text":""},{"location":"reference/#xlron.models.models.ActorCriticGNN","title":"<code>ActorCriticGNN</code>","text":"<p>               Bases: <code>Module</code></p> <p>Combine the GNN actor and critic networks into a single class</p> Source code in <code>xlron/models/models.py</code> <pre><code>class ActorCriticGNN(nn.Module):\n    \"\"\"Combine the GNN actor and critic networks into a single class\"\"\"\n    activation: str = \"tanh\"\n    num_layers: int = 2\n    num_units: int = 64\n    message_passing_steps: int = 1\n    mlp_layers: int = None\n    mlp_latent: int = None\n    edge_embedding_size: int = 128\n    edge_mlp_layers: int = 3\n    edge_mlp_latent: int = 128\n    edge_output_size_actor: int = 1\n    edge_output_size_critic: int = 1\n    global_embedding_size: int = 8\n    global_mlp_layers: int = 0\n    global_mlp_latent: int = 0\n    global_output_size_actor: int = 0\n    global_output_size_critic: int = 0\n    node_embedding_size: int = 16\n    node_mlp_layers: int = 2\n    node_mlp_latent: int = 128\n    node_output_size_actor: int = 0\n    node_output_size_critic: int = 0\n    attn_mlp_layers: int = 2\n    attn_mlp_latent: int = 128\n    gnn_mlp_layers: int = 1\n    use_attention: bool = True\n    normalise_by_link_length: bool = True  # Normalise the processed edge features by the link length\n    gnn_layer_norm: bool = True\n    mlp_layer_norm: bool = False\n    vmap: bool = True\n    temperature: float = 1.0\n    # Launch power specific parameters\n    min_power_dbm: float = 0.0\n    max_power_dbm: float = 2.0\n    step_power_dbm: float = 0.1\n    discrete: bool = True\n    # Beta distribution parameters (used only if discrete=False)\n    min_concentration: float = 0.1\n    max_concentration: float = 20.0\n    epsilon: float = 1e-6\n    # Bools to determine which actions to output\n    output_path: bool = True\n    output_power: bool = True\n    assert edge_output_size_actor &gt; 0\n    assert edge_output_size_critic + global_output_size_critic &gt; 0\n\n    @property\n    def num_power_levels(self):\n        \"\"\"Calculate number of power levels dynamically\"\"\"\n        return int((self.max_power_dbm - self.min_power_dbm) / self.step_power_dbm) + 1\n\n    @property\n    def power_levels(self):\n        \"\"\"Calculate power levels dynamically\"\"\"\n        return jnp.linspace(self.min_power_dbm, self.max_power_dbm, self.num_power_levels, dtype=LARGE_FLOAT_DTYPE)\n\n    @nn.compact\n    def __call__(self, state: EnvState, params: EnvParams):\n        actor = ActorGNN(\n            num_layers=self.num_layers,\n            num_units=self.num_units,\n            message_passing_steps=self.message_passing_steps,\n            mlp_layers=self.mlp_layers,\n            mlp_latent=self.mlp_latent,\n            edge_embedding_size=self.edge_embedding_size,\n            edge_mlp_layers=self.edge_mlp_layers,\n            edge_mlp_latent=self.edge_mlp_latent,\n            edge_output_size=self.edge_output_size_actor,\n            global_embedding_size=self.global_embedding_size,\n            global_mlp_layers=self.global_mlp_layers,\n            global_mlp_latent=self.global_mlp_latent,\n            global_output_size=self.global_output_size_actor,\n            node_embedding_size=self.node_embedding_size,\n            node_mlp_layers=self.node_mlp_layers,\n            node_mlp_latent=self.node_mlp_latent,\n            node_output_size=self.node_output_size_actor,\n            attn_mlp_layers=self.attn_mlp_layers,\n            attn_mlp_latent=self.attn_mlp_latent,\n            use_attention=self.use_attention,\n            normalise_by_link_length=self.normalise_by_link_length,\n            gnn_layer_norm=self.gnn_layer_norm,\n            mlp_layer_norm=self.mlp_layer_norm,\n            temperature=self.temperature,\n            min_power_dbm=self.min_power_dbm,\n            max_power_dbm=self.max_power_dbm,\n            step_power_dbm=self.step_power_dbm,\n            discrete=self.discrete,\n            min_concentration=self.min_concentration,\n            max_concentration=self.max_concentration,\n            epsilon=self.epsilon,\n        )\n        critic = CriticGNN(\n            activation=self.activation,\n            num_layers=self.num_layers,\n            num_units=self.num_units,\n            message_passing_steps=self.message_passing_steps,\n            mlp_layers=self.mlp_layers,\n            mlp_latent=self.mlp_latent,\n            edge_embedding_size=self.edge_embedding_size,\n            edge_mlp_layers=self.edge_mlp_layers,\n            edge_mlp_latent=self.edge_mlp_latent,\n            edge_output_size=self.edge_output_size_critic,\n            global_embedding_size=self.global_embedding_size,\n            global_mlp_layers=self.global_mlp_layers,\n            global_mlp_latent=self.global_mlp_latent,\n            global_output_size=self.global_output_size_critic,\n            node_embedding_size=self.node_embedding_size,\n            node_mlp_layers=self.node_mlp_layers,\n            node_mlp_latent=self.node_mlp_latent,\n            node_output_size=self.node_output_size_critic,\n            attn_mlp_layers=self.attn_mlp_layers,\n            attn_mlp_latent=self.attn_mlp_latent,\n            use_attention=self.use_attention,\n            normalise_by_link_length=self.normalise_by_link_length,\n            gnn_layer_norm=self.gnn_layer_norm,\n            mlp_layer_norm=self.mlp_layer_norm,\n        )\n\n        if self.vmap:\n            actor = jax.vmap(actor, in_axes=(0, None))\n            critic = jax.vmap(critic, in_axes=(0, None))\n        actor_out = actor(state, params)\n        critic_out = critic(state, params)\n        return actor_out, critic_out\n\n    def sample_action_path(self, seed, dist, log_prob=False, deterministic=False):\n        \"\"\"Sample an action from the distribution.\"\"\"\n        action = jnp.argmax(dist.probs()).astype(MED_INT_DTYPE) if deterministic else dist.sample(seed=seed)\n        if log_prob:\n            return action, dist.log_prob(action)\n        return action\n\n    def sample_action_power(self, seed, dist, log_prob=False, deterministic=False):\n        \"\"\"Sample an action and convert to power level\"\"\"\n        if self.discrete:\n            if deterministic:\n                # Take most probable action\n                raw_action = dist.mode()\n            else:\n                # Sample from distribution\n                raw_action = dist.sample(seed=seed)\n            processed_action = self.power_levels[raw_action]\n        else:\n            if deterministic:\n                # Use mean of Beta distribution for deterministic action\n                mean = dist.alpha / (dist.alpha + dist.beta)\n                raw_action = jnp.clip(mean, self.epsilon, 1.0 - self.epsilon)\n            else:\n                # Sample from Beta (clipping to avoid edge values with undefined gradient) and scale to power range\n                raw_action = jnp.clip(dist.sample(seed=seed), self.epsilon, 1.0 - self.epsilon)\n            processed_action = self.min_power_dbm + raw_action * (self.max_power_dbm - self.min_power_dbm)\n        processed_action = from_dbm(processed_action)\n        if log_prob:\n            return processed_action, dist.log_prob(raw_action)\n        return processed_action\n\n    def sample_action_path_power(self, seed, dist, log_prob=False, deterministic=False):\n        \"\"\"Sample an action from the distributions.\n        This assumes dist is a tuple of path and power distributions.\"\"\"\n        path_action = self.sample_action_path(seed, dist[0], log_prob=log_prob, deterministic=deterministic)\n        power_action  = self.sample_action_power(seed, dist[1], log_prob=log_prob, deterministic=deterministic)\n        if log_prob:\n            return path_action[0], power_action[0], path_action[1]+power_action[1]\n        return path_action, power_action\n\n    def sample_action(self, seed, dist, log_prob=False, deterministic=False):\n        \"\"\"Sample an action from the distributions.\n        This assumes dist is a tuple of path and power distributions OR just the appropriate distribution.\"\"\"\n        if self.output_path and self.output_power:\n            return self.sample_action_path_power(seed, dist, log_prob=log_prob, deterministic=deterministic)\n        elif self.output_path:\n            return self.sample_action_path(seed, dist, log_prob=log_prob, deterministic=deterministic)\n        elif self.output_power:\n            return self.sample_action_power(seed, dist, log_prob=log_prob, deterministic=deterministic)\n        else:\n            raise ValueError(\"No action type specified for sampling.\")\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorCriticGNN.num_power_levels","title":"<code>num_power_levels</code>  <code>property</code>","text":"<p>Calculate number of power levels dynamically</p>"},{"location":"reference/#xlron.models.models.ActorCriticGNN.power_levels","title":"<code>power_levels</code>  <code>property</code>","text":"<p>Calculate power levels dynamically</p>"},{"location":"reference/#xlron.models.models.ActorCriticGNN.sample_action","title":"<code>sample_action(seed, dist, log_prob=False, deterministic=False)</code>","text":"<p>Sample an action from the distributions. This assumes dist is a tuple of path and power distributions OR just the appropriate distribution.</p> Source code in <code>xlron/models/models.py</code> <pre><code>def sample_action(self, seed, dist, log_prob=False, deterministic=False):\n    \"\"\"Sample an action from the distributions.\n    This assumes dist is a tuple of path and power distributions OR just the appropriate distribution.\"\"\"\n    if self.output_path and self.output_power:\n        return self.sample_action_path_power(seed, dist, log_prob=log_prob, deterministic=deterministic)\n    elif self.output_path:\n        return self.sample_action_path(seed, dist, log_prob=log_prob, deterministic=deterministic)\n    elif self.output_power:\n        return self.sample_action_power(seed, dist, log_prob=log_prob, deterministic=deterministic)\n    else:\n        raise ValueError(\"No action type specified for sampling.\")\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorCriticGNN.sample_action_path","title":"<code>sample_action_path(seed, dist, log_prob=False, deterministic=False)</code>","text":"<p>Sample an action from the distribution.</p> Source code in <code>xlron/models/models.py</code> <pre><code>def sample_action_path(self, seed, dist, log_prob=False, deterministic=False):\n    \"\"\"Sample an action from the distribution.\"\"\"\n    action = jnp.argmax(dist.probs()).astype(MED_INT_DTYPE) if deterministic else dist.sample(seed=seed)\n    if log_prob:\n        return action, dist.log_prob(action)\n    return action\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorCriticGNN.sample_action_path_power","title":"<code>sample_action_path_power(seed, dist, log_prob=False, deterministic=False)</code>","text":"<p>Sample an action from the distributions. This assumes dist is a tuple of path and power distributions.</p> Source code in <code>xlron/models/models.py</code> <pre><code>def sample_action_path_power(self, seed, dist, log_prob=False, deterministic=False):\n    \"\"\"Sample an action from the distributions.\n    This assumes dist is a tuple of path and power distributions.\"\"\"\n    path_action = self.sample_action_path(seed, dist[0], log_prob=log_prob, deterministic=deterministic)\n    power_action  = self.sample_action_power(seed, dist[1], log_prob=log_prob, deterministic=deterministic)\n    if log_prob:\n        return path_action[0], power_action[0], path_action[1]+power_action[1]\n    return path_action, power_action\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorCriticGNN.sample_action_power","title":"<code>sample_action_power(seed, dist, log_prob=False, deterministic=False)</code>","text":"<p>Sample an action and convert to power level</p> Source code in <code>xlron/models/models.py</code> <pre><code>def sample_action_power(self, seed, dist, log_prob=False, deterministic=False):\n    \"\"\"Sample an action and convert to power level\"\"\"\n    if self.discrete:\n        if deterministic:\n            # Take most probable action\n            raw_action = dist.mode()\n        else:\n            # Sample from distribution\n            raw_action = dist.sample(seed=seed)\n        processed_action = self.power_levels[raw_action]\n    else:\n        if deterministic:\n            # Use mean of Beta distribution for deterministic action\n            mean = dist.alpha / (dist.alpha + dist.beta)\n            raw_action = jnp.clip(mean, self.epsilon, 1.0 - self.epsilon)\n        else:\n            # Sample from Beta (clipping to avoid edge values with undefined gradient) and scale to power range\n            raw_action = jnp.clip(dist.sample(seed=seed), self.epsilon, 1.0 - self.epsilon)\n        processed_action = self.min_power_dbm + raw_action * (self.max_power_dbm - self.min_power_dbm)\n    processed_action = from_dbm(processed_action)\n    if log_prob:\n        return processed_action, dist.log_prob(raw_action)\n    return processed_action\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorCriticMLP","title":"<code>ActorCriticMLP</code>","text":"<p>               Bases: <code>Module</code></p> Source code in <code>xlron/models/models.py</code> <pre><code>class ActorCriticMLP(nn.Module):\n    action_dim: Sequence[int]\n    activation: str = \"tanh\"\n    num_layers: int = 2\n    num_units: int = 64\n    layer_norm: bool = False\n    temperature: float = 1.0\n\n    @nn.compact\n    def __call__(self, x):\n        actor_mean = make_dense_layers(x, self.num_units, self.num_layers, self.activation)\n        stacked_logits = []\n        actor_mean_dim = nn.Dense(\n            self.action_dim,\n            kernel_init=orthogonal(0.01),\n            bias_init=constant(0.0),\n            dtype=COMPUTE_DTYPE,\n            param_dtype=PARAMS_DTYPE,\n        )(actor_mean)\n        logits = actor_mean_dim / self.temperature\n        stacked_logits.append(logits)\n\n        # If there are multiple action dimensions, concatenate the logits\n        action_dist = distrax.Categorical(logits=logits)\n\n        critic = make_dense_layers(x, self.num_units, self.num_layers, self.activation, layer_norm=self.layer_norm)\n        critic = nn.Dense(\n            1,\n            kernel_init=orthogonal(1.0),\n            bias_init=constant(0.0),\n            dtype=COMPUTE_DTYPE,\n            param_dtype=PARAMS_DTYPE,\n        )(\n            critic\n        )\n\n        return action_dist, jnp.squeeze(critic, axis=-1)\n\n    def sample_action(self, seed,  dist, log_prob=False, deterministic=False):\n        \"\"\"Sample an action from the distribution\"\"\"\n        action = jnp.argmax(dist.probs()) if deterministic else dist.sample(seed=seed)\n        if log_prob:\n            return action, dist.log_prob(action)\n        return action\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorCriticMLP.sample_action","title":"<code>sample_action(seed, dist, log_prob=False, deterministic=False)</code>","text":"<p>Sample an action from the distribution</p> Source code in <code>xlron/models/models.py</code> <pre><code>def sample_action(self, seed,  dist, log_prob=False, deterministic=False):\n    \"\"\"Sample an action from the distribution\"\"\"\n    action = jnp.argmax(dist.probs()) if deterministic else dist.sample(seed=seed)\n    if log_prob:\n        return action, dist.log_prob(action)\n    return action\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorGNN","title":"<code>ActorGNN</code>","text":"<p>               Bases: <code>Module</code></p> <p>Actor network for PPO algorithm. Takes the current state and returns a distrax.Categorical distribution over actions.</p> Source code in <code>xlron/models/models.py</code> <pre><code>class ActorGNN(nn.Module):\n    \"\"\"\n    Actor network for PPO algorithm. Takes the current state and returns a distrax.Categorical distribution\n    over actions.\n    \"\"\"\n    activation: str = \"tanh\"\n    num_layers: int = 2\n    num_units: int = 64\n    mlp_layers: int = None\n    mlp_latent: int = None\n    edge_embedding_size: int = 128\n    edge_mlp_layers: int = 3\n    edge_mlp_latent: int = 128\n    edge_output_size: int = 0\n    global_embedding_size: int = 8\n    global_mlp_layers: int = 0\n    global_mlp_latent: int = 0\n    global_output_size: int = 0\n    node_embedding_size: int = 16\n    node_mlp_layers: int = 2\n    node_mlp_latent: int = 128\n    node_output_size: int = 0\n    attn_mlp_layers: int = 2\n    attn_mlp_latent: int = 128\n    dropout_rate: float = 0\n    deterministic: bool = False\n    message_passing_steps: int = 1\n    use_attention: bool = True\n    normalise_by_link_length: bool = True  # Normalise the processed edge features by the link length\n    gnn_layer_norm: bool = True\n    mlp_layer_norm: bool = False\n    temperature: float = 1.0\n    # Launch power specific parameters\n    min_power_dbm: float = 0.0\n    max_power_dbm: float = 2.0\n    step_power_dbm: float = 0.1\n    discrete: bool = True\n    # Beta distribution parameters (used only if discrete=False)\n    min_concentration: float = 0.1\n    max_concentration: float = 20.0\n    epsilon: float = 1e-6\n\n    @property\n    def num_power_levels(self):\n        \"\"\"Calculate number of power levels dynamically\"\"\"\n        return int((self.max_power_dbm - self.min_power_dbm) / self.step_power_dbm) + 1\n\n    @property\n    def power_levels(self):\n        \"\"\"Calculate power levels dynamically\"\"\"\n        return jnp.linspace(self.min_power_dbm, self.max_power_dbm, self.num_power_levels, dtype=SMALL_FLOAT_DTYPE)\n\n    @nn.compact\n    def __call__(self, state: EnvState, params: EnvParams):\n        \"\"\"\n        The ActorGNN network takes the current network state in the form of a GraphTuple and returns\n        a distrax.Categorical distribution over actions.\n        The graph is processed by a GraphNet module, and the resulting graph is indexed to construct a matrix of\n        the edge features. The edge features are then normalised by the link length from the environment parameters,\n        and the current request is read from the request array.\n        The request is used to retrieve the edge features from the edge_features array for the corresponding\n        shortest k-paths. The edge features are aggregated for each path according to the \"agg_func\" e.g. sum,\n        and the action distribution array is updated.\n        Returns a distrax.Categorical distribution, from which actions can be sampled.\n\n        :param state: EnvState\n        :param params: EnvParams\n\n        :return: distrax.Categorical distribution over actions\n        \"\"\"\n        processed_graph = GraphNet(\n            message_passing_steps=self.message_passing_steps,\n            mlp_layers=self.mlp_layers,\n            mlp_latent=self.mlp_latent,\n            edge_embedding_size=self.edge_embedding_size,\n            edge_mlp_layers=self.edge_mlp_layers,\n            edge_mlp_latent=self.edge_mlp_latent,\n            edge_output_size=self.edge_output_size,\n            global_embedding_size=self.global_embedding_size,\n            global_mlp_layers=self.global_mlp_layers,\n            global_mlp_latent=self.global_mlp_latent,\n            global_output_size=self.global_output_size,\n            node_embedding_size=self.node_embedding_size,\n            node_mlp_layers=self.node_mlp_layers,\n            node_mlp_latent=self.node_mlp_latent,\n            node_output_size=self.node_output_size,\n            attn_mlp_layers=self.attn_mlp_layers,\n            attn_mlp_latent=self.attn_mlp_latent,\n            use_attention=self.use_attention,\n            gnn_layer_norm=self.gnn_layer_norm,\n            mlp_layer_norm=self.mlp_layer_norm,\n        )(state.graph)\n\n        # Index edge features to resemble the link-slot array\n        edge_features = processed_graph.edges if params.directed_graph else processed_graph.edges[:len(processed_graph.edges) // 2]\n        # Normalise features by normalised link length from state.link_length_array\n        if self.normalise_by_link_length:\n            edge_features = edge_features * (params.link_length_array.val/jnp.sum(params.link_length_array.val, promote_integers=False))\n        # Get the current request and initialise array of action distributions per path\n        nodes_sd, requested_bw = read_rsa_request(state.request_array)\n        init_action_array = jnp.zeros(params.k_paths * self.edge_output_size, dtype=SMALL_INT_DTYPE)\n\n        # Define a body func to retrieve path slots and update action array\n        def get_path_action_dist(i, action_array):\n            # Get the processed graph edge features corresponding to the i-th path\n            path_features = get_path_slots(edge_features, params, nodes_sd, i, agg_func=\"sum\")\n            # Update the action array with the path features\n            action_array = jax.lax.dynamic_update_slice(action_array, path_features, (i * self.edge_output_size,))\n            return action_array\n\n        path_action_logits = jax.lax.fori_loop(0, params.k_paths, get_path_action_dist, init_action_array)\n        path_action_logits = jnp.reshape(path_action_logits, (-1,)) / self.temperature\n\n        power_action_dist = None\n        mlp_features = [self.num_units] * self.num_layers\n        output_size = self.num_power_levels if self.discrete else 2\n        path_mlp = MLP(\n            mlp_features + [output_size],\n            dropout_rate=self.dropout_rate,\n            deterministic=self.deterministic,\n            layer_norm=self.mlp_layer_norm,\n        )\n        if params.__class__.__name__ == \"RSAGNModelEnvParams\":\n            if self.global_output_size &gt; 0:\n                power_logits = processed_graph.globals.reshape((-1,)) / self.temperature\n            else:\n                init_feature_array = jnp.zeros((params.k_paths, edge_features.shape[1]), dtype=LARGE_FLOAT_DTYPE)\n                # Define a body func to retrieve path slots and update action array\n                def get_power_action_dist(i, feature_array):\n                    # Get the processed graph edge features corresponding to the i-th path\n                    path_features = get_path_slots(edge_features, params, nodes_sd, i, agg_func=\"sum\").reshape((1, -1))\n                    # Update the array with the path features\n                    action_array = jax.lax.dynamic_update_slice(feature_array, path_features,(i, 0))\n                    return action_array\n                path_feature_batch = jax.lax.fori_loop(0, params.k_paths, get_power_action_dist, init_feature_array)\n                power_logits = path_mlp(path_feature_batch)\n            if self.discrete:\n                power_action_dist = distrax.Categorical(logits=power_logits)\n            else:\n                alpha = self.min_concentration + jax.nn.softplus(power_logits) * (\n                        self.max_concentration - self.min_concentration\n                )\n                beta = self.min_concentration + jax.nn.softplus(power_logits) * (\n                        self.max_concentration - self.min_concentration\n                )\n                power_action_dist = distrax.Beta(alpha, beta)\n\n        # Return a distrax.Categorical distribution over actions (which can be masked later)\n        path_action_dist = distrax.Categorical(logits=path_action_logits)\n        return (path_action_dist, power_action_dist)\n</code></pre>"},{"location":"reference/#xlron.models.models.ActorGNN.num_power_levels","title":"<code>num_power_levels</code>  <code>property</code>","text":"<p>Calculate number of power levels dynamically</p>"},{"location":"reference/#xlron.models.models.ActorGNN.power_levels","title":"<code>power_levels</code>  <code>property</code>","text":"<p>Calculate power levels dynamically</p>"},{"location":"reference/#xlron.models.models.ActorGNN.__call__","title":"<code>__call__(state, params)</code>","text":"<p>The ActorGNN network takes the current network state in the form of a GraphTuple and returns a distrax.Categorical distribution over actions. The graph is processed by a GraphNet module, and the resulting graph is indexed to construct a matrix of the edge features. The edge features are then normalised by the link length from the environment parameters, and the current request is read from the request array. The request is used to retrieve the edge features from the edge_features array for the corresponding shortest k-paths. The edge features are aggregated for each path according to the \"agg_func\" e.g. sum, and the action distribution array is updated. Returns a distrax.Categorical distribution, from which actions can be sampled.</p> <p>:param state: EnvState :param params: EnvParams</p> <p>:return: distrax.Categorical distribution over actions</p> Source code in <code>xlron/models/models.py</code> <pre><code>@nn.compact\ndef __call__(self, state: EnvState, params: EnvParams):\n    \"\"\"\n    The ActorGNN network takes the current network state in the form of a GraphTuple and returns\n    a distrax.Categorical distribution over actions.\n    The graph is processed by a GraphNet module, and the resulting graph is indexed to construct a matrix of\n    the edge features. The edge features are then normalised by the link length from the environment parameters,\n    and the current request is read from the request array.\n    The request is used to retrieve the edge features from the edge_features array for the corresponding\n    shortest k-paths. The edge features are aggregated for each path according to the \"agg_func\" e.g. sum,\n    and the action distribution array is updated.\n    Returns a distrax.Categorical distribution, from which actions can be sampled.\n\n    :param state: EnvState\n    :param params: EnvParams\n\n    :return: distrax.Categorical distribution over actions\n    \"\"\"\n    processed_graph = GraphNet(\n        message_passing_steps=self.message_passing_steps,\n        mlp_layers=self.mlp_layers,\n        mlp_latent=self.mlp_latent,\n        edge_embedding_size=self.edge_embedding_size,\n        edge_mlp_layers=self.edge_mlp_layers,\n        edge_mlp_latent=self.edge_mlp_latent,\n        edge_output_size=self.edge_output_size,\n        global_embedding_size=self.global_embedding_size,\n        global_mlp_layers=self.global_mlp_layers,\n        global_mlp_latent=self.global_mlp_latent,\n        global_output_size=self.global_output_size,\n        node_embedding_size=self.node_embedding_size,\n        node_mlp_layers=self.node_mlp_layers,\n        node_mlp_latent=self.node_mlp_latent,\n        node_output_size=self.node_output_size,\n        attn_mlp_layers=self.attn_mlp_layers,\n        attn_mlp_latent=self.attn_mlp_latent,\n        use_attention=self.use_attention,\n        gnn_layer_norm=self.gnn_layer_norm,\n        mlp_layer_norm=self.mlp_layer_norm,\n    )(state.graph)\n\n    # Index edge features to resemble the link-slot array\n    edge_features = processed_graph.edges if params.directed_graph else processed_graph.edges[:len(processed_graph.edges) // 2]\n    # Normalise features by normalised link length from state.link_length_array\n    if self.normalise_by_link_length:\n        edge_features = edge_features * (params.link_length_array.val/jnp.sum(params.link_length_array.val, promote_integers=False))\n    # Get the current request and initialise array of action distributions per path\n    nodes_sd, requested_bw = read_rsa_request(state.request_array)\n    init_action_array = jnp.zeros(params.k_paths * self.edge_output_size, dtype=SMALL_INT_DTYPE)\n\n    # Define a body func to retrieve path slots and update action array\n    def get_path_action_dist(i, action_array):\n        # Get the processed graph edge features corresponding to the i-th path\n        path_features = get_path_slots(edge_features, params, nodes_sd, i, agg_func=\"sum\")\n        # Update the action array with the path features\n        action_array = jax.lax.dynamic_update_slice(action_array, path_features, (i * self.edge_output_size,))\n        return action_array\n\n    path_action_logits = jax.lax.fori_loop(0, params.k_paths, get_path_action_dist, init_action_array)\n    path_action_logits = jnp.reshape(path_action_logits, (-1,)) / self.temperature\n\n    power_action_dist = None\n    mlp_features = [self.num_units] * self.num_layers\n    output_size = self.num_power_levels if self.discrete else 2\n    path_mlp = MLP(\n        mlp_features + [output_size],\n        dropout_rate=self.dropout_rate,\n        deterministic=self.deterministic,\n        layer_norm=self.mlp_layer_norm,\n    )\n    if params.__class__.__name__ == \"RSAGNModelEnvParams\":\n        if self.global_output_size &gt; 0:\n            power_logits = processed_graph.globals.reshape((-1,)) / self.temperature\n        else:\n            init_feature_array = jnp.zeros((params.k_paths, edge_features.shape[1]), dtype=LARGE_FLOAT_DTYPE)\n            # Define a body func to retrieve path slots and update action array\n            def get_power_action_dist(i, feature_array):\n                # Get the processed graph edge features corresponding to the i-th path\n                path_features = get_path_slots(edge_features, params, nodes_sd, i, agg_func=\"sum\").reshape((1, -1))\n                # Update the array with the path features\n                action_array = jax.lax.dynamic_update_slice(feature_array, path_features,(i, 0))\n                return action_array\n            path_feature_batch = jax.lax.fori_loop(0, params.k_paths, get_power_action_dist, init_feature_array)\n            power_logits = path_mlp(path_feature_batch)\n        if self.discrete:\n            power_action_dist = distrax.Categorical(logits=power_logits)\n        else:\n            alpha = self.min_concentration + jax.nn.softplus(power_logits) * (\n                    self.max_concentration - self.min_concentration\n            )\n            beta = self.min_concentration + jax.nn.softplus(power_logits) * (\n                    self.max_concentration - self.min_concentration\n            )\n            power_action_dist = distrax.Beta(alpha, beta)\n\n    # Return a distrax.Categorical distribution over actions (which can be masked later)\n    path_action_dist = distrax.Categorical(logits=path_action_logits)\n    return (path_action_dist, power_action_dist)\n</code></pre>"},{"location":"reference/#xlron.models.models.GraphNet","title":"<code>GraphNet</code>","text":"<p>               Bases: <code>Module</code></p> <p>A complete Graph Network model defined with Jraph.</p> Source code in <code>xlron/models/models.py</code> <pre><code>class GraphNet(nn.Module):\n    \"\"\"A complete Graph Network model defined with Jraph.\"\"\"\n\n    message_passing_steps: int\n    mlp_layers: int = None\n    mlp_latent: int = None\n    edge_embedding_size: int = 128\n    edge_mlp_layers: int = 3\n    edge_mlp_latent: int = 128\n    edge_output_size: int = 0\n    global_embedding_size: int = 8\n    global_mlp_layers: int = 0\n    global_mlp_latent: int = 0\n    global_output_size: int = 0\n    node_embedding_size: int = 16\n    node_mlp_layers: int = 2\n    node_mlp_latent: int = 128\n    node_output_size: int = 0\n    attn_mlp_layers: int = 2\n    attn_mlp_latent: int = 128\n    dropout_rate: float = 0\n    skip_connections: bool = True\n    use_edge_model: bool = True\n    gnn_layer_norm: bool = True\n    mlp_layer_norm: bool = False\n    deterministic: bool = True  # If true, no dropout (better for RL purposes)\n    use_attention: bool = True\n\n    @nn.compact\n    def __call__(self, graphs: jraph.GraphsTuple) -&gt; jraph.GraphsTuple:\n        # Template code from here: https://github.com/google/flax/blob/main/examples/ogbg_molpcba/models.py\n        # We will first linearly project the original features as 'embeddings'.\n        if self.mlp_latent is not None:\n            global_mlp_dims = edge_mlp_dims = node_mlp_dims = attn_mlp_dims = [self.mlp_latent] * self.mlp_layers\n        else:\n            global_mlp_dims = [self.global_mlp_latent] * self.global_mlp_layers\n            edge_mlp_dims = [self.edge_mlp_latent] * self.edge_mlp_layers\n            node_mlp_dims = [self.node_mlp_latent] * self.node_mlp_layers\n            attn_mlp_dims = [self.attn_mlp_latent] * self.attn_mlp_layers\n        if self.skip_connections:\n            # If using skip connections, we need to add the input dimensions to the output dimensions,\n            # so that the output of the MLP is the same size as the input for summing output/input\n            edge_mlp_dims = edge_mlp_dims + [self.edge_embedding_size]\n            node_mlp_dims = node_mlp_dims + [self.node_embedding_size]\n            global_mlp_dims = global_mlp_dims + [self.global_embedding_size]\n\n        embedder = jraph.GraphMapFeatures(\n            embed_edge_fn=nn.Dense(self.edge_embedding_size),\n            embed_node_fn=nn.Dense(self.node_embedding_size),\n            embed_global_fn=nn.Dense(self.global_embedding_size),\n        )\n        if graphs.edges.ndim &gt;= 3:\n            # Dims are (edges, slots, features e.g. power, source/dest)\n            # Keep the leading dimension fixed and combine the remaining dimensions\n            edges = graphs.edges.reshape((graphs.edges.shape[0], -1))\n            graphs = graphs._replace(edges=edges)\n        processed_graphs = embedder(graphs)\n\n        # Now, we will apply a Graph Network once for each message-passing round.\n        for _ in range(self.message_passing_steps):\n            if self.use_edge_model:\n                update_edge_fn = jraph.concatenated_args(\n                    MLP(\n                        edge_mlp_dims,\n                        dropout_rate=self.dropout_rate,\n                        deterministic=self.deterministic,\n                        layer_norm=self.mlp_layer_norm,\n                    )\n                )\n            else:\n                update_edge_fn = None\n\n            update_node_fn = jraph.concatenated_args(\n                MLP(\n                    node_mlp_dims,\n                    dropout_rate=self.dropout_rate,\n                    deterministic=self.deterministic,\n                    layer_norm=self.mlp_layer_norm,\n                )\n            )\n            if self.global_output_size &gt; 0:\n                update_global_fn = jraph.concatenated_args(\n                    MLP(\n                        global_mlp_dims,\n                        dropout_rate=self.dropout_rate,\n                        deterministic=self.deterministic,\n                        layer_norm=self.mlp_layer_norm,\n                    )\n                )\n            else:\n                update_global_fn = None\n\n            if self.use_attention:\n                def _attention_logit_fn(edges, sender_attr, receiver_attr, global_edge_attributes):\n                    \"\"\"Calculate attention logits using edges, nodes and global attributes.\"\"\"\n                    x = jnp.concatenate((edges, sender_attr, receiver_attr, global_edge_attributes), axis=1)\n                    return MLP(attn_mlp_dims + [1], dropout_rate=self.dropout_rate,\n                               deterministic=self.deterministic)(x)\n\n                def _attention_reduce_fn(\n                    edges: jnp.ndarray, attention: jnp.ndarray\n                ) -&gt; jnp.ndarray:\n                    # TODO - try more sophisticated attention reduce function (not sure what it would be)\n                    #  (here might help https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/JAX/tutorial7/GNN_overview.html)\n                    return attention * edges\n\n                graph_net = GraphNetGAT(\n                    update_node_fn=update_node_fn,\n                    update_edge_fn=update_edge_fn,  # Update the edges with MLP prior to attention\n                    update_global_fn=update_global_fn,\n                    attention_logit_fn=_attention_logit_fn,\n                    attention_reduce_fn=_attention_reduce_fn,\n                )\n            else:\n                graph_net = GraphNetwork(\n                    update_node_fn=update_node_fn,\n                    update_edge_fn=update_edge_fn,\n                    update_global_fn=update_global_fn,\n                )\n\n            if self.skip_connections:\n                processed_graphs = add_graphs_tuples(\n                graph_net(processed_graphs), processed_graphs\n            )\n            else:\n                processed_graphs = graph_net(processed_graphs)\n\n            if self.gnn_layer_norm:\n                processed_graphs = processed_graphs._replace(\n                    nodes=nn.LayerNorm(dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)(processed_graphs.nodes),\n                    edges=nn.LayerNorm(dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)(processed_graphs.edges),\n                    globals=nn.LayerNorm(dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)(processed_graphs.globals) if processed_graphs.globals is not None else None,\n                )\n\n        decoder = jraph.GraphMapFeatures(\n            embed_global_fn=nn.Dense(self.global_output_size, dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,) if self.global_output_size &gt; 0 else None,\n            embed_node_fn=nn.Dense(self.node_output_size, dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,) if self.node_output_size &gt; 0 else None,\n            embed_edge_fn=nn.Dense(self.edge_output_size, dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,),\n        )\n        processed_graphs = decoder(processed_graphs)\n\n        return processed_graphs\n</code></pre>"},{"location":"reference/#xlron.models.models.LaunchPowerActorCriticMLP","title":"<code>LaunchPowerActorCriticMLP</code>","text":"<p>               Bases: <code>Module</code></p> <p>In this implementation, we take an observation of th current request + statistics on each of the K candidate paths. We make K forward passes, one for each path, and output a distribution over power levels for each path. In action selection, we then sample from each distribution and use the sampled power levels to mask paths for the routing heuristic, which then determines the path taken. The selected path index is then used to select which output action, distribution, and value to use for the loss calculation.</p> Source code in <code>xlron/models/models.py</code> <pre><code>class LaunchPowerActorCriticMLP(nn.Module):\n    \"\"\"In this implementation, we take an observation of th current request + statistics on each of the K candidate paths.\n    We make K forward passes, one for each path, and output a distribution over power levels for each path.\n    In action selection, we then sample from each distribution and use the sampled power levels to mask paths for the\n    routing heuristic, which then determines the path taken. The selected path index is then used to select which output\n    action, distribution, and value to use for the loss calculation.\"\"\"\n    action_dim: Sequence[int]\n    activation: str = \"tanh\"\n    num_layers: int = 2\n    num_units: int = 64\n    layer_norm: bool = False\n    min_power_dbm: float = 0.0\n    max_power_dbm: float = 2.0\n    step_power_dbm: float = 0.1\n    discrete: bool = True\n    temperature: float = 1.0\n    k_paths: int = 5\n    num_base_features: int = 4\n    num_path_features: int = 7\n    # Beta distribution parameters (used only if discrete=False)\n    min_concentration: float = 0.1\n    max_concentration: float = 20.0\n    epsilon: float = 1e-6\n\n    @property\n    def num_power_levels(self):\n        \"\"\"Calculate number of power levels dynamically\"\"\"\n        return int((self.max_power_dbm - self.min_power_dbm) / self.step_power_dbm) + 1\n\n    @property\n    def power_levels(self):\n        \"\"\"Calculate power levels dynamically\"\"\"\n        return jnp.linspace(self.min_power_dbm, self.max_power_dbm, self.num_power_levels, dtype=SMALL_FLOAT_DTYPE)\n\n    @nn.compact\n    def __call__(self, x):\n        # Helper function to create MLP layers\n        def make_mlp(prefix):\n            layers = []\n            for i in range(self.num_layers):\n                layers.append(nn.Dense(\n                    self.num_units,\n                    kernel_init=orthogonal(np.sqrt(2)),\n                    name=f\"{prefix}_dense_{i}\",\n                    dtype=COMPUTE_DTYPE,\n                    param_dtype=PARAMS_DTYPE,\n                ))\n                if self.layer_norm:\n                    layers.append(nn.LayerNorm(name=f\"{prefix}_norm_{i}\", dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,))\n            return layers\n\n        # Initialize actor network layers\n        actor_net = make_mlp(\"actor\")\n        if self.discrete:\n            actor_out = nn.Dense(\n                self.num_power_levels,\n                kernel_init=orthogonal(0.01),\n                name=\"actor_output\",\n                dtype=COMPUTE_DTYPE,\n                param_dtype=PARAMS_DTYPE,\n            )\n        else:\n            alpha_out = nn.Dense(1, kernel_init=orthogonal(0.01), name=\"alpha\", dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)\n            beta_out = nn.Dense(1, kernel_init=orthogonal(0.01), name=\"beta\", dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)\n\n        def activate(x):\n            if self.activation == \"relu\": return jax.nn.relu(x)\n            if self.activation == \"crelu\": return crelu(x)\n            return jnp.tanh(x)\n\n        def forward(x, layers):\n            for layer in layers:\n                x = layer(x)\n                if isinstance(layer, nn.Dense):\n                    x = activate(x)\n            return x\n\n        num_base_features = self.num_base_features\n        num_path_features = self.num_path_features\n        temperature = self.temperature\n        discrete = self.discrete\n        min_concentration = self.min_concentration\n        max_concentration = self.max_concentration\n\n        # Create a class to handle the scan\n        class PathProcessor(nn.Module):\n            def __call__(self, carry, i):\n                base = x[:num_base_features]\n                path = jax.lax.dynamic_slice(\n                    x,\n                    (num_base_features + i *num_path_features,),\n                    (num_path_features,)\n                )\n                features = jnp.concatenate([base, path])\n                actor_hidden = forward(features, actor_net)\n                if discrete:\n                    out = actor_out(actor_hidden) / temperature\n                else:\n                    alpha = min_concentration + jax.nn.softplus(alpha_out(actor_hidden)) * (\n                            max_concentration - min_concentration\n                    )\n                    beta = min_concentration + jax.nn.softplus(beta_out(actor_hidden)) * (\n                            max_concentration - min_concentration\n                    )\n                    out = (alpha, beta)\n\n                return carry, out\n\n        # Scan over paths\n        _, dist_params = nn.scan(\n            PathProcessor,\n            variable_broadcast=\"params\",\n            split_rngs={\"params\": False},\n            length=self.k_paths,\n        )()(None, jnp.arange(self.k_paths, dtype=MED_INT_DTYPE))\n\n        # Initialize critic network layers\n        critic_net = make_mlp(\"critic\")\n        critic_out = nn.Dense(1, kernel_init=orthogonal(1.0), name=\"critic_output\", dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)\n        value = jnp.squeeze(critic_out(forward(x, critic_net)), axis=-1)\n\n        # Create appropriate distribution\n        if self.discrete:\n            dist = distrax.Categorical(logits=dist_params)\n        else:\n            dist = distrax.Beta(dist_params[0].reshape((self.k_paths,)), dist_params[1].reshape((self.k_paths,)))\n        # N.B. that this is a single distribution object, but it is batched over K paths\n\n        return [None, dist], value\n\n    def sample_action(self, seed, dist, log_prob=False, deterministic=False):\n        \"\"\"Sample an action and convert to power level\"\"\"\n        if self.discrete:\n            if deterministic:\n                # Take most probable action\n                raw_action = dist.mode()\n            else:\n                # Sample from distribution\n                raw_action = dist.sample(seed=seed)\n            processed_action = self.power_levels[raw_action].reshape((self.k_paths, 1))\n        else:\n            if deterministic:\n                # Use mean of Beta distribution for deterministic action\n                mean = dist.alpha / (dist.alpha + dist.beta)\n                raw_action = jnp.clip(mean, self.epsilon, 1.0 - self.epsilon)\n            else:\n                # Sample from Beta (clipping to avoid edge values with undefined gradient) and scale to power range\n                raw_action = jnp.clip(dist.sample(seed=seed), self.epsilon, 1.0 - self.epsilon)\n            processed_action = self.min_power_dbm + raw_action * (self.max_power_dbm - self.min_power_dbm)\n        processed_action = from_dbm(processed_action)\n        if log_prob:\n            return processed_action, dist.log_prob(jnp.squeeze(raw_action))\n        return processed_action\n\n    def get_action_probs(self, dist):\n        \"\"\"Get probabilities for discrete case or pdf for continuous case\"\"\"\n        if self.discrete:\n            return dist.probs()\n        else:\n            x = jnp.linspace(0, 1, 100)\n            return dist.prob(x)\n</code></pre>"},{"location":"reference/#xlron.models.models.LaunchPowerActorCriticMLP.num_power_levels","title":"<code>num_power_levels</code>  <code>property</code>","text":"<p>Calculate number of power levels dynamically</p>"},{"location":"reference/#xlron.models.models.LaunchPowerActorCriticMLP.power_levels","title":"<code>power_levels</code>  <code>property</code>","text":"<p>Calculate power levels dynamically</p>"},{"location":"reference/#xlron.models.models.LaunchPowerActorCriticMLP.get_action_probs","title":"<code>get_action_probs(dist)</code>","text":"<p>Get probabilities for discrete case or pdf for continuous case</p> Source code in <code>xlron/models/models.py</code> <pre><code>def get_action_probs(self, dist):\n    \"\"\"Get probabilities for discrete case or pdf for continuous case\"\"\"\n    if self.discrete:\n        return dist.probs()\n    else:\n        x = jnp.linspace(0, 1, 100)\n        return dist.prob(x)\n</code></pre>"},{"location":"reference/#xlron.models.models.LaunchPowerActorCriticMLP.sample_action","title":"<code>sample_action(seed, dist, log_prob=False, deterministic=False)</code>","text":"<p>Sample an action and convert to power level</p> Source code in <code>xlron/models/models.py</code> <pre><code>def sample_action(self, seed, dist, log_prob=False, deterministic=False):\n    \"\"\"Sample an action and convert to power level\"\"\"\n    if self.discrete:\n        if deterministic:\n            # Take most probable action\n            raw_action = dist.mode()\n        else:\n            # Sample from distribution\n            raw_action = dist.sample(seed=seed)\n        processed_action = self.power_levels[raw_action].reshape((self.k_paths, 1))\n    else:\n        if deterministic:\n            # Use mean of Beta distribution for deterministic action\n            mean = dist.alpha / (dist.alpha + dist.beta)\n            raw_action = jnp.clip(mean, self.epsilon, 1.0 - self.epsilon)\n        else:\n            # Sample from Beta (clipping to avoid edge values with undefined gradient) and scale to power range\n            raw_action = jnp.clip(dist.sample(seed=seed), self.epsilon, 1.0 - self.epsilon)\n        processed_action = self.min_power_dbm + raw_action * (self.max_power_dbm - self.min_power_dbm)\n    processed_action = from_dbm(processed_action)\n    if log_prob:\n        return processed_action, dist.log_prob(jnp.squeeze(raw_action))\n    return processed_action\n</code></pre>"},{"location":"reference/#xlron.models.models.MLP","title":"<code>MLP</code>","text":"<p>               Bases: <code>Module</code></p> <p>A multi-layer perceptron.</p> Source code in <code>xlron/models/models.py</code> <pre><code>class MLP(nn.Module):\n    \"\"\"A multi-layer perceptron.\"\"\"\n\n    feature_sizes: Sequence[int]\n    dropout_rate: float = 0\n    deterministic: bool = True\n    activation: Callable[[jnp.ndarray], jnp.ndarray] = nn.tanh\n    layer_norm: bool = False\n\n    @nn.compact\n    def __call__(self, inputs):\n        x = inputs\n        for size in self.feature_sizes:\n            x = nn.Dense(features=size,\n                         dtype=COMPUTE_DTYPE,\n                         param_dtype=PARAMS_DTYPE,)(x)\n            x = self.activation(x)\n            x = nn.Dropout(rate=self.dropout_rate, deterministic=self.deterministic)(\n                x\n            )\n            if self.layer_norm:\n                x = nn.LayerNorm(dtype=COMPUTE_DTYPE, param_dtype=PARAMS_DTYPE,)(x)\n        return x\n</code></pre>"},{"location":"reference/#xlron.models.models.add_graphs_tuples","title":"<code>add_graphs_tuples(graphs, other_graphs)</code>","text":"<p>Adds the nodes, edges and global features from other_graphs to graphs.</p> Source code in <code>xlron/models/models.py</code> <pre><code>def add_graphs_tuples(\n    graphs: jraph.GraphsTuple, other_graphs: jraph.GraphsTuple\n) -&gt; jraph.GraphsTuple:\n    \"\"\"Adds the nodes, edges and global features from other_graphs to graphs.\"\"\"\n    return graphs._replace(\n        nodes=graphs.nodes + other_graphs.nodes,\n        edges=graphs.edges + other_graphs.edges,\n        globals=graphs.globals + other_graphs.globals if graphs.globals is not None else None,\n    )\n</code></pre>"},{"location":"reference/#xlron.models.models.crelu","title":"<code>crelu(x)</code>","text":"<p>Computes the Concatenated ReLU (CReLU) activation function.</p> Source code in <code>xlron/models/models.py</code> <pre><code>def crelu(x):\n    \"\"\"Computes the Concatenated ReLU (CReLU) activation function.\"\"\"\n    x = jnp.concatenate([x, -x], axis=-1)\n    return nn.relu(x)\n</code></pre>"},{"location":"reference/#heuristics","title":"Heuristics","text":""},{"location":"reference/#xlron.heuristics.heuristics.DeepRMSAEnvState","title":"<code>DeepRMSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for DeepRMSA.</p> <p>Parameters:</p> Name Type Description Default <code>path_stats</code> <code>Array</code> <p>Path stats array containing</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass DeepRMSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for DeepRMSA.\n\n    Args:\n        path_stats (chex.Array): Path stats array containing\n        1. Required slots on path\n        2. Total available slots on path\n        3. Size of 1st free spectrum block\n        4. Avg. free block size\n    \"\"\"\n    path_stats: chex.Array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.EnvParams","title":"<code>EnvParams</code>","text":"<p>Dataclass to hold environment parameters. Parameters are immutable.</p> <p>Parameters:</p> Name Type Description Default <code>max_requests</code> <code>Scalar</code> <p>Maximum number of requests in an episode</p> required <code>incremental_loading</code> <code>Scalar</code> <p>Incremental increase in traffic load (non-expiring requests)</p> required <code>end_first_blocking</code> <code>Scalar</code> <p>End episode on first blocking event</p> required <code>continuous_operation</code> <code>Scalar</code> <p>If True, do not reset the environment at the end of an episode</p> required <code>edges</code> <code>Array</code> <p>Two column array defining source-dest node-pair edges of the graph</p> required <code>slot_size</code> <code>Scalar</code> <p>Spectral width of frequency slot in GHz</p> required <code>consider_modulation_format</code> <code>Scalar</code> <p>If True, consider modulation format to determine required slots</p> required <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>aggregate_slots</code> <code>Scalar</code> <p>Number of slots to aggregate into a single action (First-Fit with aggregation)</p> required <code>guardband</code> <code>Scalar</code> <p>Guard band in slots</p> required <code>directed_graph</code> <code>bool</code> <p>Whether graph is directed (one fibre per link per transmission direction)</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvParams:\n    \"\"\"Dataclass to hold environment parameters. Parameters are immutable.\n\n    Args:\n        max_requests (chex.Scalar): Maximum number of requests in an episode\n        incremental_loading (chex.Scalar): Incremental increase in traffic load (non-expiring requests)\n        end_first_blocking (chex.Scalar): End episode on first blocking event\n        continuous_operation (chex.Scalar): If True, do not reset the environment at the end of an episode\n        edges (chex.Array): Two column array defining source-dest node-pair edges of the graph\n        slot_size (chex.Scalar): Spectral width of frequency slot in GHz\n        consider_modulation_format (chex.Scalar): If True, consider modulation format to determine required slots\n        link_length_array (chex.Array): Array of link lengths\n        aggregate_slots (chex.Scalar): Number of slots to aggregate into a single action (First-Fit with aggregation)\n        guardband (chex.Scalar): Guard band in slots\n        directed_graph (bool): Whether graph is directed (one fibre per link per transmission direction)\n    \"\"\"\n    max_requests: chex.Scalar = struct.field(pytree_node=False)\n    incremental_loading: chex.Scalar = struct.field(pytree_node=False)\n    end_first_blocking: chex.Scalar = struct.field(pytree_node=False)\n    continuous_operation: chex.Scalar = struct.field(pytree_node=False)\n    edges: chex.Array = struct.field(pytree_node=False)\n    slot_size: chex.Scalar = struct.field(pytree_node=False)\n    consider_modulation_format: chex.Scalar = struct.field(pytree_node=False)\n    link_length_array: chex.Array = struct.field(pytree_node=False)\n    aggregate_slots: chex.Scalar = struct.field(pytree_node=False)\n    guardband: chex.Scalar = struct.field(pytree_node=False)\n    directed_graph: bool = struct.field(pytree_node=False)\n    maximise_throughput: bool = struct.field(pytree_node=False)\n    reward_type: str = struct.field(pytree_node=False)\n    values_bw: chex.Array = struct.field(pytree_node=False)\n    truncate_holding_time: bool = struct.field(pytree_node=False)\n    traffic_array: bool = struct.field(pytree_node=False)\n    pack_path_bits: bool = struct.field(pytree_node=False)\n    relative_arrival_times: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.EnvState","title":"<code>EnvState</code>","text":"<p>Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>current_time</code> <code>Scalar</code> <p>Current time in environment</p> required <code>holding_time</code> <code>Scalar</code> <p>Holding time of current request</p> required <code>total_timesteps</code> <code>Scalar</code> <p>Total timesteps in environment</p> required <code>total_requests</code> <code>Scalar</code> <p>Total requests in environment</p> required <code>graph</code> <code>GraphsTuple</code> <p>Graph tuple representing network state</p> required <code>full_link_slot_mask</code> <code>Array</code> <p>Action mask for link slot action (including if slot actions are aggregated)</p> required <code>accepted_services</code> <code>Array</code> <p>Number of accepted services</p> required <code>accepted_bitrate</code> <code>Array</code> <p>Accepted bitrate</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass EnvState:\n    \"\"\"Dataclass to hold environment state. State is mutable and arrays are traced on JIT compilation.\n\n    Args:\n        current_time (chex.Scalar): Current time in environment\n        holding_time (chex.Scalar): Holding time of current request\n        total_timesteps (chex.Scalar): Total timesteps in environment\n        total_requests (chex.Scalar): Total requests in environment\n        graph (jraph.GraphsTuple): Graph tuple representing network state\n        full_link_slot_mask (chex.Array): Action mask for link slot action (including if slot actions are aggregated)\n        accepted_services (chex.Array): Number of accepted services\n        accepted_bitrate (chex.Array): Accepted bitrate\n        \"\"\"\n    current_time: chex.Scalar\n    holding_time: chex.Scalar\n    arrival_time: chex.Scalar\n    total_timesteps: chex.Scalar\n    total_requests: chex.Scalar\n    graph: jraph.GraphsTuple\n    full_link_slot_mask: chex.Array\n    accepted_services: chex.Array\n    accepted_bitrate: chex.Array\n    total_bitrate: chex.Array\n    list_of_requests: chex.Array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.GNModelEnvParams","title":"<code>GNModelEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment state for GN model environments.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment state for GN model environments.\n    \"\"\"\n    ref_lambda: chex.Scalar = struct.field(pytree_node=False)\n    max_spans: chex.Scalar = struct.field(pytree_node=False)\n    max_span_length: chex.Scalar = struct.field(pytree_node=False)\n    nonlinear_coeff: chex.Scalar = struct.field(pytree_node=False)\n    raman_gain_slope: chex.Scalar = struct.field(pytree_node=False)\n    attenuation: chex.Scalar = struct.field(pytree_node=False)\n    attenuation_bar: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_coeff: chex.Scalar = struct.field(pytree_node=False)\n    dispersion_slope: chex.Scalar = struct.field(pytree_node=False)\n    transceiver_snr: chex.Array = struct.field(pytree_node=False)\n    amplifier_noise_figure: chex.Array = struct.field(pytree_node=False)\n    coherent: bool = struct.field(pytree_node=False)\n    num_roadms: chex.Scalar = struct.field(pytree_node=False)\n    roadm_loss: chex.Scalar = struct.field(pytree_node=False)\n    num_spans: chex.Scalar = struct.field(pytree_node=False)\n    launch_power_type: chex.Scalar = struct.field(pytree_node=False)\n    snr_margin: chex.Scalar = struct.field(pytree_node=False)\n    max_snr: chex.Scalar = struct.field(pytree_node=False)\n    max_power: chex.Scalar = struct.field(pytree_node=False)\n    min_power: chex.Scalar = struct.field(pytree_node=False)\n    step_power: chex.Scalar = struct.field(pytree_node=False)\n    last_fit: bool = struct.field(pytree_node=False)\n    default_launch_power: chex.Scalar = struct.field(pytree_node=False)\n    mod_format_correction: bool = struct.field(pytree_node=False)\n    monitor_active_lightpaths: bool = struct.field(pytree_node=False)  # Monitor active lightpaths for throughput calculation\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n    uniform_spans: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.GNModelEnvState","title":"<code>GNModelEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass GNModelEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    link_snr_array: chex.Array  # Available SNR on each link\n    channel_centre_bw_array: chex.Array  # Channel centre bandwidth for each active connection\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots (used for lightpath SNR calculation)\n    channel_power_array: chex.Array  # Channel power for each active connection\n    channel_centre_bw_array_prev: chex.Array  # Channel centre bandwidth for each active connection in previous timestep\n    path_index_array_prev: chex.Array  # Contains indices of lightpaths in use on slots in previous timestep\n    channel_power_array_prev: chex.Array  # Channel power for each active connection in previous timestep\n    launch_power_array: chex.Array  # Launch power array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.LogEnvState","title":"<code>LogEnvState</code>","text":"<p>Dataclass to hold environment state for logging.</p> <p>Parameters:</p> Name Type Description Default <code>env_state</code> <code>EnvState</code> <p>Environment state</p> required <code>lengths</code> <code>Scalar</code> <p>Lengths</p> required <code>returns</code> <code>Scalar</code> <p>Returns</p> required <code>cum_returns</code> <code>Scalar</code> <p>Cumulative returns</p> required <code>episode_lengths</code> <code>Scalar</code> <p>Episode lengths</p> required <code>episode_returns</code> <code>Scalar</code> <p>Episode returns</p> required <code>accepted_services</code> <code>Scalar</code> <p>Accepted services</p> required <code>accepted_bitrate</code> <code>Scalar</code> <p>Accepted bitrate</p> required <code>done</code> <code>Scalar</code> <p>Done</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass LogEnvState:\n    \"\"\"Dataclass to hold environment state for logging.\n\n    Args:\n        env_state (EnvState): Environment state\n        lengths (chex.Scalar): Lengths\n        returns (chex.Scalar): Returns\n        cum_returns (chex.Scalar): Cumulative returns\n        episode_lengths (chex.Scalar): Episode lengths\n        episode_returns (chex.Scalar): Episode returns\n        accepted_services (chex.Scalar): Accepted services\n        accepted_bitrate (chex.Scalar): Accepted bitrate\n        done (chex.Scalar): Done\n    \"\"\"\n    env_state: EnvState\n    lengths: float\n    returns: float\n    cum_returns: float\n    accepted_services: int\n    accepted_bitrate: float\n    total_bitrate: float\n    utilisation: float\n    done: bool\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.MultiBandRSAEnvParams","title":"<code>MultiBandRSAEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_start: chex.Scalar = struct.field(pytree_node=False)\n    gap_width: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.MultiBandRSAEnvState","title":"<code>MultiBandRSAEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass MultiBandRSAEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RMSAGNModelEnvParams","title":"<code>RMSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulations_array: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RMSAGNModelEnvState","title":"<code>RMSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RMSA with GN model.</p> <p>Parameters:</p> Name Type Description Default <code>link_snr_array</code> <code>Array</code> <p>Link SNR array</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RMSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RMSA with GN model.\n\n    Args:\n        link_snr_array (chex.Array): Link SNR array\n    \"\"\"\n    modulation_format_index_array: chex.Array  # Modulation format index for each active connection\n    modulation_format_index_array_prev: chex.Array  # Modulation format index for each active connection in previous timestep\n    mod_format_mask: chex.Array  # Modulation format mask\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RSAEnvParams","title":"<code>RSAEnvParams</code>","text":"<p>               Bases: <code>EnvParams</code></p> <p>Dataclass to hold environment parameters for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>num_nodes</code> <code>Scalar</code> <p>Number of nodes</p> required <code>num_links</code> <code>Scalar</code> <p>Number of links</p> required <code>link_resources</code> <code>Scalar</code> <p>Number of link resources</p> required <code>k_paths</code> <code>Scalar</code> <p>Number of paths</p> required <code>mean_service_holding_time</code> <code>Scalar</code> <p>Mean service holding time</p> required <code>load</code> <code>Scalar</code> <p>Load</p> required <code>arrival_rate</code> <code>Scalar</code> <p>Arrival rate</p> required <code>path_link_array</code> <code>Array</code> <p>Path link array</p> required <code>random_traffic</code> <code>bool</code> <p>Random traffic matrix for RSA on each reset (else uniform or custom)</p> required <code>max_slots</code> <code>Scalar</code> <p>Maximum number of slots</p> required <code>path_se_array</code> <code>Array</code> <p>Path spectral efficiency array</p> required <code>deterministic_requests</code> <code>bool</code> <p>If True, use deterministic requests</p> required <code>multiple_topologies</code> <code>bool</code> <p>If True, use multiple topologies</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvParams(EnvParams):\n    \"\"\"Dataclass to hold environment parameters for RSA.\n\n    Args:\n        num_nodes (chex.Scalar): Number of nodes\n        num_links (chex.Scalar): Number of links\n        link_resources (chex.Scalar): Number of link resources\n        k_paths (chex.Scalar): Number of paths\n        mean_service_holding_time (chex.Scalar): Mean service holding time\n        load (chex.Scalar): Load\n        arrival_rate (chex.Scalar): Arrival rate\n        path_link_array (chex.Array): Path link array\n        random_traffic (bool): Random traffic matrix for RSA on each reset (else uniform or custom)\n        max_slots (chex.Scalar): Maximum number of slots\n        path_se_array (chex.Array): Path spectral efficiency array\n        deterministic_requests (bool): If True, use deterministic requests\n        multiple_topologies (bool): If True, use multiple topologies\n    \"\"\"\n    num_nodes: chex.Scalar = struct.field(pytree_node=False)\n    num_links: chex.Scalar = struct.field(pytree_node=False)\n    link_resources: chex.Scalar = struct.field(pytree_node=False)\n    k_paths: chex.Scalar = struct.field(pytree_node=False)\n    mean_service_holding_time: chex.Scalar = struct.field(pytree_node=False)\n    load: chex.Scalar = struct.field(pytree_node=False)\n    arrival_rate: chex.Scalar = struct.field(pytree_node=False)\n    path_link_array: chex.Array = struct.field(pytree_node=False)\n    random_traffic: bool = struct.field(pytree_node=False)\n    max_slots: chex.Scalar = struct.field(pytree_node=False)\n    path_se_array: chex.Array = struct.field(pytree_node=False)\n    deterministic_requests: bool = struct.field(pytree_node=False)\n    multiple_topologies: bool = struct.field(pytree_node=False)\n    log_actions: bool = struct.field(pytree_node=False)\n    disable_node_features: bool = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RSAEnvState","title":"<code>RSAEnvState</code>","text":"<p>               Bases: <code>EnvState</code></p> <p>Dataclass to hold environment state for RSA.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>request_array</code> <code>Array</code> <p>Request array</p> required <code>link_slot_departure_array</code> <code>Array</code> <p>Link slot departure array</p> required <code>link_slot_mask</code> <code>Array</code> <p>Link slot mask</p> required <code>traffic_matrix</code> <code>Array</code> <p>Traffic matrix</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAEnvState(EnvState):\n    \"\"\"Dataclass to hold environment state for RSA.\n\n    Args:\n        link_slot_array (chex.Array): Link slot array\n        request_array (chex.Array): Request array\n        link_slot_departure_array (chex.Array): Link slot departure array\n        link_slot_mask (chex.Array): Link slot mask\n        traffic_matrix (chex.Array): Traffic matrix\n    \"\"\"\n    link_slot_array: chex.Array\n    request_array: chex.Array\n    link_slot_departure_array: chex.Array\n    link_slot_mask: chex.Array\n    traffic_matrix: chex.Array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RSAGNModelEnvParams","title":"<code>RSAGNModelEnvParams</code>","text":"<p>               Bases: <code>GNModelEnvParams</code></p> <p>Dataclass to hold environment params for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvParams(GNModelEnvParams):\n    \"\"\"Dataclass to hold environment params for RSA with GN model.\n    \"\"\"\n    min_snr: chex.Scalar = struct.field(pytree_node=False)\n    fec_threshold: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RSAGNModelEnvState","title":"<code>RSAGNModelEnvState</code>","text":"<p>               Bases: <code>GNModelEnvState</code></p> <p>Dataclass to hold environment state for RSA with GN model.</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAGNModelEnvState(GNModelEnvState):\n    \"\"\"Dataclass to hold environment state for RSA with GN model.\n    \"\"\"\n    active_lightpaths_array: chex.Array  # Active lightpath array. 1 x M array. Each value is a lightpath index. Used to calculate total throughput.\n    active_lightpaths_array_departure: chex.Array  # Active lightpath array departure time.\n    throughput: chex.Array  # Current network throughput\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RSAMultibandEnvParams","title":"<code>RSAMultibandEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for MultiBandRSA (RBSA).\n    \"\"\"\n    gap_starts: chex.Array = struct.field(pytree_node=False)\n    gap_widths: chex.Array = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RSAMultibandEnvState","title":"<code>RSAMultibandEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for MultiBandRSA (RBSA).</p> Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RSAMultibandEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for MultiBandRSA (RBSA).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.RWALightpathReuseEnvState","title":"<code>RWALightpathReuseEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for RWA with lightpath reuse.</p> <p>Parameters:</p> Name Type Description Default <code>path_index_array</code> <code>Array</code> <p>Contains indices of lightpaths in use on slots</p> required <code>path_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of each lightpath</p> required <code>link_capacity_array</code> <code>Array</code> <p>Contains remaining capacity of lightpath on each link-slot</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass RWALightpathReuseEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for RWA with lightpath reuse.\n\n    Args:\n        path_index_array (chex.Array): Contains indices of lightpaths in use on slots\n        path_capacity_array (chex.Array): Contains remaining capacity of each lightpath\n        link_capacity_array (chex.Array): Contains remaining capacity of lightpath on each link-slot\n    \"\"\"\n    path_index_array: chex.Array  # Contains indices of lightpaths in use on slots\n    path_capacity_array: chex.Array  # Contains remaining capacity of each lightpath\n    link_capacity_array: chex.Array  # Contains remaining capacity of lightpath on each link-slot\n    time_since_last_departure: chex.Array  # Time since last departure\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.VONEEnvParams","title":"<code>VONEEnvParams</code>","text":"<p>               Bases: <code>RSAEnvParams</code></p> <p>Dataclass to hold environment parameters for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_resources</code> <code>Scalar</code> <p>Number of node resources</p> required <code>max_edges</code> <code>Scalar</code> <p>Maximum number of edges</p> required <code>min_node_resources</code> <code>Scalar</code> <p>Minimum number of node resources</p> required <code>max_node_resources</code> <code>Scalar</code> <p>Maximum number of node resources</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvParams(RSAEnvParams):\n    \"\"\"Dataclass to hold environment parameters for VONE.\n\n    Args:\n        node_resources (chex.Scalar): Number of node resources\n        max_edges (chex.Scalar): Maximum number of edges\n        min_node_resources (chex.Scalar): Minimum number of node resources\n        max_node_resources (chex.Scalar): Maximum number of node resources\n    \"\"\"\n    node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_edges: chex.Scalar = struct.field(pytree_node=False)\n    min_node_resources: chex.Scalar = struct.field(pytree_node=False)\n    max_node_resources: chex.Scalar = struct.field(pytree_node=False)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.VONEEnvState","title":"<code>VONEEnvState</code>","text":"<p>               Bases: <code>RSAEnvState</code></p> <p>Dataclass to hold environment state for VONE.</p> <p>Parameters:</p> Name Type Description Default <code>node_capacity_array</code> <code>Array</code> <p>Node capacity array</p> required <code>node_resource_array</code> <code>Array</code> <p>Node resource array</p> required <code>node_departure_array</code> <code>Array</code> <p>Node departure array</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>action_history</code> <code>Array</code> <p>Action history</p> required <code>node_mask_s</code> <code>Array</code> <p>Node mask for source node</p> required <code>node_mask_d</code> <code>Array</code> <p>Node mask for destination node</p> required <code>virtual_topology_patterns</code> <code>Array</code> <p>Virtual topology patterns</p> required <code>values_nodes</code> <code>Array</code> <p>Values for nodes</p> required Source code in <code>xlron/environments/dataclasses.py</code> <pre><code>@struct.dataclass\nclass VONEEnvState(RSAEnvState):\n    \"\"\"Dataclass to hold environment state for VONE.\n\n    Args:\n        node_capacity_array (chex.Array): Node capacity array\n        node_resource_array (chex.Array): Node resource array\n        node_departure_array (chex.Array): Node departure array\n        action_counter (chex.Array): Action counter\n        action_history (chex.Array): Action history\n        node_mask_s (chex.Array): Node mask for source node\n        node_mask_d (chex.Array): Node mask for destination node\n        virtual_topology_patterns (chex.Array): Virtual topology patterns\n        values_nodes (chex.Array): Values for nodes\n    \"\"\"\n    node_capacity_array: chex.Array\n    node_resource_array: chex.Array\n    node_departure_array: chex.Array\n    action_counter: chex.Array\n    action_history: chex.Array\n    node_mask_s: chex.Array\n    node_mask_d: chex.Array\n    virtual_topology_patterns: chex.Array\n    values_nodes: chex.Array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.aggregate_slots","title":"<code>aggregate_slots(full_mask, params)</code>","text":"<p>Aggregate slot mask to reduce action space. Only used if the --aggregate_slots flag is set to &gt; 1. Aggregated action is valid if there is one valid slot action within the aggregated action window.</p> <p>Parameters:</p> Name Type Description Default <code>full_mask</code> <code>Array</code> <p>slot mask</p> required <code>params</code> <code>EnvParams</code> <p>environment parameters</p> required <p>Returns:</p> Name Type Description <code>agg_mask</code> <code>Array</code> <p>aggregated slot mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef aggregate_slots(full_mask: chex.Array, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Aggregate slot mask to reduce action space. Only used if the --aggregate_slots flag is set to &gt; 1.\n    Aggregated action is valid if there is one valid slot action within the aggregated action window.\n\n    Args:\n        full_mask: slot mask\n        params: environment parameters\n\n    Returns:\n        agg_mask: aggregated slot mask\n    \"\"\"\n\n    num_actions = math.ceil(params.link_resources/params.aggregate_slots)\n    agg_mask = jnp.zeros((params.k_paths, num_actions), dtype=LARGE_FLOAT_DTYPE)\n\n    def get_max(i, mask_val):\n        \"\"\"Get maximum value of array slice of length aggregate_slots.\"\"\"\n        mask_slice = jax.lax.dynamic_slice(\n                mask_val,\n                (0, i * params.aggregate_slots,),\n                (1,  params.aggregate_slots,),\n            )\n        max_slice = jnp.max(mask_slice).reshape(1, -1)\n        return max_slice\n\n    def update_window_max(i, val):\n        \"\"\"Update ith index 'agg_mask' with max of ith slice of length aggregate_slots from 'full_mask'.\n\n        Args:\n            i: increments as += aggregate_slots\n            val: tuple of (agg_mask, path_mask, path_index).\n        Returns:\n            new_agg_mask: agg_mask is updated with max of path_mask for window size aggregate_slots\n            mask: mask is unchanged\n            path_index: path_index is unchanged\n        \"\"\"\n        agg_mask = val[0]\n        full_mask = val[1]\n        path_index = val[2]\n        new_agg_mask = jax.lax.dynamic_update_slice(\n            agg_mask,\n            get_max(i, full_mask),\n            (path_index, i),\n        )\n        return new_agg_mask, full_mask, path_index\n\n    def apply_to_path_mask(i, val):\n        \"\"\"\n        Loop through each path for num_actions steps and get_window_max at each step.\n\n        Args:\n            i: path index\n            val: tuple of (agg_mask, mask) where mask is original link-slot mask and agg_mask is resulting aggregated mask\n        Returns:\n            new_agg_mask: agg_mask is updated with aggregated path mask\n            mask: mask is unchanged\n        \"\"\"\n        val = (\n            val[0],  # aggregated mask (to be updated)\n            val[1][i].reshape(1, -1),  # mask for path i\n            i  # path index\n        )\n        new_agg_mask = jax.lax.fori_loop(\n            0,\n            num_actions,\n            update_window_max,\n            val,\n        )[0]\n        return new_agg_mask, full_mask\n\n    return jax.lax.fori_loop(\n            0,\n            params.k_paths,\n            apply_to_path_mask,\n            (agg_mask, full_mask),\n        )\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.best_fit","title":"<code>best_fit(state, params)</code>","text":"<p>Best-Fit Spectrum Allocation. Returns the best fit slot for each path.</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>def best_fit(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Best-Fit Spectrum Allocation. Returns the best fit slot for each path.\"\"\"\n    mask = get_action_mask(state, params)\n    link_slot_array = jnp.where(state.link_slot_array &lt; 0, 1., state.link_slot_array)\n    nodes_sd, requested_bw = read_rsa_request(state.request_array)\n\n    # We need to define a wrapper function in order to vmap with named arguments\n    def _find_block_sizes(arr, starts_only=False, reverse=True):\n        return jax.vmap(find_block_sizes, in_axes=(0, None, None))(arr, starts_only, reverse)\n\n    block_sizes_right = _find_block_sizes(link_slot_array, starts_only=False, reverse=False)\n    block_sizes_left = _find_block_sizes(link_slot_array, starts_only=False, reverse=True)\n    block_sizes = jnp.maximum((block_sizes_left + block_sizes_right) - 1, 0)\n    paths = get_paths(params, nodes_sd)\n    se = get_paths_se(params, nodes_sd) if params.consider_modulation_format else jnp.ones((params.k_paths,))\n    num_slots = jax.vmap(required_slots, in_axes=(None, 0, None, None))(requested_bw, se, params.slot_size, params.guardband)\n\n    # Quantify how well the request fits within a free spectral block\n    def get_bf_on_path(path, blocks, req_slots):\n        fits = jax.vmap(lambda x: x - req_slots, in_axes=0)(blocks)\n        fits = jnp.where(fits &gt;= 0, fits, params.link_resources)\n        path_fit = jnp.dot(path, fits) / jnp.sum(path)\n        return path_fit\n    fits_block = jax.vmap(lambda x, y, z: get_bf_on_path(x, y, z), in_axes=(0, None, 0))(paths, block_sizes, num_slots)\n\n    # Quantity much of a gap there is between the assigned slots and the next occupied slots on the left\n    def get_bf_on_path_left(path, blocks, req_slots):\n        fits = jax.vmap(lambda x: x - req_slots, in_axes=0)(blocks)\n        fits = jnp.where(fits &gt;= 0, fits, params.link_resources)\n        fits_shift = jax.lax.dynamic_slice(fits, (0, 1), (fits.shape[0], fits.shape[1]-1))\n        fits_shift = jnp.concatenate((jnp.full((fits.shape[0], 1), params.link_resources), fits_shift), axis=1)\n        fits = fits + 1/jnp.maximum(fits_shift, 1)\n        path_fit = jnp.dot(path, fits) / jnp.sum(path)\n        return path_fit\n    fits_left = jax.vmap(lambda x, y, z: get_bf_on_path_left(x, y, z), in_axes=(0, None, 0))(paths, block_sizes_left, num_slots)\n\n    # Quantity much of a gap there is between the assigned slots and the next occupied slots on the right\n    def get_bf_on_path_right(path, blocks, req_slots):\n        fits = jax.vmap(lambda x: x - req_slots, in_axes=0)(blocks)\n        fits = jnp.where(fits &gt;= 0, fits, params.link_resources)\n        fits_shift = jax.lax.dynamic_slice(fits, (0, 0), (fits.shape[0], fits.shape[1] - 1))\n        fits_shift = jnp.concatenate((fits_shift, jnp.full((fits.shape[0], 1), params.link_resources)), axis=1)\n        fits = fits + 1/jnp.maximum(fits_shift, 1)\n        path_fit = jnp.dot(path, fits) / jnp.sum(path)\n        return path_fit\n    fits_right = jax.vmap(lambda x, y, z: get_bf_on_path_right(x, y, z), in_axes=(0, None, 0))(paths, block_sizes_right, num_slots)\n\n    # Sum the contribution to the overall quality of fit, and scale down the left/right contributions\n    fits = jnp.sum(jnp.stack((fits_block, fits_left/params.link_resources, fits_right/params.link_resources), axis=0), axis=0)\n    # Mask out occupied lightpaths (in case the quality of fit on some links is good enough to be considered, even if the overall path is invalid)\n    fits = jnp.where(mask == 0, jnp.inf, fits)\n    best_slots = jnp.argmin(fits, axis=1)\n    best_fits = jnp.min(fits, axis=1)\n    return best_slots, best_fits\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.bf_ksp","title":"<code>bf_ksp(state, params)</code>","text":"<p>Get the first available slot from the first k-shortest paths Method: Go through action mask and find the first available slot on all paths</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef bf_ksp(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the first available slot from the first k-shortest paths\n    Method: Go through action mask and find the first available slot on all paths\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    best_slots, fitness = best_fit(state, params)\n    # Chosen path is the one with the best fit\n    path_index = jnp.argmin(fitness)\n    slot_index = best_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.calculate_path_capacity","title":"<code>calculate_path_capacity(path_length, min_request=100, scale_factor=1.0, alpha=0.0002, NF=4.5, B=10000000000000.0, R_s=100000000000.0, beta_2=-2.17e-26, gamma=0.0012, L_s=100000.0, lambda0=1.55e-06)</code>","text":"<p>From Nevin JOCN paper 2022: https://discovery.ucl.ac.uk/id/eprint/10175456/1/RL_JOCN_accepted.pdf</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def calculate_path_capacity(\n        path_length,\n        min_request=100,  # Minimum data rate request size\n        scale_factor=1.0,  # Scale factor for link capacity\n        alpha=0.2e-3, # Fibre attenuation coefficient\n        NF=4.5,  # Amplifier noise figure\n        B=10e12,  # Total modulated bandwidth\n        R_s=100e9,  # Symbol rate\n        beta_2=-21.7e-27,  # Dispersion parameter\n        gamma=1.2e-3,  # Nonlinear coefficient\n        L_s=100e3,  # Span length\n        lambda0=1550e-9,  # Wavelength\n):\n    \"\"\"From Nevin JOCN paper 2022: https://discovery.ucl.ac.uk/id/eprint/10175456/1/RL_JOCN_accepted.pdf\"\"\"\n    alpha_lin = alpha / 4.343  # Linear attenuation coefficient\n    N_spans = jnp.floor(path_length * 1e3 / L_s)  # Number of fibre spans on path\n    L_eff = (1 - jnp.exp(-alpha_lin * L_s)) / alpha_lin  # Effective length of span in m\n    sigma_2_ase = (jnp.exp(alpha_lin * L_s) - 1) * 10**(NF/10) * 6.626e-34 * 2.998e8 * R_s / lambda0  # ASE noise power\n    span_NSR = jnp.cbrt(2 * sigma_2_ase**2 * alpha_lin * gamma**2 * L_eff**2 *\n                        jnp.log(jnp.pi**2 * jnp.abs(beta_2) * B**2 / alpha_lin) / (jnp.pi * jnp.abs(beta_2) * R_s**2))  # Noise-to-signal ratio per span\n    path_NSR = jnp.where(N_spans &lt; 1, 1, N_spans) * span_NSR  # Noise-to-signal ratio per path\n    path_capacity = 2 * R_s/1e9 * jnp.log2(1 + 1/path_NSR)  # Capacity of path in Gbps\n    # Round link capacity down to nearest increment of minimum request size and apply scale factor\n    path_capacity = jnp.floor(path_capacity * scale_factor / min_request) * min_request\n    return path_capacity\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.calculate_path_stats","title":"<code>calculate_path_stats(state, params, request)</code>","text":"<p>For use in DeepRMSA agent observation space. Calculate: 1. Size of 1st suitable free spectrum block 2. Index of 1st suitable free spectrum block 3. Required slots on path 4. Avg. free block size 5. Free slots</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>stats</code> <code>Array</code> <p>Array of calculated path statistics</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef calculate_path_stats(state: EnvState, params: EnvParams, request: chex.Array) -&gt; chex.Array:\n    \"\"\"For use in DeepRMSA agent observation space.\n    Calculate:\n    1. Size of 1st suitable free spectrum block\n    2. Index of 1st suitable free spectrum block\n    3. Required slots on path\n    4. Avg. free block size\n    5. Free slots\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        stats: Array of calculated path statistics\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_val = jnp.zeros((params.k_paths, 5), dtype=LARGE_FLOAT_DTYPE)\n    # TODO - check if the normalisation is useful\n    def body_fun(i, val):\n        link_resources = jnp.array(params.link_resources, dtype=LARGE_FLOAT_DTYPE)\n        slot_size = jnp.array(params.slot_size, dtype=LARGE_FLOAT_DTYPE)\n        slots = get_path_slots(state.link_slot_array, params, nodes_sd, i)\n        se = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else jnp.array([1], dtype=SMALL_INT_DTYPE)\n        req_slots = jnp.squeeze(required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband))\n        req_slots_norm = req_slots * slot_size / jnp.max(params.values_bw.val)\n        free_slots_norm = jnp.sum(jnp.where(slots == zero, one, zero), promote_integers=False) / link_resources\n        block_sizes = find_block_sizes(slots)\n        first_block_index = jnp.argmax(block_sizes &gt;= req_slots)\n        first_block_index_norm = first_block_index.astype(LARGE_FLOAT_DTYPE) / link_resources\n        first_block_size_norm = jnp.squeeze(\n            jax.lax.dynamic_slice(block_sizes, (first_block_index,), (1,))\n        ) / req_slots.astype(LARGE_FLOAT_DTYPE)\n        avg_block_size_norm = (jnp.sum(block_sizes) /\n                               jnp.max(jnp.array([jnp.sum(find_block_starts(slots), promote_integers=False), 1])) /\n                               req_slots)\n        val = jax.lax.dynamic_update_slice(\n            val,\n            jnp.array([[\n                first_block_size_norm,\n                first_block_index_norm,\n                req_slots_norm,\n                avg_block_size_norm.astype(LARGE_FLOAT_DTYPE),\n                free_slots_norm\n            ]]),\n            (i, 0)\n        )  # N.B. that all values are normalised\n        return val\n\n    stats = jax.lax.fori_loop(\n            0,\n            params.k_paths,\n            body_fun,\n            init_val,\n        )\n\n    return stats\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_action_rmsa_gn_model","title":"<code>check_action_rmsa_gn_model(state, action, params)</code>","text":"<p>Check if action is valid for RSA GN model Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters     action (chex.Array): Action array Returns:     bool: True if action is invalid, False if action is valid</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef check_action_rmsa_gn_model(state: EnvState, action: Optional[chex.Array], params: EnvParams) -&gt; bool:\n    \"\"\"Check if action is valid for RSA GN model\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        action (chex.Array): Action array\n    Returns:\n        bool: True if action is invalid, False if action is valid\n    \"\"\"\n    # Check if action is valid\n    # TODO - log failure reasons in info\n    snr_sufficient_check = check_snr_sufficient(state, params)\n    spectrum_reuse_check = check_no_spectrum_reuse(state.link_slot_array)\n    # jax.debug.print(\"spectrum_reuse_check {}\", spectrum_reuse_check, ordered=True)\n    # jax.debug.print(\"snr_sufficient_check {}\", snr_sufficient_check, ordered=True)\n    return jnp.any(jnp.stack((\n        spectrum_reuse_check,\n        snr_sufficient_check,\n    )))\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_action_rsa","title":"<code>check_action_rsa(state)</code>","text":"<p>Check if action is valid. Combines checks for: - no spectrum reuse</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_action_rsa(state):\n    \"\"\"Check if action is valid.\n    Combines checks for:\n    - no spectrum reuse\n\n    Args:\n        state: current state\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(jnp.stack((\n        check_no_spectrum_reuse(state.link_slot_array),\n    )))\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_action_rwalr","title":"<code>check_action_rwalr(state, action, params)</code>","text":"<p>Combines checks for: - no spectrum reuse - lightpath available and existing</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_action_rwalr(state: EnvState, action: chex.Array, params: EnvParams) -&gt; bool:\n    \"\"\"Combines checks for:\n    - no spectrum reuse\n    - lightpath available and existing\n\n    Args:\n        state: Environment state\n\n    Returns:\n        bool: True if check failed, False if check passed\n\n    \"\"\"\n    return jnp.any(jnp.stack((\n        check_no_spectrum_reuse(state.link_slot_array),\n        jnp.logical_not(check_lightpath_available_and_existing(state, params, action)[0]),\n    )))\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_all_nodes_assigned","title":"<code>check_all_nodes_assigned(node_departure_array, total_requested_nodes)</code>","text":"<p>Count negative values on each node (row) in node departure array, sum them, must equal total requested_nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>Node departure array (N x R) where N is number of nodes and R is number of resources</p> required <code>total_requested_nodes</code> <code>int</code> <p>Total requested nodes (int)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_all_nodes_assigned(node_departure_array: chex.Array, total_requested_nodes: int) -&gt; bool:\n    \"\"\"Count negative values on each node (row) in node departure array, sum them, must equal total requested_nodes.\n\n    Args:\n        node_departure_array: Node departure array (N x R) where N is number of nodes and R is number of resources\n        total_requested_nodes: Total requested nodes (int)\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.sum(jnp.sum(jnp.where(node_departure_array &lt; 0, 1, 0), axis=1)) != total_requested_nodes\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_lightpath_available_and_existing","title":"<code>check_lightpath_available_and_existing(state, params, action)</code>","text":"<p>Check if lightpath is available and existing. Available means that the lightpath does not use slots occupied by a different lightpath. Existing means that the lightpath has already been established.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>lightpath_available_check</code> <code>Tuple[Array, Array, Array, Array]</code> <p>True if lightpath is available</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef check_lightpath_available_and_existing(state: EnvState, params: EnvParams, action: chex.Array) -&gt; (\n        Tuple)[chex.Array, chex.Array, chex.Array, chex.Array]:\n    \"\"\"Check if lightpath is available and existing.\n    Available means that the lightpath does not use slots occupied by a different lightpath.\n    Existing means that the lightpath has already been established.\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        lightpath_available_check: True if lightpath is available\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_index, initial_slot_index = process_path_action(state, params, action)\n    path = get_paths(params, nodes_sd)[path_index]\n    # Get unique lightpath index\n    lightpath_index = get_lightpath_index(params, nodes_sd, path_index)\n    # Get mask for slots that lightpath will occupy\n    # negative numbers used so as not to conflict with lightpath indices\n    new_lightpath_mask = vmap_set_path_links(\n        jnp.full((params.num_links, 1), -2), path, 0, 1, -1\n    )\n    path_index_array = state.path_index_array[:, initial_slot_index].reshape(-1, 1)\n    masked_path_index_array = jnp.where(\n        new_lightpath_mask == -1, path_index_array, -2\n    )\n    lightpath_mask = jnp.where(\n        path_index_array == lightpath_index, -1, -2\n    )  # Allow current lightpath\n    lightpath_existing_check = jnp.array_equal(lightpath_mask, new_lightpath_mask)  # True if all slots are same\n    lightpath_mask = jnp.where(masked_path_index_array == -1, -1, lightpath_mask)  # Allow empty slots\n    # True if all slots are same or empty\n    lightpath_available_check = jnp.logical_or(\n        jnp.array_equal(lightpath_mask, new_lightpath_mask), lightpath_existing_check\n    )\n    curr_lightpath_capacity = jnp.max(\n        jnp.where(new_lightpath_mask == -1, state.link_capacity_array[:, initial_slot_index].reshape(-1, 1), 0)\n    )\n    return lightpath_available_check, lightpath_existing_check, curr_lightpath_capacity, lightpath_index\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_min_two_nodes_assigned","title":"<code>check_min_two_nodes_assigned(node_departure_array)</code>","text":"<p>Count negative values on each node (row) in node departure array, sum them, must be 2 or greater. This check is important if e.g. an action contains 2 nodes the same therefore only assigns 1 node. Return False if check passed, True if check failed</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>Node departure array (N x R) where N is number of nodes and R is number of resources</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_min_two_nodes_assigned(node_departure_array: chex.Array):\n    \"\"\"Count negative values on each node (row) in node departure array, sum them, must be 2 or greater.\n    This check is important if e.g. an action contains 2 nodes the same therefore only assigns 1 node.\n    Return False if check passed, True if check failed\n\n    Args:\n        node_departure_array: Node departure array (N x R) where N is number of nodes and R is number of resources\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.sum(jnp.sum(jnp.where(node_departure_array &lt; 0, 1, 0), axis=1)) &lt;= 1\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_no_spectrum_reuse","title":"<code>check_no_spectrum_reuse(link_slot_array)</code>","text":"<p>slot-=1 when used, should be zero when unoccupied, so check if any &lt; -1 in slot array.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <p>Link slot array (L x S) where L is number of links and S is number of slots</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_no_spectrum_reuse(link_slot_array):\n    \"\"\"slot-=1 when used, should be zero when unoccupied, so check if any &lt; -1 in slot array.\n\n    Args:\n        link_slot_array: Link slot array (L x S) where L is number of links and S is number of slots\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(link_slot_array &lt; -1)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_node_capacities","title":"<code>check_node_capacities(capacity_array)</code>","text":"<p>Sum selected nodes array and check less than node resources.</p> <p>Parameters:</p> Name Type Description Default <code>capacity_array</code> <code>Array</code> <p>Node capacity array (N x 1) where N is number of nodes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_node_capacities(capacity_array: chex.Array) -&gt; bool:\n    \"\"\"Sum selected nodes array and check less than node resources.\n\n    Args:\n        capacity_array: Node capacity array (N x 1) where N is number of nodes\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(capacity_array &lt; 0)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_snr_sufficient","title":"<code>check_snr_sufficient(state, params)</code>","text":"<p>Check if SNR is sufficient for all connections Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters Returns:     jnp.array: 1 if SNR is sufficient for connection else 0</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_snr_sufficient(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Check if SNR is sufficient for all connections\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: 1 if SNR is sufficient for connection else 0\n    \"\"\"\n    # TODO - this check needs to be faster!\n    required_snr_array = get_required_snr_se_kurtosis_array(state.modulation_format_index_array, 2, params)\n    # Transform lightpath index array by getting lightpath value, getting path-link array, and summing inverse link SNRs\n    lightpath_snr_array = get_lightpath_snr(state, params)\n    check_snr_sufficient = jnp.where(lightpath_snr_array &gt;= required_snr_array, 0, 1)\n    # jax.debug.print(\"check_snr_sufficient {}\", check_snr_sufficient, ordered=True)\n    # jax.debug.print(\"required_snr_array {}\", required_snr_array, ordered=True)\n    # jax.debug.print(\"lightpath_snr_array {}\", lightpath_snr_array, ordered=True)\n    # jax.debug.print(\"state.modulation_format_index_array {}\", state.modulation_format_index_array, ordered=True)\n    # jax.debug.print(\"state.channel_centre_bw_array {}\", state.channel_centre_bw_array, ordered=True)\n    # jax.debug.print(\"state.channel_power_array {}\", state.channel_power_array, ordered=True)\n    return jnp.any(check_snr_sufficient)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_topology","title":"<code>check_topology(action_history, topology_pattern)</code>","text":"<p>Check that each unique virtual node (as indicated by topology pattern) is assigned to a consistent physical node i.e. start and end node of ring is same physical node. Method: For each node index in topology pattern, mask action history with that index, then find max value in masked array. If max value is not the same for all values for that virtual node in action history, then return 1, else 0. Array should be all zeroes at the end, so do an any() check on that. e.g. virtual topology pattern = [2,1,3,1,4,1,2]  3 node ring action history = [0,34,4,0,3,1,0] meaning v node \"2\" goes p node 0, v node \"3\" goes p node 4, v node \"4\" goes p node 3 The numbers in-between relate to the slot action. If any value in the array is 1, a virtual node is assigned to multiple different physical nodes. Need to check from both perspectives: 1. For each virtual node, check that all physical nodes are the same 2. For each physical node, check that all virtual nodes are the same</p> <p>Parameters:</p> Name Type Description Default <code>action_history</code> <p>Action history</p> required <code>topology_pattern</code> <p>Topology pattern</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_topology(action_history, topology_pattern):\n    \"\"\"Check that each unique virtual node (as indicated by topology pattern) is assigned to a consistent physical node\n    i.e. start and end node of ring is same physical node.\n    Method:\n    For each node index in topology pattern, mask action history with that index, then find max value in masked array.\n    If max value is not the same for all values for that virtual node in action history, then return 1, else 0.\n    Array should be all zeroes at the end, so do an any() check on that.\n    e.g. virtual topology pattern = [2,1,3,1,4,1,2]  3 node ring\n    action history = [0,34,4,0,3,1,0]\n    meaning v node \"2\" goes p node 0, v node \"3\" goes p node 4, v node \"4\" goes p node 3\n    The numbers in-between relate to the slot action.\n    If any value in the array is 1, a virtual node is assigned to multiple different physical nodes.\n    Need to check from both perspectives:\n    1. For each virtual node, check that all physical nodes are the same\n    2. For each physical node, check that all virtual nodes are the same\n\n    Args:\n        action_history: Action history\n        topology_pattern: Topology pattern\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    def loop_func_virtual(i, val):\n        # Get indices of physical node in action history that correspond to virtual node i\n        masked_val = jnp.where(i == topology_pattern, val, -1)\n        # Get maximum value at those indices (should all be same)\n        max_node = jnp.max(masked_val)\n        # For relevant indices, if max value then return 0 else 1\n        val = jnp.where(masked_val != -1, masked_val != max_node, val)\n        return val\n    def loop_func_physical(i, val):\n        # Get indices of virtual nodes in topology pattern that correspond to physical node i\n        masked_val = jnp.where(i == action_history, val, -1)\n        # Get maximum value at those indices (should all be same)\n        max_node = jnp.max(masked_val)\n        # For relevant indices, if max value then return 0 else 1\n        val = jnp.where(masked_val != -1, masked_val != max_node, val)\n        return val\n    topology_pattern = topology_pattern[::2]  # Only look at node indices, not slot actions\n    action_history = action_history[::2]\n    check_virtual = jax.lax.fori_loop(jnp.min(topology_pattern), jnp.max(topology_pattern)+1, loop_func_virtual, action_history)\n    check_physical = jax.lax.fori_loop(jnp.min(action_history), jnp.max(action_history)+1, loop_func_physical, topology_pattern)\n    check = jnp.concatenate((check_virtual, check_physical))\n    return jnp.any(check)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_unique_nodes","title":"<code>check_unique_nodes(node_departure_array)</code>","text":"<p>Count negative values on each node (row) in node departure array, must not exceed 1.</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>Node departure array (N x R) where N is number of nodes and R is number of resources</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef check_unique_nodes(node_departure_array: chex.Array) -&gt; bool:\n    \"\"\"Count negative values on each node (row) in node departure array, must not exceed 1.\n\n    Args:\n        node_departure_array: Node departure array (N x R) where N is number of nodes and R is number of resources\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    return jnp.any(jnp.sum(jnp.where(node_departure_array &lt; zero, one, zero), axis=1, promote_integers=False) &gt; one)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.check_vone_action","title":"<code>check_vone_action(state, remaining_actions, total_requested_nodes)</code>","text":"<p>Check if action is valid. Combines checks for: - sufficient node capacities - unique nodes assigned - minimum two nodes assigned - all requested nodes assigned - correct topology pattern - no spectrum reuse</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>current state</p> required <code>remaining_actions</code> <p>remaining actions</p> required <code>total_requested_nodes</code> <p>total requested nodes</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if check failed, False if check passed</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def check_vone_action(state, remaining_actions, total_requested_nodes):\n    \"\"\"Check if action is valid.\n    Combines checks for:\n    - sufficient node capacities\n    - unique nodes assigned\n    - minimum two nodes assigned\n    - all requested nodes assigned\n    - correct topology pattern\n    - no spectrum reuse\n\n    Args:\n        state: current state\n        remaining_actions: remaining actions\n        total_requested_nodes: total requested nodes\n\n    Returns:\n        bool: True if check failed, False if check passed\n    \"\"\"\n    checks = jnp.stack((\n        check_node_capacities(state.node_capacity_array),\n        check_unique_nodes(state.node_departure_array),\n        # TODO (VONE) - Remove two nodes check if impairs performance\n        #  (check_all_nodes_assigned is sufficient but fails after last action of request instead of earlier)\n        check_min_two_nodes_assigned(state.node_departure_array),\n        jax.lax.cond(\n            jnp.equal(remaining_actions, jnp.array(1)),\n            lambda x: check_all_nodes_assigned(*x),\n            lambda x: jnp.array(False),\n            (state.node_departure_array, total_requested_nodes)\n        ),\n        jax.lax.cond(\n            jnp.equal(remaining_actions, jnp.array(1)),\n            lambda x: check_topology(*x),\n            lambda x: jnp.array(False),\n            (state.action_history, state.request_array[1])\n        ),\n        check_no_spectrum_reuse(state.link_slot_array),\n    ))\n    #jax.debug.print(\"Checks: {}\", checks, ordered=True)\n    return jnp.any(checks)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.convert_node_probs_to_traffic_matrix","title":"<code>convert_node_probs_to_traffic_matrix(node_probs)</code>","text":"<p>Convert list of node probabilities to symmetric traffic matrix.</p> <p>Parameters:</p> Name Type Description Default <code>node_probs</code> <code>list</code> <p>node probabilities</p> required <p>Returns:</p> Name Type Description <code>traffic_matrix</code> <code>Array</code> <p>traffic matrix</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def convert_node_probs_to_traffic_matrix(node_probs: list) -&gt; chex.Array:\n    \"\"\"Convert list of node probabilities to symmetric traffic matrix.\n\n    Args:\n        node_probs: node probabilities\n\n    Returns:\n        traffic_matrix: traffic matrix\n    \"\"\"\n    matrix = jnp.outer(node_probs, node_probs).astype(SMALL_FLOAT_DTYPE)\n    # Set lead diagonal to zero\n    matrix = jnp.where(jnp.eye(matrix.shape[0]) == 1, 0, matrix)\n    matrix = normalise_traffic_matrix(matrix)\n    return matrix\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.create_run_name","title":"<code>create_run_name(config)</code>","text":"<p>Create name for run based on config flags</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def create_run_name(config: Union[box.Box, dict]) -&gt; str:\n    \"\"\"Create name for run based on config flags\"\"\"\n    env_type = config[\"env_type\"]\n    topology = config[\"topology_name\"]\n    slots = config[\"link_resources\"]\n    gnn = \"_GNN\" if config[\"USE_GNN\"] else \"\"\n    incremental = \"_INC\" if config[\"incremental_loading\"] else \"\"\n    run_name = f\"{env_type}_{topology}_{slots}{gnn}{incremental}\".upper()\n    if config[\"EVAL_HEURISTIC\"]:\n        run_name += f\"_{config['path_heuristic']}\"\n        if env_type.lower() == \"vone\":\n            run_name += f\"_{config['node_heuristic']}\"\n    elif config[\"EVAL_MODEL\"]:\n        run_name += f\"_EVAL\"\n    return run_name\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.decrement_action_counter","title":"<code>decrement_action_counter(state)</code>","text":"<p>Decrement action counter in-place. Used in VONE environments.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def decrement_action_counter(state):\n    \"\"\"Decrement action counter in-place. Used in VONE environments.\"\"\"\n    state.action_counter.at[-1].add(-1)\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.ff_ksp","title":"<code>ff_ksp(state, params)</code>","text":"<p>Get the first available slot from all paths Method: Go through action mask and find the first available slot on all paths</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef ff_ksp(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the first available slot from all paths\n    Method: Go through action mask and find the first available slot on all paths\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    first_slots = first_fit(state, params)\n    # Chosen path is the one with the lowest index of first available slot\n    path_index = jnp.argmin(first_slots)\n    slot_index = first_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.finalise_action_rsa","title":"<code>finalise_action_rsa(state, params)</code>","text":"<p>Turn departure times positive.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef finalise_action_rsa(state: EnvState, params: Optional[EnvParams]):\n    \"\"\"Turn departure times positive.\n\n    Args:\n        state: current state\n\n    Returns:\n        state: updated state\n    \"\"\"\n    _, requested_datarate = read_rsa_request(state.request_array)\n    state = state.replace(\n        link_slot_departure_array=make_positive(state.link_slot_departure_array),\n        accepted_services=state.accepted_services + 1,\n        accepted_bitrate=state.accepted_bitrate + requested_datarate[0],\n        total_bitrate=state.total_bitrate + requested_datarate[0]\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.finalise_action_rwalr","title":"<code>finalise_action_rwalr(state, params)</code>","text":"<p>Turn departure times positive.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef finalise_action_rwalr(state: EnvState, params: Optional[EnvParams]):\n    \"\"\"Turn departure times positive.\n\n    Args:\n        state: current state\n\n    Returns:\n        state: updated state\n    \"\"\"\n    _, requested_datarate = read_rsa_request(state.request_array)\n    state = state.replace(\n        link_slot_departure_array=make_positive(state.link_slot_departure_array),\n        accepted_services=state.accepted_services + 1,\n        accepted_bitrate=state.accepted_bitrate + requested_datarate[0],\n        total_bitrate=state.total_bitrate + requested_datarate[0]\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.finalise_vone_action","title":"<code>finalise_vone_action(state)</code>","text":"<p>Turn departure times positive.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>current state</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef finalise_vone_action(state):\n    \"\"\"Turn departure times positive.\n\n    Args:\n        state: current state\n\n    Returns:\n        state: updated state\n    \"\"\"\n    state = state.replace(\n        node_departure_array=make_positive(state.node_departure_array),\n        link_slot_departure_array=make_positive(state.link_slot_departure_array),\n        accepted_services=state.accepted_services + 1,\n        accepted_bitrate=state.accepted_bitrate  # TODO - get sum of bitrates for requested links\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.first_fit","title":"<code>first_fit(state, params)</code>","text":"<p>First-Fit Spectrum Allocation. Returns the first fit slot for each path.</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>def first_fit(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"First-Fit Spectrum Allocation. Returns the first fit slot for each path.\"\"\"\n    mask = get_action_mask(state, params)\n    # Add a column of ones to the mask to make sure that occupied paths have non-zero index in \"first_slots\"\n    mask = jnp.concatenate((mask, jnp.full((mask.shape[0], 1), 1)), axis=1)\n    # Get index of first available slots for each path\n    first_slots = jnp.argmax(mask, axis=1)\n    return first_slots\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.format_vone_slot_request","title":"<code>format_vone_slot_request(state, action)</code>","text":"<p>Format slot request for VONE action into format (source-node, slot, destination-node).</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <code>action</code> <code>Array</code> <p>action to format</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: formatted request</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def format_vone_slot_request(state: EnvState, action: chex.Array) -&gt; chex.Array:\n    \"\"\"Format slot request for VONE action into format (source-node, slot, destination-node).\n\n    Args:\n        state: current state\n        action: action to format\n\n    Returns:\n        chex.Array: formatted request\n    \"\"\"\n    remaining_actions = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.action_counter, 2, 1))\n    full_request = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.request_array, 0, 1))\n    unformatted_request = jax.lax.dynamic_slice_in_dim(full_request, (remaining_actions - 1) * 2, 3)\n    node_s = jax.lax.dynamic_slice_in_dim(action, 0, 1)\n    requested_slots = jax.lax.dynamic_slice_in_dim(unformatted_request, 1, 1)\n    node_d = jax.lax.dynamic_slice_in_dim(action, 2, 1)\n    formatted_request = jnp.concatenate((node_s, requested_slots, node_d))\n    return formatted_request\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.generate_arrival_holding_times","title":"<code>generate_arrival_holding_times(key, params)</code>","text":"<p>Generate arrival and holding times based on Poisson distributed events. To understand how sampling from e^-x can be transformed to sample from lambdae^-(x/lambda) see: https://en.wikipedia.org/wiki/Inverse_transform_sampling#Examples Basically, inverse transform sampling is used to sample from a distribution with CDF F(x). The CDF of the exponential distribution (lambdae^-{lambdax}) is F(x) = 1 - e^-{lambdax}. Therefore, the inverse CDF is x = -ln(1-u)/lambda, where u is sample from uniform distribution. Therefore, we need to divide jax.random.exponential() by lambda in order to scale the standard exponential CDF. Experimental histograms of this method compared to random.expovariate() in Python's random library show that the two methods are equivalent. Also see: https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html https://jax.readthedocs.io/en/latest/_autosummary/jax.random.exponential.html</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>PRNG key</p> required <code>params</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>arrival_time</code> <p>Arrival time</p> <code>holding_time</code> <p>Holding time</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef generate_arrival_holding_times(key, params):\n    \"\"\"\n    Generate arrival and holding times based on Poisson distributed events.\n    To understand how sampling from e^-x can be transformed to sample from lambda*e^-(x/lambda) see:\n    https://en.wikipedia.org/wiki/Inverse_transform_sampling#Examples\n    Basically, inverse transform sampling is used to sample from a distribution with CDF F(x).\n    The CDF of the exponential distribution (lambda*e^-{lambda*x}) is F(x) = 1 - e^-{lambda*x}.\n    Therefore, the inverse CDF is x = -ln(1-u)/lambda, where u is sample from uniform distribution.\n    Therefore, we need to divide jax.random.exponential() by lambda in order to scale the standard exponential CDF.\n    Experimental histograms of this method compared to random.expovariate() in Python's random library show that\n    the two methods are equivalent.\n    Also see: https://numpy.org/doc/stable/reference/random/generated/numpy.random.exponential.html\n    https://jax.readthedocs.io/en/latest/_autosummary/jax.random.exponential.html\n\n    Args:\n        key: PRNG key\n        params: Environment parameters\n\n    Returns:\n        arrival_time: Arrival time\n        holding_time: Holding time\n    \"\"\"\n    key_arrival, key_holding = jax.random.split(key, 2)\n    arrival_time = jax.random.exponential(key_arrival, shape=(1,), dtype=SMALL_FLOAT_DTYPE) \\\n                   / params.arrival_rate  # Divide because it is rate (lambda)\n    if params.truncate_holding_time:\n        # For DeepRMSA, need to generate holding times that are less than 2*mean_service_holding_time\n        key_holding = jax.random.split(key, 5)\n        holding_times = jax.vmap(lambda x: jax.random.exponential(x, shape=(1,)) \\\n                                * params.mean_service_holding_time)(key_holding)\n        holding_times = jnp.where(holding_times &lt; 2*params.mean_service_holding_time, holding_times, zero)\n        # Get first non-zero value in holding_times\n        non_zero_index = jnp.nonzero(holding_times, size=1)[0][0]\n        holding_time = jax.lax.dynamic_slice(jnp.squeeze(holding_times), (non_zero_index,), (1,))\n    else:\n        holding_time = jax.random.exponential(key_holding, shape=(1,), dtype=SMALL_FLOAT_DTYPE) \\\n                       * params.mean_service_holding_time  # Multiply because it is mean (1/lambda)\n    return arrival_time, holding_time\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.generate_vone_request","title":"<code>generate_vone_request(key, state, params)</code>","text":"<p>Generate a new request for the VONE environment. The request has two rows. The first row shows the node and slot values. The first three elements of the second row show the number of unique nodes, the total number of steps, and the remaining steps. These first three elements comprise the action counter. The remaining elements of the second row show the virtual topology pattern, i.e. the connectivity of the virtual topology.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef generate_vone_request(key: chex.PRNGKey, state: EnvState, params: EnvParams):\n    \"\"\"Generate a new request for the VONE environment.\n    The request has two rows. The first row shows the node and slot values.\n    The first three elements of the second row show the number of unique nodes, the total number of steps, and the remaining steps.\n    These first three elements comprise the action counter.\n    The remaining elements of the second row show the virtual topology pattern, i.e. the connectivity of the virtual topology.\n    \"\"\"\n    shape = params.max_edges*2+1  # shape of request array\n    key_topology, key_node, key_slot, key_times = jax.random.split(key, 4)\n    # Randomly select topology, node resources, slot resources\n    pattern = jax.random.choice(key_topology, state.virtual_topology_patterns)\n    action_counter = jax.lax.dynamic_slice(pattern, (0,), (3,))\n    topology_pattern = jax.lax.dynamic_slice(pattern, (3,), (pattern.shape[0]-3,))\n    selected_node_values = jax.random.choice(key_node, state.values_nodes, shape=(shape,))\n    selected_bw_values = jax.random.choice(key_slot, params.values_bw.val, shape=(shape,))\n    # Create a mask for odd and even indices\n    mask = jnp.tile(jnp.array([0, 1]), (shape+1) // 2)[:shape]\n    # Vectorized conditional replacement using mask\n    first_row = jnp.where(mask, selected_bw_values, selected_node_values)\n    # Make sure node request values are consistent for same virtual nodes\n    first_row = jax.lax.fori_loop(\n        2,  # Lowest node index in virtual topology requests is 2\n        shape,  # Highest possible node index in virtual topology requests is shape-1\n        lambda i, x: jnp.where(topology_pattern == i, selected_node_values[i], x),\n        first_row\n    )\n    # Mask out unused part of request array\n    first_row = jnp.where(topology_pattern == 0, 0, first_row)\n    # Set times\n    arrival_time, holding_time = generate_arrival_holding_times(key, params)\n    state = state.replace(\n        holding_time=holding_time,\n        current_time=state.current_time + arrival_time,\n        action_counter=action_counter,\n        request_array=jnp.vstack((first_row, topology_pattern)),\n        action_history=init_action_history(params),\n        total_requests=state.total_requests + 1\n    )\n    state = remove_expired_node_requests(state, params) if not params.incremental_loading else state\n    state = remove_expired_services_rsa(state, params) if not params.incremental_loading else state\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_action_mask","title":"<code>get_action_mask(state, params)</code>","text":"<p>N.B. The mask must already be present in the state!</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>def get_action_mask(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"N.B. The mask must already be present in the state!\"\"\"\n    mask = state.link_slot_mask if params.__class__.__name__ != \"DeepRMSAEnvParams\" else (\n        mask_slots(state, params, state.request_array).link_slot_mask\n    )\n    mask = jnp.reshape(mask, (params.k_paths, -1))\n    return mask\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_best_modulation_format","title":"<code>get_best_modulation_format(state, path, initial_slot_index, launch_power, params)</code>","text":"<p>Get best modulation format for lightpath. \"Best\" is the highest order that has SNR requirements below available. Try each modulation format, calculate SNR for each, then return the highest order possible. Args:     state (EnvState): Environment state     path (chex.Array): Path array     initial_slot_index (int): Initial slot index     params (EnvParams): Environment parameters Returns:     jnp.array: Acceptable modulation format indices</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(3,))\ndef get_best_modulation_format(state: EnvState, path: chex.Array, initial_slot_index: int, launch_power: chex.Array, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get best modulation format for lightpath. \"Best\" is the highest order that has SNR requirements below available.\n    Try each modulation format, calculate SNR for each, then return the highest order possible.\n    Args:\n        state (EnvState): Environment state\n        path (chex.Array): Path array\n        initial_slot_index (int): Initial slot index\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Acceptable modulation format indices\n    \"\"\"\n    _, requested_datarate = read_rsa_request(state.request_array)\n    mod_format_count = params.modulations_array.val.shape[0]\n    acceptable_mod_format_indices = jnp.full((mod_format_count,), -2)\n\n    def acceptable_modulation_format(i, acceptable_format_indices):\n        req_snr = params.modulations_array.val[i][2] + params.snr_margin\n        se = params.modulations_array.val[i][1]\n        req_slots = required_slots(requested_datarate, se, params.slot_size, params.guardband)\n        # TODO - need to check we don't overwrite values in already occupied slots\n        # Possible approaches:\n        # Check slot occupancy? Probably would need to iterate through for num_slots, but that's an issue\n        # What about we allocate and then fix up later, e.g. could it be possible to just add the modulation format on top without\n        # check sum of path links prior to assigning?\n        #\n        new_state = state.replace(\n            channel_power_array=vmap_set_path_links(\n                state.channel_power_array, path, initial_slot_index, req_slots, launch_power),\n            channel_centre_bw_array=vmap_set_path_links(\n                state.channel_centre_bw_array, path, initial_slot_index, req_slots, params.slot_size)\n        )\n        snr_value = get_minimum_snr_of_channels_on_path(new_state, path, initial_slot_index, req_slots, params)\n        # jax.debug.print(\"snr_value {}\", snr_value, ordered=True)\n        # jax.debug.print(\"req_snr {}\", req_snr, ordered=True)\n        acceptable_format_index = jnp.where(snr_value &gt;= req_snr, i, -1).reshape((1,))\n        acceptable_format_indices = jax.lax.dynamic_update_slice(acceptable_format_indices, acceptable_format_index, (i,))\n        # jax.debug.print(\"acceptable_format_indices {}\", acceptable_format_indices, ordered=True)\n        return acceptable_format_indices\n\n    acceptable_mod_format_indices = jax.lax.fori_loop(\n        0,\n        mod_format_count,\n        acceptable_modulation_format,\n        acceptable_mod_format_indices\n    )\n    return acceptable_mod_format_indices\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_best_modulation_format_simple","title":"<code>get_best_modulation_format_simple(state, path, initial_slot_index, params)</code>","text":"<p>Get modulation format for lightpath. Assume worst case (least Gaussian) modulation format when calculating SNR. Args:     state (EnvState): Environment state     path (chex.Array): Path array     initial_slot_index (int): Initial slot index     params (EnvParams): Environment parameters Returns:     jnp.array: Acceptable modulation format indices</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(3,))\ndef get_best_modulation_format_simple(\n        state: RSAGNModelEnvState, path: chex.Array, initial_slot_index: int, params: RSAGNModelEnvParams\n) -&gt; chex.Array:\n    \"\"\"Get modulation format for lightpath.\n    Assume worst case (least Gaussian) modulation format when calculating SNR.\n    Args:\n        state (EnvState): Environment state\n        path (chex.Array): Path array\n        initial_slot_index (int): Initial slot index\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Acceptable modulation format indices\n    \"\"\"\n    link_snr_array = get_snr_link_array(state, params)\n    snr_value = get_snr_for_path(path, link_snr_array, params)[initial_slot_index] - params.snr_margin  # Margin\n    mod_format_count = params.modulations_array.val.shape[0]\n    acceptable_mod_format_indices = jnp.arange(mod_format_count)\n    req_snr = params.modulations_array.val[:, 2] + params.snr_margin\n    acceptable_mod_format_indices = jnp.where(snr_value &gt;= req_snr,\n                                              acceptable_mod_format_indices,\n                                              jnp.full((mod_format_count,), -2))\n    return acceptable_mod_format_indices\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_centre_frequency","title":"<code>get_centre_frequency(initial_slot_index, num_slots, params)</code>","text":"<p>Get centre frequency for new lightpath</p> <p>Parameters:</p> Name Type Description Default <code>initial_slot_index</code> <code>Array</code> <p>Centre frequency of first slot</p> required <code>num_slots</code> <code>float</code> <p>Number of slots</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Centre frequency for new lightpath</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef get_centre_frequency(initial_slot_index: int, num_slots: int, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Get centre frequency for new lightpath\n\n    Args:\n        initial_slot_index (chex.Array): Centre frequency of first slot\n        num_slots (float): Number of slots\n        params (RSAGNModelEnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Centre frequency for new lightpath\n    \"\"\"\n    slot_centres = (jnp.arange(params.link_resources) - (params.link_resources - 1) / 2) * params.slot_size\n    return slot_centres[initial_slot_index] + ((params.slot_size * (num_slots - 1)) / 2)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_edge_disjoint_paths","title":"<code>get_edge_disjoint_paths(graph)</code>","text":"<p>Get edge disjoint paths between all nodes in graph.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>graph</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>edge disjoint paths (path is list of edges)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def get_edge_disjoint_paths(graph: nx.Graph) -&gt; dict:\n    \"\"\"Get edge disjoint paths between all nodes in graph.\n\n    Args:\n        graph: graph\n\n    Returns:\n        dict: edge disjoint paths (path is list of edges)\n    \"\"\"\n    result = {n: {} for n in graph}\n    for n1, n2 in itertools.combinations(graph, 2):\n        # Sort by number of links in path\n        # TODO - sort by path length\n        result[n1][n2] = sorted(list(nx.edge_disjoint_paths(graph, n1, n2)), key=len)\n        result[n2][n1] = sorted(list(nx.edge_disjoint_paths(graph, n2, n1)), key=len)\n    return result\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_launch_power","title":"<code>get_launch_power(state, path_action, power_action, params)</code>","text":"<p>Get launch power for new lightpath. N.B. launch power is specified in dBm but is converted to linear units when stored in channel_power_array. This func returns linear units (mW). Path action is used to determine the launch power in the case of tabular launch power type. Power action is used to determine the launch power in the case of RL launch power type. During masking, power action is set as state.launch_power_array[0], which is set by the RL agent. Args:     state (EnvState): Environment state     path_action (chex.Array): Action specifying path index (0 to k_paths-1)     power_action (chex.Array): Action specifying launch power in dBm     params (EnvParams): Environment parameters Returns:     chex.Array: Launch power for new lightpath</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_launch_power(state: EnvState, path_action: chex.Array, power_action: chex.Array, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get launch power for new lightpath. N.B. launch power is specified in dBm but is converted to linear units\n    when stored in channel_power_array. This func returns linear units (mW).\n    Path action is used to determine the launch power in the case of tabular launch power type.\n    Power action is used to determine the launch power in the case of RL launch power type. During masking,\n    power action is set as state.launch_power_array[0], which is set by the RL agent.\n    Args:\n        state (EnvState): Environment state\n        path_action (chex.Array): Action specifying path index (0 to k_paths-1)\n        power_action (chex.Array): Action specifying launch power in dBm\n        params (EnvParams): Environment parameters\n    Returns:\n        chex.Array: Launch power for new lightpath\n    \"\"\"\n    k_path_index, _ = process_path_action(state, params, path_action)\n    if params.launch_power_type == 1:  # Fixed\n        return state.launch_power_array[0]\n    elif params.launch_power_type == 2:  # Tabular (one row per path)\n        nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n        source, dest = nodes_sd\n        i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n        return state.launch_power_array[i+k_path_index]\n    elif params.launch_power_type == 3:  # RL\n        return power_action\n    elif params.launch_power_type == 4:  # Scaled\n        nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n        source, dest = nodes_sd\n        i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n        # Get path length\n        link_length_array = jnp.sum(params.link_length_array.val, axis=1, promote_integers=False)\n        path_length = jnp.sum(link_length_array[i+k_path_index], promote_integers=False)\n        path_link_array = jnp.unpackbits(params.path_link_array.val)[:, params.num_links] if params.pack_path_bits \\\n            else params.path_link_array.val\n        maximum_path_length = jnp.max(jnp.dot(path_link_array, params.link_length_array.val))\n        return state.launch_power_array[0] * (path_length / maximum_path_length)\n    else:\n        raise ValueError(\"Invalid launch power type. Check params.launch_power_type\")\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_lightpath_snr","title":"<code>get_lightpath_snr(state, params)</code>","text":"<p>Get SNR for each link on path. N.B. that in most cases it is more efficient to calculate the SNR for every possible path, rather than a slot-by-slot basis. But in some cases slot-by-slot is better i.e. when kN(N-1)/2 &gt; LS Args:     state (RSAGNModelEnvState): Environment state     params (RSAGNModelEnvParams): Environment parameters</p> <p>Returns:</p> Type Description <code>Array</code> <p>chex.array: SNR for each link on path</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def get_lightpath_snr(state: RSAGNModelEnvParams, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Get SNR for each link on path.\n    N.B. that in most cases it is more efficient to calculate the SNR for every possible path, rather than a slot-by-slot basis.\n    But in some cases slot-by-slot is better i.e. when k*N(N-1)/2 &gt; L*S\n    Args:\n        state (RSAGNModelEnvState): Environment state\n        params (RSAGNModelEnvParams): Environment parameters\n\n    Returns:\n        chex.array: SNR for each link on path\n    \"\"\"\n    # Get the SNR for the channel that the path occupies\n    path_snr_array = jax.vmap(get_snr_for_path, in_axes=(0, None, None))(params.path_link_array.val, state.link_snr_array, params)\n    # Where value in path_index_array matches index of path_snr_array, substitute in SNR value\n    slot_indices = jnp.arange(params.link_resources)\n    lightpath_snr_array = jax.vmap(jax.vmap(lambda x, si: path_snr_array[x][si], in_axes=(0, 0)), in_axes=(0, None))(state.path_index_array, slot_indices)\n    return lightpath_snr_array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_link_weights","title":"<code>get_link_weights(state, params)</code>","text":"<p>Get link weights based on occupancy for use in congestion-aware routing heuristics.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <p>chex.Array: Link weights</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>def get_link_weights(state: EnvState, params: EnvParams):\n    \"\"\"Get link weights based on occupancy for use in congestion-aware routing heuristics.\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Link weights\n    \"\"\"\n    if params.__class__.__name__ != \"RWALightpathReuseEnvParams\":\n        link_occupancy = jnp.count_nonzero(state.link_slot_array, axis=1)\n    else:\n        initial_path_capacity = init_path_capacity_array(\n            params.link_length_array.val, params.path_link_array.val, scale_factor=1.0\n        )\n        initial_path_capacity = jnp.squeeze(jax.vmap(lambda x: initial_path_capacity[x])(state.path_index_array))\n        utilisation = jnp.where(initial_path_capacity - state.link_capacity_array &lt; 0, 0,\n                                initial_path_capacity - state.link_capacity_array) / initial_path_capacity\n        link_occupancy = jnp.sum(utilisation, axis=1)\n    link_weights = jnp.multiply(params.link_length_array.val.T, (1 / (1 - link_occupancy / (params.link_resources + 1))))[0]\n    return link_weights\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_minimum_snr_of_channels_on_path","title":"<code>get_minimum_snr_of_channels_on_path(state, path, slot_index, req_slots, params)</code>","text":"<p>Get the minimum value of the SNR on newly assigned channels. N.B. this requires the link_snr_array to have already been calculated and present in state.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef get_minimum_snr_of_channels_on_path(\n        state: RSAGNModelEnvState, path: chex.Array, slot_index: chex.Array, req_slots: int, params: RSAGNModelEnvParams\n) -&gt; chex.Array:\n    \"\"\"Get the minimum value of the SNR on newly assigned channels.\n    N.B. this requires the link_snr_array to have already been calculated and present in state.\"\"\"\n    snr_value_all_channels = get_snr_for_path(path, state.link_snr_array, params)\n    min_snr_value_sub_channels = jnp.min(\n        jnp.concatenate([\n            snr_value_all_channels[slot_index].reshape((1,)),\n            snr_value_all_channels[slot_index + req_slots - 1].reshape((1,))\n        ], axis=0)\n    )\n    return min_snr_value_sub_channels\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_num_spectral_features","title":"<code>get_num_spectral_features(n_nodes)</code>","text":"<p>Heuristic for number of spectral features based on graph size.</p> <p>Parameters:</p> Name Type Description Default <code>n_nodes</code> <code>int</code> <p>Number of nodes in the graph</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of spectral features to use, clamped between 3 and 15.</p> <code>int</code> <p>Follows log2(n_nodes) scaling as reasonable default.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_num_spectral_features(n_nodes: int) -&gt; int:\n    \"\"\"Heuristic for number of spectral features based on graph size.\n\n    Args:\n        n_nodes: Number of nodes in the graph\n\n    Returns:\n        Number of spectral features to use, clamped between 3 and 15.\n        Follows log2(n_nodes) scaling as reasonable default.\n    \"\"\"\n    return jnp.minimum(jnp.maximum(3, jnp.floor(jnp.log2(n_nodes))), 15).astype(int)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_path_from_path_index_array","title":"<code>get_path_from_path_index_array(path_index_array, path_link_array)</code>","text":"<p>Get path from path index array. Args:     path_index_array (chex.Array): Path index array     path_link_array (chex.Array): Path link array</p> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.array: path index values replaced with binary path-link arrays</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_path_from_path_index_array(path_index_array: chex.Array, path_link_array: chex.Array) -&gt; chex.Array:\n    \"\"\"Get path from path index array.\n    Args:\n        path_index_array (chex.Array): Path index array\n        path_link_array (chex.Array): Path link array\n\n    Returns:\n        jnp.array: path index values replaced with binary path-link arrays\n    \"\"\"\n    # TODO - support unpacking bits (if this function ends up being used)\n    def get_index_from_link(link):\n        return jax.vmap(lambda x: path_link_array[x], in_axes=(0,))(link)\n\n    return jax.vmap(get_index_from_link, in_axes=(0,))(path_index_array)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_path_index_array","title":"<code>get_path_index_array(params, nodes)</code>","text":"<p>Indices of paths between source and destination from path array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_path_index_array(params, nodes):\n    \"\"\"Indices of paths between source and destination from path array\"\"\"\n    # get source and destination nodes in order (for accurate indexing of path-link array)\n    source, dest = nodes.astype(LARGE_INT_DTYPE)\n    i = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n    index_array = jax.lax.dynamic_slice(jnp.arange(0, params.path_link_array.shape[0], dtype=LARGE_INT_DTYPE), (i,), (params.k_paths,))\n    return index_array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_path_indices","title":"<code>get_path_indices(s, d, k, N, directed=False)</code>","text":"<p>Get path indices for a given source, destination and number of paths. If source &gt; destination and the graph is directed (two fibres per link, one in each direction) then an offset is added to the index to get the path in the other direction (the offset is the total number source-dest pairs).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>int</code> <p>Source node index</p> required <code>d</code> <code>int</code> <p>Destination node index</p> required <code>k</code> <code>int</code> <p>Number of paths</p> required <code>N</code> <code>int</code> <p>Number of nodes</p> required <code>directed</code> <code>bool</code> <p>Whether graph is directed. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>jnp.array: Start index on path-link array for candidate paths</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2, 3, 4))\ndef get_path_indices(s: int, d: int, k: int, N: int, directed: bool = False) -&gt; chex.Array:\n    \"\"\"Get path indices for a given source, destination and number of paths.\n    If source &gt; destination and the graph is directed (two fibres per link, one in each direction) then an offset is\n    added to the index to get the path in the other direction (the offset is the total number source-dest pairs).\n\n    Args:\n        s (int): Source node index\n        d (int): Destination node index\n        k (int): Number of paths\n        N (int): Number of nodes\n        directed (bool, optional): Whether graph is directed. Defaults to False.\n\n    Returns:\n        jnp.array: Start index on path-link array for candidate paths\n    \"\"\"\n    node_indices = jnp.arange(N, dtype=LARGE_INT_DTYPE)\n    indices_to_s = jnp.where(node_indices &lt; s, node_indices, jnp.array(0, dtype=LARGE_INT_DTYPE))\n    indices_to_d = jnp.where(node_indices &lt; d, node_indices, jnp.array(0, dtype=LARGE_INT_DTYPE))\n    # If two fibres per link, add offset to index to get fibre in other direction if source &gt; destination\n    directed_offset = directed * (s &gt; d) * N * (N - 1) * k / 2\n    # The following equation is based on the combinations formula\n    forward = ((N * s + d - jnp.sum(indices_to_s, promote_integers=False) - 2 * s - 1) * k)\n    backward = ((N * d + s - jnp.sum(indices_to_d, promote_integers=False) - 2 * d - 1) * k)\n    return forward * (s &lt; d) + backward * (s &gt; d) + directed_offset.astype(LARGE_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_path_slots","title":"<code>get_path_slots(link_slot_array, params, nodes_sd, i, agg_func='max')</code>","text":"<p>Get slots on each constitutent link of path from link_slot_array (L x S), then aggregate to get (S x 1) representation of slots on path.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>link-slot array</p> required <code>params</code> <code>EnvParams</code> <p>environment parameters</p> required <code>nodes_sd</code> <code>Array</code> <p>source-destination nodes</p> required <code>i</code> <code>int</code> <p>path index</p> required <code>agg_func</code> <code>str</code> <p>aggregation function (max or sum). If max, result will be available slots on path. If sum, result will contain information on edge features.</p> <code>'max'</code> <p>Returns:</p> Name Type Description <code>slots</code> <code>Array</code> <p>slots on path</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 4))\ndef get_path_slots(link_slot_array: chex.Array, params: EnvParams, nodes_sd: chex.Array, i: int, agg_func: str = \"max\") -&gt; chex.Array:\n    \"\"\"Get slots on each constitutent link of path from link_slot_array (L x S),\n    then aggregate to get (S x 1) representation of slots on path.\n\n    Args:\n        link_slot_array: link-slot array\n        params: environment parameters\n        nodes_sd: source-destination nodes\n        i: path index\n        agg_func: aggregation function (max or sum).\n            If max, result will be available slots on path.\n            If sum, result will contain information on edge features.\n\n    Returns:\n        slots: slots on path\n    \"\"\"\n    path = get_paths(params, nodes_sd)[i]\n    path = path.reshape((params.num_links, 1))\n    # Get links and collapse to single dimension\n    num_slots = params.link_resources if agg_func == \"max\" else math.ceil(params.link_resources/params.aggregate_slots)\n    slots = jnp.where(path, link_slot_array, jnp.zeros(num_slots, dtype=LARGE_FLOAT_DTYPE))\n    # Make any -1s positive then get max for each slot across links\n    if agg_func == \"max\":\n        # Use this for getting slots from link_slot_array\n        slots = jnp.max(jnp.absolute(slots), axis=0)\n    elif agg_func == \"sum\":\n        # TODO - consider using an RNN (or S5) to aggregate edge features\n        # Use this (or alternative) for aggregating edge features from GNN\n        slots = jnp.sum(slots, axis=0, promote_integers=False)\n    elif agg_func == \"mean\":\n        # Use this for getting mean value in slot index along path\n        slots = jnp.mean(slots, axis=0)\n    else:\n        raise ValueError(\"agg_func must be 'max' or 'sum' or 'mean'\")\n    return slots\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_paths","title":"<code>get_paths(params, nodes)</code>","text":"<p>Get k paths between source and destination</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_paths(params, nodes):\n    \"\"\"Get k paths between source and destination\"\"\"\n    index_array = get_path_index_array(params, nodes)\n    paths = jnp.take(params.path_link_array.val, index_array, axis=0)\n    if params.pack_path_bits:  # Unpack the bit-packed paths\n        paths = jnp.unpackbits(paths, axis=1)[:, :params.num_links]\n    return paths\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_paths_obs_gn_model","title":"<code>get_paths_obs_gn_model(state, params)</code>","text":"<p>Get observation space for launch power optimization (with numerical stability).</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_paths_obs_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    # TODO - make this just show the stats from just one path at a time\n    \"\"\"Get observation space for launch power optimization (with numerical stability).\"\"\"\n    request_array = state.request_array.reshape((-1,))\n    path_stats = calculate_path_stats(state, params, request_array)\n    # Remove first 3 items of path stats for each path\n    path_stats = path_stats[:, 3:]\n    link_length_array = jnp.sum(params.link_length_array.val, axis=1, promote_integers=False)\n    lightpath_snr_array = get_lightpath_snr(state, params)\n    nodes_sd, requested_datarate = read_rsa_request(request_array)\n    source, dest = nodes_sd\n\n    def calculate_gn_path_stats(k_path_index, init_val):\n        # Get path index\n        path_index = get_path_indices(source, dest, params.k_paths, params.num_nodes,\n                                      directed=params.directed_graph) + k_path_index\n        path_link_array = jnp.unpackbits(params.path_link_array.val, axis=1)[:, :params.num_links] if params.pack_path_bits \\\n            else params.path_link_array.val\n        path = path_link_array[path_index]\n        path_length = jnp.dot(path, link_length_array)\n        max_path_length = jnp.max(jnp.dot(path_link_array, link_length_array))\n        path_length_norm = path_length / max_path_length\n        max_path_length_hops = jnp.max(jnp.sum(path_link_array, axis=1, promote_integers=False))\n        path_length_hops_norm = jnp.sum(path, promote_integers=False).astype(LARGE_FLOAT_DTYPE) / max_path_length_hops\n        # Connections on path\n        num_connections = jnp.where(path == 1, jnp.where(state.channel_power_array &gt; 0, one, zero).sum(axis=1), zero).sum()\n        num_connections_norm = num_connections / jnp.array(params.link_resources, dtype=LARGE_FLOAT_DTYPE)\n        # Mean power of connections on path\n        # make path with row length equal to link_resource (+1 to avoid zero division)\n        mean_power_norm = (jnp.where(path == one, state.channel_power_array.sum(axis=1), zero).sum() /\n                           (jnp.where(num_connections &gt; zero, num_connections, one) * params.max_power))\n        # Mean SNR of connections on the path links\n        max_snr = jnp.array(50, dtype=LARGE_FLOAT_DTYPE)  # Nominal value for max GSNR in dB\n        mean_snr_norm = (jnp.where(path == one, lightpath_snr_array.sum(axis=1), zero).sum(promote_integers=False) /\n                         (jnp.where(num_connections &gt; zero, num_connections, one) * max_snr))\n        return jax.lax.dynamic_update_slice(\n            init_val,\n            jnp.array([[\n                path_length,\n                path_length_hops_norm,\n                num_connections_norm,\n                mean_power_norm,\n                mean_snr_norm\n            ]]),\n            (k_path_index, 0),\n        )\n\n    gn_path_stats = jnp.zeros((params.k_paths, 5), dtype=LARGE_FLOAT_DTYPE)\n    gn_path_stats = jax.lax.fori_loop(\n        0, params.k_paths, calculate_gn_path_stats, gn_path_stats\n    )\n    all_stats = jnp.concatenate([path_stats, gn_path_stats], axis=1)\n    return jnp.concatenate(\n        (\n            jnp.array([source]),\n            requested_datarate / 100.,\n            jnp.array([dest]),\n            jnp.reshape(state.holding_time, (-1,)),\n            jnp.reshape(all_stats, (-1,)),\n        ),\n        axis=0,\n    )\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_paths_se","title":"<code>get_paths_se(params, nodes)</code>","text":"<p>Get max. spectral efficiency of modulation format on k paths between source and destination</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_paths_se(params, nodes):\n    \"\"\"Get max. spectral efficiency of modulation format on k paths between source and destination\"\"\"\n    # get source and destination nodes in order (for accurate indexing of path-link array)\n    index_array = get_path_index_array(params, nodes)\n    return jnp.take(params.path_se_array.val, index_array, axis=0)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_required_snr_se_kurtosis_array","title":"<code>get_required_snr_se_kurtosis_array(modulation_format_index_array, col_index, params)</code>","text":"<p>Convert modulation format index to required SNR or spectral efficiency. Modulation format index array contains the index of the modulation format used by the channel. The modulation index references a row in the modulations array, which contains SNR and SE values.</p> <p>Parameters:</p> Name Type Description Default <code>modulation_format_index_array</code> <code>Array</code> <p>Modulation format index array</p> required <code>col_index</code> <code>int</code> <p>Column index for required SNR or spectral efficiency</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>jnp.array: Required SNR for each channel (min. SNR for empty channel (mod. index 0))</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2,))\ndef get_required_snr_se_kurtosis_array(modulation_format_index_array: chex.Array, col_index: int, params: RSAGNModelEnvParams) -&gt; chex.Array:\n    \"\"\"Convert modulation format index to required SNR or spectral efficiency.\n    Modulation format index array contains the index of the modulation format used by the channel.\n    The modulation index references a row in the modulations array, which contains SNR and SE values.\n\n    Args:\n        modulation_format_index_array (chex.Array): Modulation format index array\n        col_index (int): Column index for required SNR or spectral efficiency\n        params (RSAGNModelEnvParams): Environment parameters\n\n    Returns:\n        jnp.array: Required SNR for each channel (min. SNR for empty channel (mod. index 0))\n    \"\"\"\n    return jax.vmap(get_required_snr_se_kurtosis_on_link, in_axes=(0, None, None))(modulation_format_index_array, col_index, params)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_snr_link_array","title":"<code>get_snr_link_array(state, params)</code>","text":"<p>Get SNR per link Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters Returns:     jnp.array: SNR per link</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef get_snr_link_array(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get SNR per link\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: SNR per link\n    \"\"\"\n\n    def get_link_snr(link_index, state, params):\n        # Get channel power, channel centre, bandwidth, and noise figure\n        link_lengths = params.link_length_array[link_index, :]\n        num_spans = jnp.ceil(jnp.sum(link_lengths)*1e3 / params.max_span_length).astype(MED_INT_DTYPE)\n        if params.mod_format_correction:\n            mod_format_link = state.modulation_format_index_array[link_index, :]\n            kurtosis_link = get_required_snr_se_kurtosis_on_link(mod_format_link, 4, params)\n            se_link = get_required_snr_se_kurtosis_on_link(mod_format_link, 1, params)\n        else:\n            kurtosis_link = jnp.zeros(params.link_resources)\n            se_link = jnp.ones(params.link_resources)\n        bw_link = state.channel_centre_bw_array[link_index, :]\n        ch_power_link = state.channel_power_array[link_index, :]\n        required_slots_link = get_required_slots_on_link(bw_link, se_link, params)\n        ch_centres_link = get_centre_freq_on_link(jnp.arange(params.link_resources), required_slots_link, params)\n\n        # Calculate SNR\n        P = dict(\n            num_channels=params.link_resources,\n            num_spans=num_spans,\n            max_spans=params.max_spans,\n            ref_lambda=params.ref_lambda,\n            length=link_lengths,\n            attenuation_i=jnp.array(params.attenuation),\n            attenuation_bar_i=jnp.array(params.attenuation_bar),\n            nonlinear_coeff=jnp.array(params.nonlinear_coeff),\n            raman_gain_slope_i=jnp.array(params.raman_gain_slope),\n            dispersion_coeff=jnp.array(params.dispersion_coeff),\n            dispersion_slope=jnp.array(params.dispersion_slope),\n            coherent=params.coherent,\n            num_roadms=params.num_roadms,\n            roadm_loss=params.roadm_loss,\n            amplifier_noise_figure=params.amplifier_noise_figure.val,\n            transceiver_snr=params.transceiver_snr.val,\n            mod_format_correction=params.mod_format_correction,\n            ch_power_w_i=ch_power_link,\n            ch_centre_i=ch_centres_link*1e9,\n            ch_bandwidth_i=bw_link*1e9,\n            excess_kurtosis_i=kurtosis_link,\n            uniform_spans=params.uniform_spans,\n        )\n        snr = isrs_gn_model.get_snr(**P)[0]\n\n        return snr\n\n    link_snr_array = jax.vmap(get_link_snr, in_axes=(0, None, None))(jnp.arange(params.num_links), state, params)\n    link_snr_array = jnp.nan_to_num(link_snr_array, nan=1e-5)\n    return link_snr_array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.get_spectral_features","title":"<code>get_spectral_features(laplacian, num_features)</code>","text":"<p>Compute spectral node features from symmetric normalized graph Laplacian.</p> <p>Parameters:</p> Name Type Description Default <code>adj</code> <p>Adjacency matrix of the graph</p> required <code>num_features</code> <code>int</code> <p>Number of eigenvector features to extract</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape (n_nodes, num_features) containing eigenvectors corresponding</p> <code>ndarray</code> <p>to the smallest non-zero eigenvalues of the graph Laplacian.</p> Notes <ul> <li>Skips trivial eigenvectors (those with near-zero eigenvalues)</li> <li>Eigenvectors are ordered by ascending eigenvalue magnitude</li> <li>Runtime is O(n^3) - use only for small/medium graphs</li> <li>Eigenvector signs are arbitrary (may vary between runs)</li> </ul> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def get_spectral_features(laplacian: jnp.array, num_features: int) -&gt; jnp.ndarray:\n    \"\"\"Compute spectral node features from symmetric normalized graph Laplacian.\n\n    Args:\n        adj: Adjacency matrix of the graph\n        num_features: Number of eigenvector features to extract\n\n    Returns:\n        Array of shape (n_nodes, num_features) containing eigenvectors corresponding\n        to the smallest non-zero eigenvalues of the graph Laplacian.\n\n    Notes:\n        - Skips trivial eigenvectors (those with near-zero eigenvalues)\n        - Eigenvectors are ordered by ascending eigenvalue magnitude\n        - Runtime is O(n^3) - use only for small/medium graphs\n        - Eigenvector signs are arbitrary (may vary between runs)\n    \"\"\"\n    n_nodes = laplacian.shape[0]\n    eigenvalues, eigenvectors = jnp.linalg.eigh(laplacian)\n    return eigenvectors[:, :num_features].astype(LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_action_rmsa_gn_model","title":"<code>implement_action_rmsa_gn_model(state, action, params)</code>","text":"<p>Implement action for RSA GN model. Update following arrays: - link_slot_array - link_slot_departure_array - link_snr_array - modulation_format_index_array - channel_power_array - active_path_array Args:     state (EnvState): Environment state     action (chex.Array): Action tuple (first is path action, second is launch_power)     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rmsa_gn_model(\n        state: RSAGNModelEnvState, action: chex.Array, params: RSAGNModelEnvParams\n) -&gt; EnvState:\n    \"\"\"Implement action for RSA GN model. Update following arrays:\n    - link_slot_array\n    - link_slot_departure_array\n    - link_snr_array\n    - modulation_format_index_array\n    - channel_power_array\n    - active_path_array\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action tuple (first is path action, second is launch_power)\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_action, power_action = action\n    path_action = path_action.astype(MED_INT_DTYPE)\n    k_path_index, initial_slot_index = process_path_action(state, params, path_action)\n    lightpath_index = get_lightpath_index(params, nodes_sd, k_path_index)\n    path = get_paths(params, nodes_sd)[k_path_index]\n    launch_power = get_launch_power(state, path_action, power_action, params)\n    # TODO(GN MODEL) - get mod. format based on maximum reach\n    mod_format_index = jax.lax.dynamic_slice(\n        state.mod_format_mask, (path_action,), (1,)\n    ).astype(MED_INT_DTYPE)[0]\n    se = params.modulations_array.val[mod_format_index][1]\n    num_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)\n    # Update link_slot_array and link_slot_departure_array, then other arrays\n    state = implement_path_action(state, path, initial_slot_index, num_slots)\n    state = state.replace(\n        path_index_array=vmap_set_path_links(state.path_index_array, path, initial_slot_index, num_slots-params.guardband, lightpath_index),\n        channel_power_array=vmap_set_path_links(state.channel_power_array, path, initial_slot_index, num_slots-params.guardband, launch_power),\n        modulation_format_index_array=vmap_set_path_links(state.modulation_format_index_array, path, initial_slot_index, num_slots-params.guardband, mod_format_index),\n        channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, initial_slot_index, num_slots-params.guardband, params.slot_size),\n    )\n    # Update link_snr_array\n    state = state.replace(link_snr_array=get_snr_link_array(state, params))\n    # jax.debug.print(\"launch_power {}\", launch_power, ordered=True)\n    # jax.debug.print(\"mod_format_index {}\", mod_format_index, ordered=True)\n    # jax.debug.print(\"initial_slot_index {}\", initial_slot_index, ordered=True)\n    # jax.debug.print(\"state.mod_format_mask {}\", state.mod_format_mask, ordered=True)\n    # jax.debug.print(\"path_snr {}\", get_snr_for_path(path, state.link_snr_array, params), ordered=True)\n    # jax.debug.print(\"required_snr {}\", params.modulations_array.val[mod_format_index][2] + params.snr_margin, ordered=True)\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_action_rsa","title":"<code>implement_action_rsa(state, action, params)</code>","text":"<p>Implement action to assign slots on links.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <code>action</code> <code>Array</code> <p>action to implement</p> required <code>params</code> <code>EnvParams</code> <p>environment parameters</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rsa(\n        state: EnvState,\n        action: chex.Array,\n        params: EnvParams,\n) -&gt; EnvState:\n    \"\"\"Implement action to assign slots on links.\n\n    Args:\n        state: current state\n        action: action to implement\n        params: environment parameters\n\n    Returns:\n        state: updated state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_index, initial_slot_index = process_path_action(state, params, action)\n    path = get_paths(params, nodes_sd)[path_index]\n    if params.__class__.__name__ == \"RWALightpathReuseEnvParams\":\n        state = state.replace(\n            link_capacity_array=vmap_update_path_links(\n                state.link_capacity_array, path, initial_slot_index, 1, requested_datarate\n            )\n        )\n        # TODO (Dynamic-RWALR) - to support diverse requested_datarates for RWA-LR, need to update masking\n        # TODO (Dynamic-RWALR) - In order to enable dynamic RWA with lightpath reuse (as opposed to just incremental loading),\n        #  need to keep track of active requests OR just randomly remove connections\n        #  (could do this by using the link_slot_departure array in a novel way... i.e. don't fill it with departure time but current bw)\n        capacity_mask = jnp.where(state.link_capacity_array &lt;= 0., -1., 0.)\n        over_capacity_mask = jnp.where(state.link_capacity_array &lt; 0., -1., 0.)\n        total_mask = capacity_mask + over_capacity_mask\n        state = state.replace(\n            link_slot_array=total_mask,\n            link_slot_departure_array=vmap_update_path_links(state.link_slot_departure_array, path,\n                                                                       initial_slot_index, 1,\n                                                                       state.current_time + state.holding_time)\n        )\n    else:\n        se = get_paths_se(params, nodes_sd)[path_index] if params.consider_modulation_format else one\n        num_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)\n        state = implement_path_action(state, path, initial_slot_index, num_slots)\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_action_rsa_gn_model","title":"<code>implement_action_rsa_gn_model(state, action, params)</code>","text":"<p>Implement action for RSA GN model. Update following arrays: - link_slot_array - link_slot_departure_array - link_snr_array - modulation_format_index_array - channel_power_array - active_path_array Args:     state (EnvState): Environment state     action (chex.Array): Action tuple (first is path action, second is launch_power)     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rsa_gn_model(\n        state: RSAGNModelEnvState, action: chex.Array, params: RSAGNModelEnvParams\n) -&gt; EnvState:\n    \"\"\"Implement action for RSA GN model. Update following arrays:\n    - link_slot_array\n    - link_slot_departure_array\n    - link_snr_array\n    - modulation_format_index_array\n    - channel_power_array\n    - active_path_array\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action tuple (first is path action, second is launch_power)\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_action, power_action = action\n    path_action = path_action.astype(MED_INT_DTYPE)\n    k_path_index, initial_slot_index = process_path_action(state, params, path_action)\n    lightpath_index = get_lightpath_index(params, nodes_sd, k_path_index)\n    path = get_paths(params, nodes_sd)[k_path_index]\n    launch_power = get_launch_power(state, path_action, power_action, params)\n    num_slots = required_slots(requested_datarate, 1, params.slot_size, guardband=params.guardband)\n    # Update link_slot_array and link_slot_departure_array, then other arrays\n    state = implement_path_action(state, path, initial_slot_index, num_slots)\n    state = state.replace(\n        path_index_array=vmap_set_path_links(state.path_index_array, path, initial_slot_index, num_slots-params.guardband, lightpath_index),\n        channel_power_array=vmap_set_path_links(state.channel_power_array, path, initial_slot_index, num_slots-params.guardband, launch_power),\n        # TODO - update this to use separate arrays to track channel centres and bandwidths and update with bandwidth (that may or may not equal slot size)\n        channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, initial_slot_index, num_slots-params.guardband, params.slot_size),\n    )\n    if params.monitor_active_lightpaths:\n        state = state.replace(\n            active_lightpaths_array=update_active_lightpaths_array(state, lightpath_index, initial_slot_index, num_slots-params.guardband),\n            active_lightpaths_array_departure=update_active_lightpaths_array_departure(state, -state.current_time-state.holding_time),\n        )\n        # No need to check SNR until end of episode\n        return state\n    # Update link_snr_array\n    state = state.replace(link_snr_array=get_snr_link_array(state, params))\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_action_rwalr","title":"<code>implement_action_rwalr(state, action, params)</code>","text":"<p>For use in RWALightpathReuseEnv. Update link_slot_array and link_slot_departure_array to reflect new lightpath assignment. Update link_capacity_array with new capacity if lightpath is available. Undo link_capacity_update if over capacity.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>action</code> <code>Array</code> <p>Action array</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2,))\ndef implement_action_rwalr(state: EnvState, action: chex.Array, params: EnvParams) -&gt; EnvState:\n    \"\"\"For use in RWALightpathReuseEnv.\n    Update link_slot_array and link_slot_departure_array to reflect new lightpath assignment.\n    Update link_capacity_array with new capacity if lightpath is available.\n    Undo link_capacity_update if over capacity.\n\n    Args:\n        state: Environment state\n        action: Action array\n        params: Environment parameters\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(state.request_array)\n    path_index, initial_slot_index = process_path_action(state, params, action)\n    path = get_paths(params, nodes_sd)[path_index]\n    lightpath_available_check, lightpath_existing_check, curr_lightpath_capacity, lightpath_index = (\n        check_lightpath_available_and_existing(state, params, action)\n    )\n    # Get path capacity - request\n    lightpath_capacity = jax.lax.cond(\n        lightpath_existing_check,\n        lambda x: curr_lightpath_capacity - requested_datarate,  # Subtract requested_datarate from current lightpath\n        lambda x: jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.path_capacity_array, x, 1)) - requested_datarate,  # Get initial capacity of lightpath - request\n        lightpath_index\n    )\n    # Update link_capacity_array with new capacity if lightpath is available\n    state = jax.lax.cond(\n        lightpath_available_check,\n        lambda x: x.replace(\n            link_capacity_array=vmap_set_path_links(\n                state.link_capacity_array, path, initial_slot_index, 1, lightpath_capacity\n            ),\n            path_index_array=vmap_set_path_links(\n                state.path_index_array, path, initial_slot_index, 1, lightpath_index\n            ),\n        ),\n        lambda x: x,\n        state\n    )\n    capacity_mask = jnp.where(state.link_capacity_array &lt;= 0., -1., 0.)\n    over_capacity_mask = jnp.where(state.link_capacity_array &lt; 0., -1., 0.)\n    # Undo link_capacity_update if over capacity\n    # N.B. this will fail if requested capacity is greater than total original capacity of lightpath\n    lightpath_capacity_before_action = jax.lax.cond(\n        lightpath_existing_check,\n        lambda x: curr_lightpath_capacity,  # Subtract requested_datarate from current lightpath\n        lambda x: 1e6,  # Empty slots have high capacity (1e6)\n        # Get initial capacity of lightpath - request\n        None,\n    )\n    state = state.replace(\n        link_capacity_array=jnp.where(over_capacity_mask == -1, lightpath_capacity_before_action, state.link_capacity_array)\n    )\n    # Total mask will be 0 if space still available, -1 if capacity is zero or -2 if over capacity\n    total_mask = capacity_mask + over_capacity_mask\n    # Update link_slot_array and link_slot_departure_array\n    state = state.replace(\n        link_slot_array=total_mask,\n        link_slot_departure_array=vmap_update_path_links(state.link_slot_departure_array, path,\n                                                                 initial_slot_index, 1,\n                                                                 state.current_time + state.holding_time)\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_node_action","title":"<code>implement_node_action(state, s_node, d_node, s_request, d_request, n=2)</code>","text":"<p>Update node capacity, node resource and node departure arrays</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>current state</p> required <code>s_node</code> <code>int</code> <p>source node</p> required <code>d_node</code> <code>int</code> <p>destination node</p> required <code>s_request</code> <code>int</code> <p>source node request</p> required <code>d_request</code> <code>int</code> <p>destination node request</p> required <code>n</code> <code>int</code> <p>number of nodes to implement. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>State</code> <code>EnvState</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def implement_node_action(state: EnvState, s_node: chex.Array, d_node: chex.Array, s_request: chex.Array, d_request: chex.Array, n=2) -&gt; EnvState:\n    \"\"\"Update node capacity, node resource and node departure arrays\n\n    Args:\n        state (State): current state\n        s_node (int): source node\n        d_node (int): destination node\n        s_request (int): source node request\n        d_request (int): destination node request\n        n (int, optional): number of nodes to implement. Defaults to 2.\n\n    Returns:\n        State: updated state\n    \"\"\"\n    node_indices = jnp.arange(state.node_capacity_array.shape[0])\n\n    curr_selected_nodes = jnp.zeros(state.node_capacity_array.shape[0])\n    # d_request -ve so that selected node is +ve (so that argmin works correctly for node resource array update)\n    # curr_selected_nodes is N x 1 array, with requested node resources at index of selected node\n    curr_selected_nodes = update_node_array(node_indices, curr_selected_nodes, d_node, -d_request)\n    curr_selected_nodes = jax.lax.cond(n == 2, lambda x: update_node_array(*x), lambda x: x[1], (node_indices, curr_selected_nodes, s_node, -s_request))\n\n    node_capacity_array = state.node_capacity_array - curr_selected_nodes\n\n    node_resource_array = vmap_update_node_resources(state.node_resource_array, curr_selected_nodes)\n\n    node_departure_array = vmap_update_node_departure(state.node_departure_array, curr_selected_nodes, -state.current_time-state.holding_time)\n\n    state = state.replace(\n        node_capacity_array=node_capacity_array,\n        node_resource_array=node_resource_array,\n        node_departure_array=node_departure_array\n    )\n\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_path_action","title":"<code>implement_path_action(state, path, initial_slot_index, num_slots)</code>","text":"<p>Update link-slot and link-slot departure arrays. Times are set to negative until turned positive by finalisation (after checks).</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>current state</p> required <code>path</code> <code>int</code> <p>path to implement</p> required <code>initial_slot_index</code> <code>int</code> <p>initial slot index</p> required <code>num_slots</code> <code>int</code> <p>number of slots to implement</p> required Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def implement_path_action(state: EnvState, path: chex.Array, initial_slot_index: chex.Array, num_slots: chex.Array) -&gt; EnvState:\n    \"\"\"Update link-slot and link-slot departure arrays.\n    Times are set to negative until turned positive by finalisation (after checks).\n\n    Args:\n        state (State): current state\n        path (int): path to implement\n        initial_slot_index (int): initial slot index\n        num_slots (int): number of slots to implement\n    \"\"\"\n    state = state.replace(\n        link_slot_array=vmap_update_path_links(state.link_slot_array, path, initial_slot_index, num_slots, one),\n        link_slot_departure_array=vmap_update_path_links(state.link_slot_departure_array, path, initial_slot_index, num_slots, state.current_time+state.holding_time)\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.implement_vone_action","title":"<code>implement_vone_action(state, action, total_actions, remaining_actions, params)</code>","text":"<p>Implement action to assign nodes (1, 2, or 0 nodes assigned per action) and assign slots and links for lightpath.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>current state</p> required <code>action</code> <code>Array</code> <p>action to implement (node, node, path_slot_action)</p> required <code>total_actions</code> <code>Scalar</code> <p>total number of actions to implement for current request</p> required <code>remaining_actions</code> <code>Scalar</code> <p>remaining actions to implement</p> required <code>k</code> <p>number of paths to consider</p> required <code>N</code> <p>number of nodes to assign</p> required <p>Returns:</p> Name Type Description <code>state</code> <p>updated state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(4,))\ndef implement_vone_action(\n        state: EnvState,\n        action: chex.Array,\n        total_actions: chex.Scalar,\n        remaining_actions: chex.Scalar,\n        params: EnvParams,\n):\n    \"\"\"Implement action to assign nodes (1, 2, or 0 nodes assigned per action) and assign slots and links for lightpath.\n\n    Args:\n        state: current state\n        action: action to implement (node, node, path_slot_action)\n        total_actions: total number of actions to implement for current request\n        remaining_actions: remaining actions to implement\n        k: number of paths to consider\n        N: number of nodes to assign\n\n    Returns:\n        state: updated state\n    \"\"\"\n    request = jax.lax.dynamic_slice(state.request_array[0], ((remaining_actions-1)*2, ), (3, ))\n    node_request_s = jax.lax.dynamic_slice(request, (2, ), (1, ))\n    requested_datarate = jax.lax.dynamic_slice(request, (1,), (1,))\n    node_request_d = jax.lax.dynamic_slice(request, (0, ), (1, ))\n    nodes = action[::2]\n    path_index, initial_slot_index = process_path_action(state, params, action[1])\n    path = get_paths(params, nodes)[path_index]\n    se = get_paths_se(params, nodes)[path_index] if params.consider_modulation_format else jnp.array([1])\n    num_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)\n\n    # jax.debug.print(\"state.request_array {}\", state.request_array, ordered=True)\n    # jax.debug.print(\"path {}\", path, ordered=True)\n    # jax.debug.print(\"slots {}\", jnp.max(jnp.where(path.reshape(-1,1) == 1, state.link_slot_array, jnp.zeros(params.num_links).reshape(-1,1)), axis=0), ordered=True)\n    # jax.debug.print(\"path_index {}\", path_index, ordered=True)\n    # jax.debug.print(\"initial_slot_index {}\", initial_slot_index, ordered=True)\n    # jax.debug.print(\"requested_datarate {}\", requested_datarate, ordered=True)\n    # jax.debug.print(\"request {}\", request, ordered=True)\n    # jax.debug.print(\"se {}\", se, ordered=True)\n    # jax.debug.print(\"num_slots {}\", num_slots, ordered=True)\n\n    n_nodes = jax.lax.cond(\n        total_actions == remaining_actions,\n        lambda x: 2, lambda x: 1,\n        (total_actions, remaining_actions))\n    path_action_only_check = path_action_only(state.request_array[1], state.action_counter, remaining_actions)\n\n    state = jax.lax.cond(\n        path_action_only_check,\n        lambda x: x[0],\n        lambda x: implement_node_action(x[0], x[1], x[2], x[3], x[4], n=x[5]),\n        (state, nodes[0], nodes[1], node_request_s, node_request_d, n_nodes)\n    )\n\n    state = implement_path_action(state, path, initial_slot_index, num_slots)\n\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_action_counter","title":"<code>init_action_counter()</code>","text":"<p>Initialize action counter. First index is num unique nodes, second index is total steps, final is remaining steps until completion of request. Only used in VONE environments.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_action_counter():\n    \"\"\"Initialize action counter.\n    First index is num unique nodes, second index is total steps, final is remaining steps until completion of request.\n    Only used in VONE environments.\n    \"\"\"\n    return jnp.zeros(3, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_action_history","title":"<code>init_action_history(params)</code>","text":"<p>Initialize action history</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_action_history(params: EnvParams):\n    \"\"\"Initialize action history\"\"\"\n    return jnp.full(params.max_edges*2+1, -1, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_active_lightpaths_array","title":"<code>init_active_lightpaths_array(params)</code>","text":"<p>Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array. M is MIN(max_requests, num_links * link_resources / min_slots). min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:     jnp.array: Active path array (default value -1, empty path)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_active_lightpaths_array(params: RSAGNModelEnvParams):\n    \"\"\"Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array.\n    M is MIN(max_requests, num_links * link_resources / min_slots).\n    min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.\n\n    Args:\n        params (RSAGNModelEnvParams): Environment parameters\n    Returns:\n        jnp.array: Active path array (default value -1, empty path)\n    \"\"\"\n    total_slots = params.num_links * params.link_resources  # total slots on networks\n    min_slots = jnp.max(params.values_bw.val) / params.slot_size  # minimum number of slots required for lightpath\n    return jnp.full((int(total_slots / min_slots), 3), -1, dtype=LARGE_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_active_lightpaths_array_departure","title":"<code>init_active_lightpaths_array_departure(params)</code>","text":"<p>Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array. M is MIN(max_requests, num_links * link_resources / min_slots). min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <p>Returns:     jnp.array: Active path array (default value -1, empty path)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_active_lightpaths_array_departure(params: RSAGNModelEnvParams):\n    \"\"\"Initialise active lightpath array. Stores path indices of all active paths on the network in a 1 x M array.\n    M is MIN(max_requests, num_links * link_resources / min_slots).\n    min_slots is the minimum number of slots required for a lightpath i.e. max(values_bw)/ slot_size.\n\n    Args:\n        params (RSAGNModelEnvParams): Environment parameters\n    Returns:\n        jnp.array: Active path array (default value -1, empty path)\n    \"\"\"\n    total_slots = params.num_links * params.link_resources  # total slots on networks\n    min_slots = jnp.max(params.values_bw.val) / params.slot_size  # minimum number of slots required for lightpath\n    return jnp.full((int(total_slots / min_slots), 3), 0., dtype=SMALL_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_active_path_array","title":"<code>init_active_path_array(params)</code>","text":"<p>Initialise active path array. Stores details of full path utilised by lightpath on each frequency slot. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Active path array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_active_path_array(params: EnvParams):\n    \"\"\"Initialise active path array. Stores details of full path utilised by lightpath on each frequency slot.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Active path array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources, params.num_links), -1, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_channel_centre_bw_array","title":"<code>init_channel_centre_bw_array(params)</code>","text":"<p>Initialise channel centre array. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Channel centre array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_channel_centre_bw_array(params: EnvParams):\n    \"\"\"Initialise channel centre array.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Channel centre array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources), 0., dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_channel_power_array","title":"<code>init_channel_power_array(params)</code>","text":"<p>Initialise channel power array.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:     jnp.array: Channel power array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_channel_power_array(params: EnvParams):\n    \"\"\"Initialise channel power array.\n\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Channel power array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources), 0., dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_graph_tuple","title":"<code>init_graph_tuple(state, params, adj, exclude_source_dest=False)</code>","text":"<p>Initialise graph tuple for use with Jraph GNNs. Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters     adj (jnp.array): Adjacency matrix of the graph Returns:     jraph.GraphsTuple: Graph tuple</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 3))\ndef init_graph_tuple(state: EnvState, params: EnvParams, adj: jnp.array, exclude_source_dest: bool=False) -&gt; jraph.GraphsTuple:\n    \"\"\"Initialise graph tuple for use with Jraph GNNs.\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        adj (jnp.array): Adjacency matrix of the graph\n    Returns:\n        jraph.GraphsTuple: Graph tuple\n    \"\"\"\n    senders = params.edges.val.T[0]\n    receivers = params.edges.val.T[1]\n\n    # Get source and dest from request array\n    source_dest, datarate = read_rsa_request(state.request_array)\n    # Global feature is normalised data rate of current request\n    globals = jnp.array([datarate / jnp.max(params.values_bw.val)], dtype=LARGE_FLOAT_DTYPE)\n\n    if exclude_source_dest:\n        source_dest_features = jnp.zeros((params.num_nodes, 2), dtype=LARGE_FLOAT_DTYPE)\n    else:\n        source, dest = source_dest[0], source_dest[2]\n        # One-hot encode source and destination (2 additional features)\n        source_dest_features = jnp.zeros((params.num_nodes, 2), dtype=LARGE_FLOAT_DTYPE)\n        source_dest_features = source_dest_features.at[source.astype(MED_INT_DTYPE), 0].set(1)\n        source_dest_features = source_dest_features.at[dest.astype(MED_INT_DTYPE), 1].set(-1)\n\n    spectral_features = get_spectral_features(adj, num_features=3)\n\n    # For dynamic traffic, edge_features are normalised remaining holding time instead of link_slot_array\n    holding_time_edge_features = state.link_slot_departure_array / params.mean_service_holding_time\n\n    if params.__class__.__name__ in [\"RSAGNModelEnvParams\", \"RMSAGNModelEnvParams\"]:\n        # Normalize by max parameters (converted to linear units)\n        max_power = isrs_gn_model.from_dbm(params.max_power)\n        normalized_power = jnp.round(state.channel_power_array / max_power, 3)\n        max_snr = isrs_gn_model.from_db(params.max_snr)\n        normalized_snr = jnp.round(state.link_snr_array / max_snr, 3)\n        edge_features = jnp.stack([normalized_snr, normalized_power], axis=-1)\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n    elif params.__class__.__name__ == \"VONEEnvParams\":\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        node_features = getattr(state, \"node_capacity_array\", jnp.zeros(params.num_nodes, dtype=LARGE_FLOAT_DTYPE))\n        node_features = node_features.reshape(-1, 1)\n        node_features = jnp.concatenate([node_features, spectral_features, source_dest_features], axis=-1)\n    else:\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        # [n_edges] or [n_edges, ...]\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n\n    if params.disable_node_features:\n        node_features = jnp.zeros((1,), dtype=LARGE_FLOAT_DTYPE)\n\n    # Handle undirected graphs (duplicate edges after normalization)\n    if not params.directed_graph:\n        senders_ = jnp.concatenate([senders, receivers])\n        receivers = jnp.concatenate([receivers, senders])\n        senders = senders_\n        edge_features = jnp.repeat(edge_features, 2, axis=0)\n\n    return jraph.GraphsTuple(\n        nodes=node_features,\n        edges=edge_features,\n        senders=senders,\n        receivers=receivers,\n        n_node=jnp.reshape(params.num_nodes, (1,)),\n        n_edge=jnp.reshape(len(senders), (1,)),\n        globals=globals,\n    )\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_link_capacity_array","title":"<code>init_link_capacity_array(params)</code>","text":"<p>Initialise link capacity array. Represents available data rate for lightpath on each link. Default is high value (1e6) for unoccupied slots. Once lightpath established, capacity is determined by corresponding entry in path capacity array.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_capacity_array(params):\n    \"\"\"Initialise link capacity array. Represents available data rate for lightpath on each link.\n    Default is high value (1e6) for unoccupied slots. Once lightpath established, capacity is determined by\n    corresponding entry in path capacity array.\"\"\"\n    return jnp.full((params.num_links, params.link_resources), 1e6)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_link_length_array","title":"<code>init_link_length_array(graph)</code>","text":"<p>Initialise link length array. Args:     graph (nx.Graph): NetworkX graph Returns:</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_length_array(graph: nx.Graph) -&gt; chex.Array:\n    \"\"\"Initialise link length array.\n    Args:\n        graph (nx.Graph): NetworkX graph\n    Returns:\n\n    \"\"\"\n    link_lengths = []\n    for edge in sorted(graph.edges):\n        link_lengths.append(graph.edges[edge][\"weight\"])\n    return jnp.array(link_lengths, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_link_length_array_gn_model","title":"<code>init_link_length_array_gn_model(graph, max_span_length, max_spans)</code>","text":"<p>Initialise link length array for environements that use GN model of physical layer. We assume each link has spans of equal length.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>NetworkX graph</p> required <p>Returns:     jnp.array: Link length array (L x max_spans)</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_length_array_gn_model(graph: nx.Graph, max_span_length: int,  max_spans: int) -&gt; chex.Array:\n    \"\"\"Initialise link length array for environements that use GN model of physical layer.\n    We assume each link has spans of equal length.\n\n    Args:\n        graph (nx.Graph): NetworkX graph\n    Returns:\n        jnp.array: Link length array (L x max_spans)\n    \"\"\"\n    link_lengths = []\n    directed = graph.is_directed()\n    graph = graph.to_undirected()\n    edges = sorted(graph.edges)\n    for edge in edges:\n        link_lengths.append(graph.edges[edge][\"weight\"])\n    if directed:\n        for edge in edges:\n            link_lengths.append(graph.edges[edge][\"weight\"])\n    span_length_array = []\n    for length in link_lengths:\n        num_spans = math.ceil(length / max_span_length)\n        avg_span_length = length / num_spans\n        span_lengths = [avg_span_length] * num_spans\n        span_lengths.extend([0] * (max_spans - num_spans))\n        span_length_array.append(span_lengths)\n    return jnp.array(span_length_array, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_link_slot_array","title":"<code>init_link_slot_array(params)</code>","text":"<p>Initialize empty (all zeroes) link-slot array. 0 means slot is free, -1 means occupied. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Link slot array (E x S) where E is number of edges and S is number of slots</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_link_slot_array(params: EnvParams):\n    \"\"\"Initialize empty (all zeroes) link-slot array. 0 means slot is free, -1 means occupied.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Link slot array (E x S) where E is number of edges and S is number of slots\"\"\"\n    return jnp.zeros((params.num_links, params.link_resources), dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_link_slot_mask","title":"<code>init_link_slot_mask(params, agg=1)</code>","text":"<p>Initialize link mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0, 1))\ndef init_link_slot_mask(params: EnvParams, agg: int = 1):\n    \"\"\"Initialize link mask\"\"\"\n    return jnp.ones(params.k_paths*math.ceil(params.link_resources / agg), dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_link_snr_array","title":"<code>init_link_snr_array(params)</code>","text":"<p>Initialise signal-to-noise ratio (SNR) array. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: SNR array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_link_snr_array(params: EnvParams):\n    \"\"\"Initialise signal-to-noise ratio (SNR) array.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: SNR array\n    \"\"\"\n    # The SNR is kept in linear units to allow summation of 1/SNR across links\n    return jnp.full((params.num_links, params.link_resources), -1e5, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_mod_format_mask","title":"<code>init_mod_format_mask(params)</code>","text":"<p>Initialize link mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_mod_format_mask(params: EnvParams):\n    \"\"\"Initialize link mask\"\"\"\n    return jnp.full((params.k_paths*params.link_resources,), -1.0, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_modulation_format_index_array","title":"<code>init_modulation_format_index_array(params)</code>","text":"<p>Initialise modulation format index array. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Modulation format index array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_modulation_format_index_array(params: EnvParams):\n    \"\"\"Initialise modulation format index array.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Modulation format index array\n    \"\"\"\n    return jnp.full((params.num_links, params.link_resources), -1, dtype=MED_INT_DTYPE)  # -1 so that highest order is assumed (closest to Gaussian)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_modulations_array","title":"<code>init_modulations_array(modulations_filepath=None)</code>","text":"<p>Initialise array of maximum spectral efficiency for modulation format on path.</p> <p>Parameters:</p> Name Type Description Default <code>modulations_filepath</code> <code>str</code> <p>Path to CSV file containing modulation formats. Defaults to None.</p> <code>None</code> <p>Returns:     jnp.array: Array of maximum spectral efficiency for modulation format on path.     First two columns are maximum path length and spectral efficiency.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_modulations_array(modulations_filepath: str = None):\n    \"\"\"Initialise array of maximum spectral efficiency for modulation format on path.\n\n    Args:\n        modulations_filepath (str, optional): Path to CSV file containing modulation formats. Defaults to None.\n    Returns:\n        jnp.array: Array of maximum spectral efficiency for modulation format on path.\n        First two columns are maximum path length and spectral efficiency.\n    \"\"\"\n    f = pathlib.Path(modulations_filepath) if modulations_filepath else (\n            pathlib.Path(__file__).parents[1].absolute() / \"data\" / \"modulations\" / \"modulations.csv\")\n    modulations = np.genfromtxt(f, delimiter=',')\n    # Drop empty first row (headers) and column (name)\n    modulations = modulations[1:, 1:]\n    return jnp.array(modulations, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_node_capacity_array","title":"<code>init_node_capacity_array(params)</code>","text":"<p>Initialize node array with uniform resources. Args:     params (EnvParams): Environment parameters Returns:     jnp.array: Node capacity array (N x 1) where N is number of nodes</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_node_capacity_array(params: EnvParams):\n    \"\"\"Initialize node array with uniform resources.\n    Args:\n        params (EnvParams): Environment parameters\n    Returns:\n        jnp.array: Node capacity array (N x 1) where N is number of nodes\"\"\"\n    return jnp.array([params.node_resources] * params.num_nodes, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_node_mask","title":"<code>init_node_mask(params)</code>","text":"<p>Initialize node mask</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_node_mask(params: EnvParams):\n    \"\"\"Initialize node mask\"\"\"\n    return jnp.ones(params.num_nodes, dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_node_resource_array","title":"<code>init_node_resource_array(params)</code>","text":"<p>Array to track node resources occupied by virtual nodes</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_node_resource_array(params: EnvParams):\n    \"\"\"Array to track node resources occupied by virtual nodes\"\"\"\n    return jnp.zeros((params.num_nodes, params.node_resources), dtype=LARGE_FLOAT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_path_capacity_array","title":"<code>init_path_capacity_array(link_length_array, path_link_array, min_request=1, scale_factor=1.0, alpha=0.0002, NF=4.5, B=10000000000000.0, R_s=100000000000.0, beta_2=-2.17e-26, gamma=0.0012, L_s=100000.0, lambda0=1.55e-06)</code>","text":"<p>Calculated from Nevin paper: https://api.repository.cam.ac.uk/server/api/core/bitstreams/b80e7a9c-a86b-4b30-a6d6-05017c60b0c8/content</p> <p>Parameters:</p> Name Type Description Default <code>link_length_array</code> <code>Array</code> <p>Array of link lengths</p> required <code>path_link_array</code> <code>Array</code> <p>Array of links on paths</p> required <code>min_request</code> <code>int</code> <p>Minimum data rate request size. Defaults to 100 GBps.</p> <code>1</code> <code>scale_factor</code> <code>float</code> <p>Scale factor for link capacity. Defaults to 1.0.</p> <code>1.0</code> <code>alpha</code> <code>float</code> <p>Fibre attenuation coefficient. Defaults to 0.2e-3 /m</p> <code>0.0002</code> <code>NF</code> <code>float</code> <p>Amplifier noise figure. Defaults to 4.5 dB.</p> <code>4.5</code> <code>B</code> <code>float</code> <p>Total modulated bandwidth. Defaults to 10e12 Hz.</p> <code>10000000000000.0</code> <code>R_s</code> <code>float</code> <p>Symbol rate. Defaults to 100e9 Baud.</p> <code>100000000000.0</code> <code>beta_2</code> <code>float</code> <p>Dispersion parameter. Defaults to -21.7e-27 s^2/m.</p> <code>-2.17e-26</code> <code>gamma</code> <code>float</code> <p>Nonlinear coefficient. Defaults to 1.2e-3 /W/m.</p> <code>0.0012</code> <code>L_s</code> <code>float</code> <p>Span length. Defaults to 100e3 m.</p> <code>100000.0</code> <code>lambda0</code> <code>float</code> <p>Wavelength. Defaults to 1550e-9 m.</p> <code>1.55e-06</code> <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Array of link capacities in Gbps</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_capacity_array(\n        link_length_array: chex.Array,\n        path_link_array: chex.Array,\n        min_request=1,  # Minimum data rate request size\n        scale_factor=1.0,  # Scale factor for link capacity\n        alpha=0.2e-3,  # Fibre attenuation coefficient\n        NF=4.5,  # Amplifier noise figure\n        B=10e12,  # Total modulated bandwidth\n        R_s=100e9,  # Symbol rate\n        beta_2=-21.7e-27,  # Dispersion parameter\n        gamma=1.2e-3,  # Nonlinear coefficient\n        L_s=100e3,  # span length\n        lambda0=1550e-9,  # Wavelength\n) -&gt; chex.Array:\n    \"\"\"Calculated from Nevin paper:\n    https://api.repository.cam.ac.uk/server/api/core/bitstreams/b80e7a9c-a86b-4b30-a6d6-05017c60b0c8/content\n\n    Args:\n        link_length_array (chex.Array): Array of link lengths\n        path_link_array (chex.Array): Array of links on paths\n        min_request (int, optional): Minimum data rate request size. Defaults to 100 GBps.\n        scale_factor (float, optional): Scale factor for link capacity. Defaults to 1.0.\n        alpha (float, optional): Fibre attenuation coefficient. Defaults to 0.2e-3 /m\n        NF (float, optional): Amplifier noise figure. Defaults to 4.5 dB.\n        B (float, optional): Total modulated bandwidth. Defaults to 10e12 Hz.\n        R_s (float, optional): Symbol rate. Defaults to 100e9 Baud.\n        beta_2 (float, optional): Dispersion parameter. Defaults to -21.7e-27 s^2/m.\n        gamma (float, optional): Nonlinear coefficient. Defaults to 1.2e-3 /W/m.\n        L_s (float, optional): Span length. Defaults to 100e3 m.\n        lambda0 (float, optional): Wavelength. Defaults to 1550e-9 m.\n\n    Returns:\n        chex.Array: Array of link capacities in Gbps\n    \"\"\"\n    path_length_array = jnp.dot(path_link_array, link_length_array)\n    path_capacity_array = calculate_path_capacity(\n        path_length_array,\n        min_request=min_request,\n        scale_factor=scale_factor,\n        alpha=alpha,\n        NF=NF,\n        B=B,\n        R_s=R_s,\n        beta_2=beta_2,\n        gamma=gamma,\n        L_s=L_s,\n        lambda0=lambda0,\n    )\n    return path_capacity_array.astype(MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_path_index_array","title":"<code>init_path_index_array(params)</code>","text":"<p>Initialise path index array. Represents index of lightpath occupying each slot.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_index_array(params):\n    \"\"\"Initialise path index array. Represents index of lightpath occupying each slot.\"\"\"\n    return jnp.full((params.num_links, params.link_resources), -1)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_path_length_array","title":"<code>init_path_length_array(path_link_array, graph)</code>","text":"<p>Initialise path length array.</p> <p>Parameters:</p> Name Type Description Default <code>path_link_array</code> <code>Array</code> <p>Path-link array</p> required <code>graph</code> <code>Graph</code> <p>NetworkX graph</p> required <p>Returns:     chex.Array: Path length array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_length_array(path_link_array: chex.Array, graph: nx.Graph) -&gt; chex.Array:\n    \"\"\"Initialise path length array.\n\n    Args:\n        path_link_array (chex.Array): Path-link array\n        graph (nx.Graph): NetworkX graph\n    Returns:\n        chex.Array: Path length array\n    \"\"\"\n    link_length_array = init_link_length_array(graph)\n    path_lengths = jnp.dot(path_link_array, link_length_array)\n    return path_lengths\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_path_link_array","title":"<code>init_path_link_array(graph, k, disjoint=False, weight='weight', directed=False, modulations_array=None, rwa_lr=False, scale_factor=1.0, path_snr=False)</code>","text":"<p>Initialise path-link array. Each path is defined by a link utilisation array (one row in the path-link array). 1 indicates link corresponding to index is used, 0 indicates not used.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>NetworkX graph</p> required <code>k</code> <code>int</code> <p>Number of paths</p> required <code>disjoint</code> <code>bool</code> <p>Whether to use edge-disjoint paths. Defaults to False.</p> <code>False</code> <code>weight</code> <code>str</code> <p>Sort paths by edge attribute. Defaults to \"weight\".</p> <code>'weight'</code> <code>directed</code> <code>bool</code> <p>Whether graph is directed. Defaults to False.</p> <code>False</code> <code>modulations_array</code> <code>Array</code> <p>Array of maximum spectral efficiency for modulation format on path. Defaults to None.</p> <code>None</code> <code>rwa_lr</code> <code>bool</code> <p>Whether the environment is RWA with lightpath reuse (affects path ordering).</p> <code>False</code> <code>path_snr</code> <code>bool</code> <p>If GN model is used, include extra row of zeroes for unutilised paths</p> <code>False</code> <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Path-link array (N(N-1)*k x E) where N is number of nodes, E is number of edges, k is number of shortest paths</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_link_array(\n        graph: nx.Graph,\n        k: int,\n        disjoint: bool = False,\n        weight: str = \"weight\",\n        directed: bool = False,\n        modulations_array: chex.Array = None,\n        rwa_lr: bool = False,\n        scale_factor: float = 1.0,\n        path_snr: bool = False,\n) -&gt; chex.Array:\n    \"\"\"Initialise path-link array.\n    Each path is defined by a link utilisation array (one row in the path-link array).\n    1 indicates link corresponding to index is used, 0 indicates not used.\n\n    Args:\n        graph (nx.Graph): NetworkX graph\n        k (int): Number of paths\n        disjoint (bool, optional): Whether to use edge-disjoint paths. Defaults to False.\n        weight (str, optional): Sort paths by edge attribute. Defaults to \"weight\".\n        directed (bool, optional): Whether graph is directed. Defaults to False.\n        modulations_array (chex.Array, optional): Array of maximum spectral efficiency for modulation format on path. Defaults to None.\n        rwa_lr (bool, optional): Whether the environment is RWA with lightpath reuse (affects path ordering).\n        path_snr (bool, optional): If GN model is used, include extra row of zeroes for unutilised paths\n        to ensure correct SNR calculation for empty paths (path index -1).\n\n    Returns:\n        chex.Array: Path-link array (N(N-1)*k x E) where N is number of nodes, E is number of edges, k is number of shortest paths\n    \"\"\"\n    def get_k_shortest_paths(g, source, target, k, weight):\n        return list(\n            islice(nx.shortest_simple_paths(g, source, target, weight=weight), k)\n        )\n\n    def get_k_disjoint_shortest_paths(g, source, target, k, weight):\n        k_paths_disjoint_unsorted = list(nx.edge_disjoint_paths(g, source, target))\n        k_paths_shortest = get_k_shortest_paths(g, source, target, k, weight=weight)\n\n        # Keep disjoint paths and add unique shortest paths until k paths reached\n        disjoint_ids = [tuple(path) for path in k_paths_disjoint_unsorted]\n        k_paths = k_paths_disjoint_unsorted\n        for path in k_paths_shortest:\n            if tuple(path) not in disjoint_ids:\n                k_paths.append(path)\n        k_paths = k_paths[:k]\n        return k_paths\n\n    paths = []\n    edges = sorted(graph.edges)\n\n    # Get the k-shortest paths for each node pair\n    k_path_collections = []\n    get_paths = get_k_disjoint_shortest_paths if disjoint else get_k_shortest_paths\n    for node_pair in combinations(graph.nodes, 2):\n\n        k_paths = get_paths(graph, node_pair[0], node_pair[1], k, weight=weight)\n        k_path_collections.append(k_paths)\n\n    if directed:  # Get paths in reverse direction\n        for node_pair in combinations(graph.nodes, 2):\n            k_paths_rev = get_paths(graph, node_pair[1], node_pair[0], k, weight=weight)\n            k_path_collections.append(k_paths_rev)\n\n    # Sort the paths for each node pair\n    max_missing_paths = 0\n    for k_paths in k_path_collections:\n\n        source, dest = k_paths[0][0], k_paths[0][-1]\n\n        # Sort the paths by # of hops then by length, or just length\n        path_lengths = [nx.path_weight(graph, path, weight='weight') for path in k_paths]\n        path_num_links = [len(path) - 1 for path in k_paths]\n\n        # Get maximum spectral efficiency for modulation format on path\n        if modulations_array is not None and rwa_lr is not True:\n            se_of_path = []\n            modulations_array = modulations_array[::-1]\n            for length in path_lengths:\n                for modulation in modulations_array:\n                    if length &lt;= modulation[0]:\n                        se_of_path.append(modulation[1])\n                        break\n            # Sorting by the num_links/se instead of just path length is observed to improve performance\n            path_weighting = [num_links/se for se, num_links in zip(se_of_path, path_num_links)]\n        elif rwa_lr:\n            path_capacity = [float(calculate_path_capacity(path_length, scale_factor=scale_factor)) for path_length in path_lengths]\n            path_weighting = [num_links/path_capacity for num_links, path_capacity in zip(path_num_links, path_capacity)]\n        elif weight is None:\n            path_weighting = path_num_links\n        else:\n            path_weighting = path_lengths\n\n        # if less then k unique paths, add empty paths\n        empty_path = [0] * len(graph.edges)\n        num_missing_paths = k - len(k_paths)\n        max_missing_paths = max(max_missing_paths, num_missing_paths)\n        k_paths = k_paths + [empty_path] * num_missing_paths\n        path_weighting = path_weighting + [1e6] * num_missing_paths\n        path_lengths = path_lengths + [1e6] * num_missing_paths\n\n        # Sort by number of links then by length (or just by length if weight is specified)\n        unsorted_paths = zip(k_paths, path_weighting, path_lengths)\n        k_paths_sorted = [(source, dest, weighting, path) for path, weighting, _ in sorted(unsorted_paths, key=lambda x: (x[1], 1/x[2]) if weight is None else x[2])]\n\n        # Keep only first k paths\n        k_paths_sorted = k_paths_sorted[:k]\n\n        prev_link_usage = empty_path\n        for k_path in k_paths_sorted:\n            k_path = k_path[-1]\n            link_usage = [0]*len(graph.edges)  # Initialise empty path\n            if sum(k_path) == 0:\n                link_usage = prev_link_usage\n            else:\n                for i in range(len(k_path)-1):\n                    s, d = k_path[i], k_path[i + 1]\n                    for edge_index, edge in enumerate(edges):\n                        condition = (edge[0] == s and edge[1] == d) if directed else \\\n                            ((edge[0] == s and edge[1] == d) or (edge[0] == d and edge[1] == s))\n                        if condition:\n                            link_usage[edge_index] = 1\n            path = link_usage\n            prev_link_usage = link_usage\n            paths.append(path)\n\n    # If using GN model, add extra row of zeroes for empty paths for SNR calculation\n    if path_snr:\n        empty_path = [0] * len(graph.edges)\n        paths.append(empty_path)\n\n    return jnp.array(paths, dtype=SMALL_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_path_se_array","title":"<code>init_path_se_array(path_length_array, modulations_array)</code>","text":"<p>Initialise array of maximum spectral efficiency for highest-order modulation format on path.</p> <p>Parameters:</p> Name Type Description Default <code>path_length_array</code> <code>array</code> <p>Array of path lengths</p> required <code>modulations_array</code> <code>array</code> <p>Array of maximum spectral efficiency for modulation format on path</p> required <p>Returns:</p> Type Description <p>jnp.array: Array of maximum spectral efficiency for on path</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_path_se_array(path_length_array, modulations_array):\n    \"\"\"Initialise array of maximum spectral efficiency for highest-order modulation format on path.\n\n    Args:\n        path_length_array (jnp.array): Array of path lengths\n        modulations_array (jnp.array): Array of maximum spectral efficiency for modulation format on path\n\n    Returns:\n        jnp.array: Array of maximum spectral efficiency for on path\n    \"\"\"\n    se_list = []\n    # Flip the modulation array so that the shortest path length is first\n    modulations_array = modulations_array[::-1]\n    for length in path_length_array:\n        for modulation in modulations_array:\n            if length &lt;= modulation[0]:\n                se_list.append(modulation[1])\n                break\n    return jnp.array(se_list, dtype=SMALL_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_rsa_request_array","title":"<code>init_rsa_request_array()</code>","text":"<p>Initialize request array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_rsa_request_array():\n    \"\"\"Initialize request array\"\"\"\n    return jnp.zeros(3, dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_traffic_matrix","title":"<code>init_traffic_matrix(key, params)</code>","text":"<p>Initialize traffic matrix. Allows for random traffic matrix or uniform traffic matrix. Source-dest traffic requests are sampled probabilistically from the resulting traffic matrix.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>PRNGKey</code> <p>PRNG key</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <p>jnp.array: Traffic matrix</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef init_traffic_matrix(key: chex.PRNGKey, params: EnvParams):\n    \"\"\"Initialize traffic matrix. Allows for random traffic matrix or uniform traffic matrix.\n    Source-dest traffic requests are sampled probabilistically from the resulting traffic matrix.\n\n    Args:\n        key (chex.PRNGKey): PRNG key\n        params (EnvParams): Environment parameters\n\n    Returns:\n        jnp.array: Traffic matrix\n    \"\"\"\n    if params.random_traffic:\n        traffic_matrix = jax.random.uniform(key, shape=(params.num_nodes, params.num_nodes), dtype=SMALL_FLOAT_DTYPE)\n    else:\n        traffic_matrix = jnp.ones((params.num_nodes, params.num_nodes), dtype=SMALL_FLOAT_DTYPE)\n    diag_elements = jnp.diag_indices_from(traffic_matrix)\n    # Set main diagonal to zero so no requests from node to itself\n    traffic_matrix = traffic_matrix.at[diag_elements].set(0)\n    traffic_matrix = normalise_traffic_matrix(traffic_matrix)\n    return traffic_matrix\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_transceiver_amplifier_noise_arrays","title":"<code>init_transceiver_amplifier_noise_arrays(link_resources, ref_lambda, slot_size, noise_data_filepath=None)</code>","text":"<p>Initialise transceiver and amplifier noise arrays. Args:     link_resources (int): Number of link resources     ref_lambda (float): Reference wavelength     slot_size (float): Slot size     noise_data_filepath (str, optional): Path to CSV file containing modulation formats. Defaults to None. Returns:     Tuple[chex.Array, chex.Array]: Transceiver noise array, Amplifier noise array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_transceiver_amplifier_noise_arrays(\n        link_resources: int,\n        ref_lambda: float,\n        slot_size: float,\n        noise_data_filepath: str = None\n) -&gt; Tuple[chex.Array, chex.Array]:\n    \"\"\"Initialise transceiver and amplifier noise arrays.\n    Args:\n        link_resources (int): Number of link resources\n        ref_lambda (float): Reference wavelength\n        slot_size (float): Slot size\n        noise_data_filepath (str, optional): Path to CSV file containing modulation formats. Defaults to None.\n    Returns:\n        Tuple[chex.Array, chex.Array]: Transceiver noise array, Amplifier noise array\n    \"\"\"\n    f = pathlib.Path(noise_data_filepath) if noise_data_filepath else (\n            pathlib.Path(__file__).parents[1].absolute() / \"data\" / \"gn_model\" / \"transceiver_amplifier_data.csv\")\n    noise_data = np.genfromtxt(f, delimiter=',')\n    # Drop empty first row (headers) and column (name)\n    noise_data = noise_data[1:, 1:]\n    # Columns are: wavelength_min_nm,wavelength_max_nm,frequency_min_ghz,frequency_max_ghz,NF_ASE_dB,SNR_TRX_dB\n    frequency_min_ghz = noise_data[:, 2]\n    frequency_max_ghz = noise_data[:, 3]\n    amplifier_noise_db = noise_data[:, 4]  # NF_ASE_dB\n    transceiver_snr_db = noise_data[:, 5]  # SNR_TRX_dB\n\n    # Define slot centres in GHz relative to central wavelength\n    slot_centres = (jnp.arange(link_resources) - (link_resources - 1) / 2) * slot_size\n\n    # Transform relative slot centres to absolute frequencies in GHz\n    ref_frequency_ghz = c / ref_lambda / 1e9\n    slot_frequencies_ghz = ref_frequency_ghz + slot_centres\n\n    # Initialize output arrays\n    transceiver_snr_array = jnp.zeros(link_resources)\n    amplifier_noise_figure_array = jnp.zeros(link_resources)\n\n    # For each slot, find which band it belongs to\n    for i, freq in enumerate(slot_frequencies_ghz):\n        # Find the band this frequency falls into\n        for j in range(len(frequency_min_ghz)):\n            if frequency_min_ghz[j] &lt;= freq &lt;= frequency_max_ghz[j]:\n                transceiver_snr_array = transceiver_snr_array.at[i].set(transceiver_snr_db[j])\n                amplifier_noise_figure_array = amplifier_noise_figure_array.at[i].set(amplifier_noise_db[j])\n                break\n        else:\n            # If frequency is outside all bands, could raise error or use default\n            raise ValueError(f\"Frequency {freq} GHz is outside the defined bands\")\n\n    return transceiver_snr_array, amplifier_noise_figure_array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_virtual_topology_patterns","title":"<code>init_virtual_topology_patterns(pattern_names)</code>","text":"<p>Initialise virtual topology patterns. First 3 digits comprise the \"action counter\": first index is num unique nodes, second index is total steps, final is remaining steps until completion of request. Remaining digits define the topology pattern, with 1 to indicate links and other positive integers are node indices.</p> <p>Parameters:</p> Name Type Description Default <code>pattern_names</code> <code>list</code> <p>List of virtual topology pattern names</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Array of virtual topology patterns</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def init_virtual_topology_patterns(pattern_names: str) -&gt; chex.Array:\n    \"\"\"Initialise virtual topology patterns.\n    First 3 digits comprise the \"action counter\": first index is num unique nodes, second index is total steps,\n    final is remaining steps until completion of request.\n    Remaining digits define the topology pattern, with 1 to indicate links and other positive integers are node indices.\n\n    Args:\n        pattern_names (list): List of virtual topology pattern names\n\n    Returns:\n        chex.Array: Array of virtual topology patterns\n    \"\"\"\n    patterns = []\n    # TODO - Allow 2 node requests in VONE (check if any modifications necessary other than below)\n    #if \"2_bus\" in pattern_names:\n    #    patterns.append([2, 1, 1, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0])\n    if \"3_bus\" in pattern_names:\n        patterns.append([3, 2, 2, 2, 1, 3, 1, 4])\n    if \"3_ring\" in pattern_names:\n        patterns.append([3, 3, 3, 2, 1, 3, 1, 4, 1, 2])\n    if \"4_bus\" in pattern_names:\n        patterns.append([4, 3, 3, 2, 1, 3, 1, 4, 1, 5])\n    if \"4_ring\" in pattern_names:\n        patterns.append([4, 4, 4, 2, 1, 3, 1, 4, 1, 5, 1, 2])\n    if \"5_bus\" in pattern_names:\n        patterns.append([5, 4, 4, 2, 1, 3, 1, 4, 1, 5, 1, 6])\n    if \"5_ring\" in pattern_names:\n        patterns.append([5, 5, 5, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 2])\n    if \"6_bus\" in pattern_names:\n        patterns.append([6, 5, 5, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7])\n    max_length = max([len(pattern) for pattern in patterns])\n    # Pad patterns with zeroes to match longest\n    for pattern in patterns:\n        pattern.extend([0]*(max_length-len(pattern)))\n    return jnp.array(patterns, dtype=SMALL_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.init_vone_request_array","title":"<code>init_vone_request_array(params)</code>","text":"<p>Initialize request array either with uniform resources</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef init_vone_request_array(params: EnvParams):\n    \"\"\"Initialize request array either with uniform resources\"\"\"\n    return jnp.zeros((2, params.max_edges*2+1,), dtype=MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.kca_ff","title":"<code>kca_ff(state, params)</code>","text":"<p>Congestion-aware First Fit. Only suitable for RSA/RMSA. Method:</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef kca_ff(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Congestion-aware First Fit. Only suitable for RSA/RMSA.\n    Method:\n\n    \"\"\"\n    mask = get_action_mask(state, params)\n    # Get index of first available slots for each path\n    first_slots = first_fit(state, params)\n    # Get nodes\n    nodes_sd, _ = read_rsa_request(state.request_array)\n    # Initialise array to hold congestion on each path\n    path_congestion_array = jnp.full((mask.shape[0],), 0.)\n    link_weights = get_link_weights(state, params)\n\n    def get_path_congestion(i, val):\n        # Get links on path\n        path = get_paths(params, nodes_sd)[i]\n        # Get congestion\n        path_link_congestion = jnp.multiply(link_weights, path)\n        path_congestion = jnp.sum(path_link_congestion).reshape((1,))\n        return jax.lax.dynamic_update_slice(val, path_congestion, (i,))\n\n    path_congestion_array = jax.lax.fori_loop(0, mask.shape[0], get_path_congestion, path_congestion_array)\n    path_index = jnp.argmin(path_congestion_array)\n    slot_index = first_slots[path_index] % params.link_resources\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.kmc_ff","title":"<code>kmc_ff(state, params)</code>","text":"<p>K-Minimum Cut. Only suitable for RSA/RMSA. Method: 1. Go through action mask and find the first available slot on all paths. 2. For each path, allocate the first available slot. 3. Sum number of new consecutive zero regions (cuts) created by assignment (on each link) 4. Choose path that creates the fewest cuts.</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef kmc_ff(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"K-Minimum Cut. Only suitable for RSA/RMSA.\n    Method:\n    1. Go through action mask and find the first available slot on all paths.\n    2. For each path, allocate the first available slot.\n    3. Sum number of new consecutive zero regions (cuts) created by assignment (on each link)\n    4. Choose path that creates the fewest cuts.\n    \"\"\"\n    mask = get_action_mask(state, params)\n    first_slots = first_fit(state, params)\n    link_slot_array = jnp.where(state.link_slot_array &lt; 0, 1., state.link_slot_array)\n    nodes_sd, requested_bw = read_rsa_request(state.request_array)\n    block_sizes = jax.vmap(find_block_sizes, in_axes=(0,))(link_slot_array)\n    block_sizes_mask = jnp.where(block_sizes &gt; 0, 1, 0.)  # Binary array showing initial block starts\n    block_count = jnp.sum(block_sizes_mask, axis=1)\n\n    def get_cuts_on_path(i, result):\n        initial_slot_index = first_slots[i] % params.link_resources\n        path = get_paths(params, nodes_sd)[i]\n        se = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else 1\n        num_slots = required_slots(requested_bw, se, params.slot_size, guardband=params.guardband)\n        # Make link-slot_array positive\n        updated_slots = vmap_set_path_links(link_slot_array, path, initial_slot_index, num_slots, 1.)\n        updated_block_sizes = jax.vmap(find_block_sizes, in_axes=(0,))(updated_slots)\n        updated_block_sizes_mask = jnp.where(updated_block_sizes &gt; 0, 1, 0)  # Binary array showing updated block starts\n        updated_block_count = jnp.sum(updated_block_sizes_mask, axis=1)\n        num_cuts = jax.lax.cond(\n            mask[i][initial_slot_index] == 0.,  # If true, no valid action for path\n            lambda x: jnp.full((1,), params.link_resources*params.num_links).astype(jnp.float32),  # Return max no. of cuts\n            lambda x: jnp.sum(jnp.maximum(updated_block_count - block_count, 0.)).reshape((1,)),  # Else, return number of cuts\n            1.\n        )\n        result = jax.lax.dynamic_update_slice(result, num_cuts, (i,))\n        return result\n\n    # Initialise array to hold number of cuts on each path\n    path_cuts_array = jnp.full((mask.shape[0],), 0.)\n    path_cuts_array = jax.lax.fori_loop(0, mask.shape[0], get_cuts_on_path, path_cuts_array)\n    path_index = jnp.argmin(path_cuts_array)\n    slot_index = first_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.kme_ff","title":"<code>kme_ff(state, params)</code>","text":"<p>K-Minimum Entropy. Only suitable for RSA/RMSA. Method: 1. Go through action mask and find the first available slot on all paths. 2. For each path, allocate the first available slot. 3. Sum number of new consecutive zero regions (cuts) created by assignment (on each link) 4. Choose path that creates the fewest cuts.</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef kme_ff(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"K-Minimum Entropy. Only suitable for RSA/RMSA.\n    Method:\n    1. Go through action mask and find the first available slot on all paths.\n    2. For each path, allocate the first available slot.\n    3. Sum number of new consecutive zero regions (cuts) created by assignment (on each link)\n    4. Choose path that creates the fewest cuts.\n    \"\"\"\n    mask = get_action_mask(state, params)\n    first_slots = first_fit(state, params)\n    link_slot_array = jnp.where(state.link_slot_array &lt; 0, 1., state.link_slot_array)\n    nodes_sd, requested_bw = read_rsa_request(state.request_array)\n    max_entropy = jnp.sum(jnp.log(params.link_resources)) * params.num_links\n\n    def get_link_entropy(blocks):\n        ent = jax.vmap(lambda x: jnp.sum(x/params.link_resources * jnp.log(params.link_resources/x)), in_axes=0)(blocks)\n        return jnp.sum(jnp.where(blocks &gt; 0, ent, 0))\n\n    def get_entropy_on_path(i, result):\n        initial_slot_index = first_slots[i] % params.link_resources\n        path = get_paths(params, nodes_sd)[i]\n        se = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else 1\n        num_slots = required_slots(requested_bw, se, params.slot_size, guardband=params.guardband)\n        # Make link-slot_array positive\n        updated_slots = vmap_set_path_links(link_slot_array, path, initial_slot_index, num_slots, 1.)\n        updated_block_sizes = jax.vmap(find_block_sizes, in_axes=(0,))(updated_slots)\n        updated_entropy = jax.vmap(get_link_entropy, in_axes=(0,))(updated_block_sizes)\n        new_path_entropy = jnp.sum(jnp.dot(path, updated_entropy)).reshape((1,))\n        new_path_entropy = jax.lax.cond(\n            mask[i][initial_slot_index] == 0.,  # If true, no valid action for path\n            lambda x: max_entropy.astype(jnp.float32).reshape((1,)),  # Return maximum entropy\n            lambda x: new_path_entropy,  # Else, return number of cuts\n            1.\n        )\n        result = jax.lax.dynamic_update_slice(result, new_path_entropy, (i,))\n        return result\n\n    path_entropy_array = jnp.full((mask.shape[0],), 0.)\n    path_entropy_array = jax.lax.fori_loop(0, mask.shape[0], get_entropy_on_path, path_entropy_array)\n    path_index = jnp.argmin(path_entropy_array)\n    slot_index = first_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.kmf_ff","title":"<code>kmf_ff(state, params)</code>","text":"<p>K-Minimum Frag-size. Only suitable for RSA/RMSA. Method: 1. Go through action mask and find the first available slot on all paths. 2. For each path, allocate the first available slot. 3. Sum number of new consecutive zero regions (cuts) created by assignment (on each link) 4. Choose path that creates the fewest cuts.</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef kmf_ff(state: RSAEnvState, params: RSAEnvParams) -&gt; chex.Array:\n    \"\"\"K-Minimum Frag-size. Only suitable for RSA/RMSA.\n    Method:\n    1. Go through action mask and find the first available slot on all paths.\n    2. For each path, allocate the first available slot.\n    3. Sum number of new consecutive zero regions (cuts) created by assignment (on each link)\n    4. Choose path that creates the fewest cuts.\n    \"\"\"\n    mask = get_action_mask(state, params)\n    first_slots = first_fit(state, params)\n    link_slot_array = jnp.where(state.link_slot_array &lt; 0, 1., state.link_slot_array)\n    nodes_sd, requested_bw = read_rsa_request(state.request_array)\n    blocks = jax.vmap(find_block_sizes, in_axes=(0,))(link_slot_array)\n\n    def get_frags_on_path(i, result):\n        initial_slot_index = first_slots[i] % params.link_resources\n        path = get_paths(params, nodes_sd)[i]\n        se = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else 1\n        num_slots = required_slots(requested_bw, se, params.slot_size, guardband=params.guardband)\n        # Mask on path links\n        block_sizes = jax.vmap(lambda x, y: jnp.where(x &gt; 0, y, 0.), in_axes=(0, 0))(path, blocks)\n        updated_slots = vmap_set_path_links(state.link_slot_array, path, initial_slot_index, num_slots, -1)\n        updated_block_sizes = jax.vmap(find_block_sizes, in_axes=(0,))(updated_slots)\n        # Mask on path links\n        updated_block_sizes = jax.vmap(lambda x, y: jnp.where(x &gt; 0, y, 0.), in_axes=(0, 0))(path, updated_block_sizes)\n        difference = updated_block_sizes - block_sizes\n        new_frags = jnp.where(difference != 0, block_sizes + difference, 0.)\n        # Slice new frags up to initial slot index (so as to only consider frags to the left)\n        new_frags = jnp.where(jnp.arange(params.link_resources) &lt; initial_slot_index, new_frags, 0.)\n        new_frag_size = jnp.sum(new_frags)\n        num_frags = jax.lax.cond(\n            mask[i][initial_slot_index] == 0.,  # If true, no valid action for path\n            lambda x: jnp.full((1,), float(params.link_resources * params.num_links)),  # Return max frag size\n            lambda x: new_frag_size.reshape((1,)),\n            # Else, return number of cuts\n            1.\n        )\n        result = jax.lax.dynamic_update_slice(result, num_frags, (i,))\n        return result\n\n    # Initialise array to hold number of cuts on each path\n    path_frags_array = jnp.full((mask.shape[0],), 0.)\n    path_frags_array = jax.lax.fori_loop(0, mask.shape[0], get_frags_on_path, path_frags_array)\n    path_index = jnp.argmin(path_frags_array)\n    slot_index = first_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.ksp_bf","title":"<code>ksp_bf(state, params)</code>","text":"<p>Get the first available slot from all k-shortest paths Method: Go through action mask and find the first available slot, starting from shortest path</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef ksp_bf(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the first available slot from all k-shortest paths\n    Method: Go through action mask and find the first available slot, starting from shortest path\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    best_slots, fitness = best_fit(state, params)\n    # Chosen path is the first one with an available slot\n    path_index = jnp.argmin(jnp.where(fitness &lt; jnp.inf, 0, 1))\n    slot_index = best_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.ksp_ff","title":"<code>ksp_ff(state, params)</code>","text":"<p>Get the first available slot from the shortest available path Method: Go through action mask and find the first available slot, starting from shortest path</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef ksp_ff(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the first available slot from the shortest available path\n    Method: Go through action mask and find the first available slot, starting from shortest path\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    first_slots = first_fit(state, params)\n    # Chosen path is the first one with an available slot\n    path_index = jnp.argmax(first_slots &lt; params.link_resources)\n    slot_index = first_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.ksp_ff_multiband","title":"<code>ksp_ff_multiband(state, params)</code>","text":"<p>Get the first available slot from all k-shortest paths in multiband scenario Method: Go through action mask and find the first available slot, starting from shortest path</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>MultiBandRSAEnvState</code> <p>Environment state specific to multiband operations</p> required <code>params</code> <code>MultiBandRSAEnvParams</code> <p>Environment parameters including multiband details</p> required <p>Returns:     chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>def ksp_ff_multiband(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the first available slot from all k-shortest paths in multiband scenario\n    Method: Go through action mask and find the first available slot, starting from shortest path\n\n    Args:\n        state (MultiBandRSAEnvState): Environment state specific to multiband operations\n        params (MultiBandRSAEnvParams): Environment parameters including multiband details\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.ksp_lf","title":"<code>ksp_lf(state, params)</code>","text":"<p>Get the last available slot on the shortest available path Method: Go through action mask and find the last available slot, starting from shortest path</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef ksp_lf(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the last available slot on the shortest available path\n    Method: Go through action mask and find the last available slot, starting from shortest path\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    last_slots = last_fit(state, params)\n    # Chosen path is the first one with an available slot\n    path_index = jnp.argmax(last_slots &lt; params.link_resources)\n    slot_index = last_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.ksp_mu","title":"<code>ksp_mu(state, params, unique_lightpaths, relative)</code>","text":"<p>Get the most-used slot on the shortest available path. Method: Go through action mask and find the utilisation of available slots on each path. Find the shortest available path and choose the most utilised slot on that path.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>unique_lightpaths</code> <code>bool</code> <p>Whether to consider unique lightpaths</p> required <code>relative</code> <code>bool</code> <p>Whether to return relative utilisation</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2, 3))\ndef ksp_mu(state: EnvState, params: EnvParams, unique_lightpaths: bool, relative: bool) -&gt; chex.Array:\n    \"\"\"Get the most-used slot on the shortest available path.\n    Method: Go through action mask and find the utilisation of available slots on each path.\n    Find the shortest available path and choose the most utilised slot on that path.\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        unique_lightpaths (bool): Whether to consider unique lightpaths\n        relative (bool): Whether to return relative utilisation\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    mask = get_action_mask(state, params)\n    most_used_slots = most_used(state, params, unique_lightpaths, relative)\n    # Get usage of available slots\n    most_used_mask = most_used_slots * mask\n    # Get index of most-used available slot for each path\n    most_used_slots = jnp.argmax(most_used_mask, axis=1).astype(jnp.int32)\n    # Chosen path is the first one with an available slot\n    available_paths = jnp.max(mask, axis=1)\n    path_index = jnp.argmax(available_paths)\n    slot_index = most_used_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.last_fit","title":"<code>last_fit(state, params)</code>","text":"<p>Last-Fit Spectrum Allocation. Returns the last fit slot for each path.</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>def last_fit(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Last-Fit Spectrum Allocation. Returns the last fit slot for each path.\"\"\"\n    mask = get_action_mask(state, params)\n    # Add a column of ones to the mask to make sure that occupied paths have non-zero index in \"last_slots\"\n    mask = jnp.concatenate((jnp.full((mask.shape[0], 1), 1), mask), axis=1)\n    # Get index of last available slots for each path\n    last_slots = jnp.argmax(mask[:, ::-1], axis=1)\n    # Convert to index from the left\n    last_slots = params.link_resources - last_slots - 1\n    return last_slots\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.lf_ksp","title":"<code>lf_ksp(state, params)</code>","text":"<p>Get the last available slot from all paths Method: Go through action mask and find the last available slot on all paths</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef lf_ksp(state: EnvState, params: EnvParams) -&gt; chex.Array:\n    \"\"\"Get the last available slot from all paths\n    Method: Go through action mask and find the last available slot on all paths\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    last_slots = last_fit(state, params)\n    # Chosen path is the one with the highest index of last available slot\n    path_index = jnp.argmax(last_slots)\n    slot_index = last_slots[path_index] % params.link_resources\n    # Convert indices to action\n    action = path_index * params.link_resources + slot_index\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.make_graph","title":"<code>make_graph(topology_name='conus', topology_directory=None)</code>","text":"<p>Create graph from topology definition. Topologies must be defined in JSON format in the topologies directory and named as the topology name with .json extension.</p> <p>Parameters:</p> Name Type Description Default <code>topology_name</code> <code>str</code> <p>topology name</p> <code>'conus'</code> <code>topology_directory</code> <code>str</code> <p>topology directory</p> <code>None</code> <p>Returns:</p> Name Type Description <code>graph</code> <p>graph</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def make_graph(topology_name: str = \"conus\", topology_directory: str = None):\n    \"\"\"Create graph from topology definition.\n    Topologies must be defined in JSON format in the topologies directory and\n    named as the topology name with .json extension.\n\n    Args:\n        topology_name: topology name\n        topology_directory: topology directory\n\n    Returns:\n        graph: graph\n    \"\"\"\n    topology_path = pathlib.Path(topology_directory) if topology_directory else (\n            pathlib.Path(__file__).parents[1].absolute() / \"data\" / \"topologies\")\n    # Create topology\n    if topology_name == \"4node\":\n        # 4 node ring\n        graph = nx.from_numpy_array(np.array([[0, 1, 0, 1],\n                                            [1, 0, 1, 0],\n                                               [0, 1, 0, 1],\n                                               [1, 0, 1, 0]]))\n        # Add edge weights to graph\n        nx.set_edge_attributes(graph, {(0, 1): 4, (1, 2): 3, (2, 3): 2, (3, 0): 1}, \"weight\")\n    elif topology_name == \"7node\":\n        # 7 node ring\n        graph = nx.from_numpy_array(jnp.array([[0, 1, 0, 0, 0, 0, 1],\n                                               [1, 0, 1, 0, 0, 0, 0],\n                                               [0, 1, 0, 1, 0, 0, 0],\n                                               [0, 0, 1, 0, 1, 0, 0],\n                                               [0, 0, 0, 1, 0, 1, 0],\n                                               [0, 0, 0, 0, 1, 0, 1],\n                                               [1, 0, 0, 0, 0, 1, 0]]))\n        # Add edge weights to graph\n        nx.set_edge_attributes(graph, {(0, 1): 4, (1, 2): 3, (2, 3): 2, (3, 4): 1, (4, 5): 2, (5, 6): 3, (6, 0): 4}, \"weight\")\n    else:\n        with open(topology_path / f\"{topology_name}.json\") as f:\n            graph = nx.node_link_graph(json.load(f))\n    return graph\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.mask_nodes","title":"<code>mask_nodes(state, num_nodes)</code>","text":"<p>Returns mask of valid actions for node selection. 1 for valid action, 0 for invalid action.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>num_nodes</code> <code>Scalar</code> <p>Number of nodes</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_nodes(state: EnvState, num_nodes: chex.Scalar) -&gt; EnvState:\n    \"\"\"Returns mask of valid actions for node selection. 1 for valid action, 0 for invalid action.\n\n    Args:\n        state: Environment state\n        num_nodes: Number of nodes\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    total_actions = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.action_counter, 1, 1))\n    remaining_actions = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.action_counter, 2, 1))\n    full_request = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.request_array, 0, 1))\n    virtual_topology = jnp.squeeze(jax.lax.dynamic_slice_in_dim(state.request_array, 1, 1))\n    request = jax.lax.dynamic_slice_in_dim(full_request, (remaining_actions - 1) * 2, 3)\n    node_request_s = jax.lax.dynamic_slice_in_dim(request, 2, 1)\n    node_request_d = jax.lax.dynamic_slice_in_dim(request, 0, 1)\n    prev_action = jax.lax.dynamic_slice_in_dim(state.action_history, (remaining_actions) * 2, 3)\n    prev_dest = jax.lax.dynamic_slice_in_dim(prev_action, 0, 1)\n    node_indices = jnp.arange(0, num_nodes)\n    # Get requested indices from request array virtual topology\n    requested_indices = jax.lax.dynamic_slice_in_dim(virtual_topology, (remaining_actions-1)*2, 3)\n    requested_index_d = jax.lax.dynamic_slice_in_dim(requested_indices, 0, 1)\n    # Get index of previous selected node\n    prev_selected_node = jnp.where(virtual_topology == requested_index_d, state.action_history, jnp.full(virtual_topology.shape, -1))\n    # will be current index if node only occurs once in virtual topology or will be different index if occurs more than once\n    prev_selected_index = jnp.argmax(prev_selected_node).astype(MED_INT_DTYPE)\n    prev_selected_node_d = jax.lax.dynamic_slice_in_dim(state.action_history, prev_selected_index, 1)\n\n    # If first action, source and dest both to be assigned -&gt; just mask all nodes based on resources\n    # Thereafter, source must be previous dest. Dest can be any node (except previous allocations).\n    state = state.replace(\n        node_mask_s=jax.lax.cond(\n            jnp.equal(remaining_actions, total_actions),\n            lambda x: jnp.where(\n                state.node_capacity_array &gt;= node_request_s,\n                x,\n                jnp.zeros(num_nodes)\n            ),\n            lambda x: jnp.where(\n                node_indices == prev_dest,\n                x,\n                jnp.zeros(num_nodes)\n            ),\n            jnp.ones(num_nodes),\n        )\n    )\n    state = state.replace(\n        node_mask_d=jnp.where(\n            state.node_capacity_array &gt;= node_request_d,\n            jnp.ones(num_nodes),\n            jnp.zeros(num_nodes)\n        )\n    )\n    # If not first move, set node_mask_d to zero wherever node_mask_s is 1\n    # to avoid same node selection for s and d\n    state = state.replace(\n        node_mask_d=jax.lax.cond(\n            jnp.equal(remaining_actions, total_actions),\n            lambda x: x,\n            lambda x: jnp.where(\n                state.node_mask_s == 1,\n                jnp.zeros(num_nodes),\n                x\n            ),\n            state.node_mask_d,\n        )\n    )\n\n    def mask_previous_selections(i, val):\n        # Disallow previously allocated nodes\n        update_slice = lambda j, x: jax.lax.dynamic_update_slice_in_dim(x, jnp.array([0.]), j, axis=0)\n        val = jax.lax.cond(\n            i % 2 == 0,\n            lambda x: update_slice(x[0][i], x[1]),  # i is node request index\n            lambda x: update_slice(x[0][i+1], x[1]),  # i is slot request index (so add 1 to get next node)\n            (state.action_history, val),\n        )\n        return val\n\n    state = state.replace(\n        node_mask_d=jax.lax.fori_loop(\n            remaining_actions*2,\n            state.action_history.shape[0]-1,\n            mask_previous_selections,\n            state.node_mask_d\n        )\n    )\n    # If requested node index is new then disallow previously allocated nodes\n    # If not new, then must match previously allocated node for that index\n    state = state.replace(\n        node_mask_d=jax.lax.cond(\n            jnp.squeeze(prev_selected_node_d) &gt;= 0,\n            lambda x: jnp.where(\n                node_indices == prev_selected_node_d,\n                x[1],\n                x[0],\n            ),\n            lambda x: x[2],\n            (jnp.zeros(num_nodes), jnp.ones(num_nodes), state.node_mask_d),\n        )\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.mask_slots","title":"<code>mask_slots(state, params, request)</code>","text":"<p>Returns binary mask of valid actions. 1 for valid action, 0 for invalid action.</p> <ol> <li>Check request for source and destination nodes</li> <li>For each path:<ul> <li>Get current slots on path (with padding on end to avoid out of bounds)</li> <li>Get mask for required slots on path</li> <li>Multiply through current slots with required slots mask to check if slots available on path</li> <li>Remove padding from mask</li> <li>Return path mask</li> </ul> </li> <li>Update total mask with path mask</li> <li>If aggregate_slots &gt; 1, aggregate slot mask to reduce action space</li> </ol> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_slots(state: EnvState, params: EnvParams, request: chex.Array) -&gt; EnvState:\n    \"\"\"Returns binary mask of valid actions. 1 for valid action, 0 for invalid action.\n\n    1. Check request for source and destination nodes\n    2. For each path:\n        - Get current slots on path (with padding on end to avoid out of bounds)\n        - Get mask for required slots on path\n        - Multiply through current slots with required slots mask to check if slots available on path\n        - Remove padding from mask\n        - Return path mask\n    3. Update total mask with path mask\n    4. If aggregate_slots &gt; 1, aggregate slot mask to reduce action space\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_mask = jnp.zeros((params.link_resources * params.k_paths), dtype=LARGE_FLOAT_DTYPE)\n\n    def mask_path(i, mask):\n        # Get slots for path\n        slots = get_path_slots(state.link_slot_array, params, nodes_sd, i)\n        # Add padding to slots at end\n        slots = jnp.concatenate((slots, jnp.ones(params.max_slots, dtype=LARGE_FLOAT_DTYPE)))\n        # Convert bandwidth to slots for each path\n        spectral_efficiency = get_paths_se(params, nodes_sd)[i] if params.consider_modulation_format else one\n        requested_slots = required_slots(requested_datarate, spectral_efficiency, params.slot_size, guardband=params.guardband)\n        # Get mask used to check if request will fit slots\n        request_mask = get_request_mask(requested_slots[0], params)\n\n        def check_slots_available(j, val):\n            # Multiply through by request mask to check if slots available\n            request_slice = jax.lax.dynamic_slice(val, (j,), (params.max_slots,))\n            slot_sum = jnp.sum(request_mask * request_slice, promote_integers=False) &lt;= zero\n            slot_sum = slot_sum.reshape((1,)).astype(LARGE_FLOAT_DTYPE)\n            return jax.lax.dynamic_update_slice(val, slot_sum, (j,))\n\n        # Mask out slots that are not valid\n        path_mask = jax.lax.fori_loop(\n            0,\n            int(params.link_resources+1),  # No need to check last requested_slots-1 slots\n            check_slots_available,\n            slots,\n        )\n        # Cut off padding\n        path_mask = jax.lax.dynamic_slice(path_mask, (0,), (params.link_resources,))\n        # Update total mask with path mask\n        mask = jax.lax.dynamic_update_slice(mask, path_mask, (i * params.link_resources,))\n        return mask\n\n    # Loop over each path\n    link_slot_mask = jax.lax.fori_loop(0, params.k_paths, mask_path, init_mask)\n    if params.aggregate_slots &gt; 1:\n        # Full link slot mask is used in process_path_action to get the correct slot from the aggregated slot action\n        state = state.replace(full_link_slot_mask=link_slot_mask)\n        link_slot_mask, _ = aggregate_slots(link_slot_mask.reshape(params.k_paths, -1), params)\n        link_slot_mask = link_slot_mask.reshape(-1)\n    state = state.replace(link_slot_mask=link_slot_mask)\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.mask_slots_rmsa_gn_model","title":"<code>mask_slots_rmsa_gn_model(state, params, request)</code>","text":"<p>For use in RSAGNModelEnv. 1. For each path:     1.1 Get path slots     1.2 Get launch power</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>RSAGNModelEnvState</code> <p>Environment state</p> required <code>params</code> <code>RSAGNModelEnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_slots_rmsa_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams, request: chex.Array) -&gt; EnvState:\n    \"\"\"For use in RSAGNModelEnv.\n    1. For each path:\n        1.1 Get path slots\n        1.2 Get launch power\n\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_mask = jnp.zeros((params.link_resources * params.k_paths))\n\n    def mask_path(i, mask):\n        path = get_paths(params, nodes_sd)[i]\n        # Get slots for path\n        slots = get_path_slots(state.link_slot_array, params, nodes_sd, i)\n        # Add padding to slots at end\n        # 0 means slot is free, 1 is occupied\n        slots = jnp.concatenate((slots, jnp.ones(params.max_slots)))\n        launch_power = get_launch_power(state, i, state.launch_power_array[i], params)\n        lightpath_index = get_lightpath_index(params, nodes_sd, i)\n\n        # This function checks through each available modulation format, checks the first and last available slots,\n        # calculates the SNR, checks it meets the requirements, and returns the resulting mask\n        def check_modulation_format(mod_format_index, init_path_mask):\n            se = params.modulations_array.val[mod_format_index][1]\n            req_slots = required_slots(requested_datarate, se, params.slot_size, guardband=params.guardband)[0]\n            bandwidth_per_subchannel = params.slot_size\n            req_snr = params.modulations_array.val[mod_format_index][2] + params.snr_margin\n            # Get mask used to check if request will fit slots\n            request_mask = get_request_mask(req_slots, params)\n\n            def check_slots_available(j, val):\n                # Multiply through by request mask to check if slots available\n                slot_sum = jnp.sum(request_mask * jax.lax.dynamic_slice(val, (j,), (params.max_slots,)), promote_integers=False) &lt;= 0\n                slot_sum = slot_sum.reshape((1,)).astype(LARGE_FLOAT_DTYPE)\n                return jax.lax.dynamic_update_slice(val, slot_sum, (j,))\n\n            # Mask out slots that are not valid\n            slot_mask = jax.lax.fori_loop(\n                0,\n                int(params.link_resources + 1),  # No need to check last requested_slots-1 slots\n                check_slots_available,\n                slots,\n            )\n            # Cut off padding\n            slot_mask = jax.lax.dynamic_slice(slot_mask, (0,), (params.link_resources,))\n            # Check first and last available slots for suitability\n            ff_path_mask = jnp.concatenate((slot_mask, jnp.ones((1,))), axis=0)\n            lf_path_mask = jnp.concatenate((jnp.ones((1,)), slot_mask), axis=0)\n            first_available_slot_index = jnp.argmax(ff_path_mask)\n            last_available_slot_index = params.link_resources - jnp.argmax(jnp.flip(lf_path_mask)) - 1\n            # Assign \"req_slots\" subchannels (each with bandwidth = slot width) for the first and last possible slots\n            ff_temp_state = state.replace(\n                channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, first_available_slot_index, req_slots, bandwidth_per_subchannel),\n                channel_power_array=vmap_set_path_links(state.channel_power_array, path, first_available_slot_index, req_slots, launch_power),\n                path_index_array=vmap_set_path_links(state.path_index_array, path, first_available_slot_index, req_slots, lightpath_index),\n                modulation_format_index_array=vmap_set_path_links(state.modulation_format_index_array, path, first_available_slot_index, req_slots, mod_format_index),\n            )\n            lf_temp_state = state.replace(\n                channel_centre_bw_array=vmap_set_path_links(state.channel_centre_bw_array, path, last_available_slot_index, req_slots, bandwidth_per_subchannel),\n                channel_power_array=vmap_set_path_links(state.channel_power_array, path, last_available_slot_index, req_slots, launch_power),\n                path_index_array=vmap_set_path_links(state.path_index_array, path, last_available_slot_index, req_slots, lightpath_index),\n                modulation_format_index_array=vmap_set_path_links(state.modulation_format_index_array, path, last_available_slot_index, req_slots, mod_format_index),\n            )\n            ff_temp_state = ff_temp_state.replace(link_snr_array=get_snr_link_array(ff_temp_state, params))\n            lf_temp_state = lf_temp_state.replace(link_snr_array=get_snr_link_array(lf_temp_state, params))\n            # Take the minimum value of SNR from all the subchannels\n            ff_snr_value = get_minimum_snr_of_channels_on_path(\n                ff_temp_state, path, first_available_slot_index, req_slots, params\n            )\n            lf_snr_value = get_minimum_snr_of_channels_on_path(\n                lf_temp_state, path, last_available_slot_index, req_slots, params\n            )\n            # Check that other paths SNR is still sufficient (True if failure)\n            ff_snr_check = 1 - check_action_rmsa_gn_model(ff_temp_state, None, params)\n            lf_snr_check = 1 - check_action_rmsa_gn_model(lf_temp_state, None, params)\n            ff_check = (ff_snr_value &gt;= req_snr) * ff_snr_check\n            lf_check = (lf_snr_value &gt;= req_snr) * lf_snr_check\n\n            slot_indices = jnp.arange(params.link_resources, dtype=MED_INT_DTYPE)\n            mod_format_mask = jnp.where(slot_indices == first_available_slot_index, ff_check, False)\n            mod_format_mask = jnp.where(slot_indices == last_available_slot_index, lf_check, mod_format_mask)\n            path_mask = jnp.where(mod_format_mask, mod_format_index, init_path_mask)\n            # jax.debug.print(\"ff_snr_check {}\", ff_snr_check, ordered=True)\n            # jax.debug.print(\"lf_snr_check {}\", lf_snr_check, ordered=True)\n            # jax.debug.print(\"ff_snr_value {}\", ff_snr_value, ordered=True)\n            # jax.debug.print(\"lf_snr_value {}\", lf_snr_value, ordered=True)\n            # jax.debug.print(\"first_available_slot_index {}\", first_available_slot_index, ordered=True)\n            # jax.debug.print(\"last_available_slot_index {}\", last_available_slot_index, ordered=True)\n            # jax.debug.print(\"req_snr {}\", req_snr, ordered=True)\n            # jax.debug.print(\"mod_format_mask {}\", mod_format_mask, ordered=True)\n            # jax.debug.print(\"path_mask {}\", path_mask, ordered=True)\n            return path_mask\n\n        path_mask = jax.lax.fori_loop(0, params.modulations_array.val.shape[0], check_modulation_format, jnp.full((params.link_resources,), -1., dtype=LARGE_FLOAT_DTYPE))\n\n        # Update total mask with path mask\n        mask = jax.lax.dynamic_update_slice(mask, path_mask, (i * params.link_resources,))\n        return mask\n\n    # Loop over each path\n    mod_format_mask = jax.lax.fori_loop(0, params.k_paths, mask_path, init_mask)\n    link_slot_mask = jnp.where(mod_format_mask &gt;= 0, 1.0, 0.0)\n    if params.aggregate_slots &gt; 1:\n        # Full link slot mask is used in process_path_action to get the correct slot from the aggregated slot action\n        state = state.replace(full_link_slot_mask=link_slot_mask)\n        link_slot_mask, _ = aggregate_slots(link_slot_mask.reshape(params.k_paths, -1), params)\n        link_slot_mask = link_slot_mask.reshape(-1)\n    state = state.replace(\n        link_slot_mask=link_slot_mask,\n        mod_format_mask=mod_format_mask,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.mask_slots_rwalr","title":"<code>mask_slots_rwalr(state, params, request)</code>","text":"<p>For use in RWALightpathReuseEnv. Each lightpath has a maximum capacity defined in path_capacity_array. This is updated when a lightpath is assigned. If remaining path capacity is less than current request, corresponding link-slots are masked out. If link-slot is in use by another lightpath for a different source and destination node (even if not full) it is masked out. Step 1: - Mask out slots that are not valid based on path capacity (check link_capacity_array) Step 2: - Mask out slots that are not valid based on lightpath reuse (check path_index_array)</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>request</code> <code>Array</code> <p>Request array in format [source_node, data-rate, destination_node]</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef mask_slots_rwalr(state: EnvState, params: EnvParams, request: chex.Array) -&gt; EnvState:\n    \"\"\"For use in RWALightpathReuseEnv.\n    Each lightpath has a maximum capacity defined in path_capacity_array. This is updated when a lightpath is assigned.\n    If remaining path capacity is less than current request, corresponding link-slots are masked out.\n    If link-slot is in use by another lightpath for a different source and destination node (even if not full) it is masked out.\n    Step 1:\n    - Mask out slots that are not valid based on path capacity (check link_capacity_array)\n    Step 2:\n    - Mask out slots that are not valid based on lightpath reuse (check path_index_array)\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n        request: Request array in format [source_node, data-rate, destination_node]\n\n    Returns:\n        state: Updated environment state\n    \"\"\"\n    nodes_sd, requested_datarate = read_rsa_request(request)\n    init_mask = jnp.zeros((params.link_resources * params.k_paths))\n    source, dest = nodes_sd\n    path_start_index = get_path_indices(source, dest, params.k_paths, params.num_nodes, directed=params.directed_graph)\n    #jax.debug.print(\"path_start_index {}\", path_start_index, ordered=True)\n    #jax.debug.print(\"link_capacity_array {}\", state.link_capacity_array, ordered=True)\n\n    def mask_path(i, mask):\n        # Step 1 - mask capacity\n        capacity_mask = jnp.where(state.link_capacity_array &lt; requested_datarate, 1., 0.)\n        #jax.debug.print(\"capacity_mask {}\", capacity_mask, ordered=True)\n        capacity_slots = get_path_slots(capacity_mask, params, nodes_sd, i)\n        #jax.debug.print(\"capacity_slots {}\", capacity_slots, ordered=True)\n        # Step 2 - mask lightpath reuse\n        lightpath_index = path_start_index + i\n        #jax.debug.print(\"lightpath_index {}\", lightpath_index, ordered=True)\n        lightpath_mask = jnp.where(state.path_index_array == lightpath_index, 0., 1.)  # Allow current lightpath\n        #jax.debug.print(\"lightpath_mask {}\", lightpath_mask, ordered=True)\n        lightpath_mask = jnp.where(state.path_index_array == -1, 0., lightpath_mask)  # Allow empty slots\n        #jax.debug.print(\"lightpath_mask {}\", lightpath_mask, ordered=True)\n        lightpath_slots = get_path_slots(lightpath_mask, params, nodes_sd, i)\n        #jax.debug.print(\"lightpath_slots {}\", lightpath_slots, ordered=True)\n        # Step 3 combine masks\n        path_mask = jnp.max(jnp.stack((capacity_slots, lightpath_slots)), axis=0)\n        # Swap zeros for ones\n        path_mask = jnp.where(path_mask == 0, 1., 0.)\n        #jax.debug.print(\"path_mask {}\", path_mask, ordered=True)\n        mask = jax.lax.dynamic_update_slice(mask, path_mask, (i * params.link_resources,))\n        return mask\n\n    # Loop over each path\n    link_slot_mask = jax.lax.fori_loop(0, params.k_paths, mask_path, init_mask)\n    if params.aggregate_slots &gt; 1:\n        # Full link slot mask is used in process_path_action to get the correct slot from the aggregated slot action\n        state = state.replace(full_link_slot_mask=link_slot_mask)\n        link_slot_mask, _ = aggregate_slots(link_slot_mask.reshape(params.k_paths, -1), params)\n        link_slot_mask = link_slot_mask.reshape(-1)\n    state = state.replace(link_slot_mask=link_slot_mask)\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.most_used","title":"<code>most_used(state, params, unique_lightpaths, relative)</code>","text":"<p>Get the amount of utilised bandwidth on each lightpath. If RWA-LR environment, the utilisation of a slot is defined by either the count of unique active lightpahts on the slot (if unique_lightpaths is True) or the count of active lightpaths on the slot (if unique_lightpaths is False). If RSA-type environment, utilisation is the count of active lightpaths on that slot.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>unique_lightpaths</code> <code>bool</code> <p>Whether to consider unique lightpaths</p> required <code>relative</code> <code>bool</code> <p>Whether to return relative utilisation</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Most used slots (array length = link_resources)</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2, 3))\ndef most_used(state: EnvState, params: EnvParams, unique_lightpaths, relative) -&gt; chex.Array:\n    \"\"\"Get the amount of utilised bandwidth on each lightpath.\n    If RWA-LR environment, the utilisation of a slot is defined by either the count of unique active lightpahts on the\n    slot (if unique_lightpaths is True) or the count of active lightpaths on the slot (if unique_lightpaths is False).\n    If RSA-type environment, utilisation is the count of active lightpaths on that slot.\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        unique_lightpaths (bool): Whether to consider unique lightpaths\n        relative (bool): Whether to return relative utilisation\n\n    Returns:\n        chex.Array: Most used slots (array length = link_resources)\n    \"\"\"\n    if params.__class__.__name__ != \"RWALightpathReuseEnvParams\":\n        most_used_slots = jnp.count_nonzero(state.link_slot_array, axis=0) + 1\n    elif params.__class__.__name__ == \"RWALightpathReuseEnvParams\" and not unique_lightpaths:\n        # Get initial path capacity\n        initial_path_capacity = init_path_capacity_array(\n            params.link_length_array.val, params.path_link_array.val, scale_factor=1.0\n        )\n        initial_path_capacity = jnp.squeeze(jax.vmap(lambda x: initial_path_capacity[x])(state.path_index_array))\n        utilisation = jnp.where(initial_path_capacity - state.link_capacity_array &lt; 0, 0,\n                                initial_path_capacity - state.link_capacity_array)\n        if relative:\n            utilisation = utilisation / initial_path_capacity\n        # Get most used slots by summing the utilisation along the slots\n        most_used_slots = jnp.sum(utilisation, axis=0) + 1\n    else:\n        most_used_slots = jnp.count_nonzero(state.path_index_array + 1, axis=0) + 1\n    return most_used_slots\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.mu_ksp","title":"<code>mu_ksp(state, params, unique_lightpaths, relative)</code>","text":"<p>Use the most-used available slot on any path. The most-used slot is that which has the most unique lightpaths (if unique_lightpaths=True) or active lightpaths. Method: Go through action mask and find the usage of available slots, choose available slot that is most utilised.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>EnvParams</code> <p>Environment parameters</p> required <code>unique_lightpaths</code> <code>bool</code> <p>Whether to consider unique lightpaths</p> required <code>relative</code> <code>bool</code> <p>Whether to return relative utilisation</p> required <p>Returns:</p> Type Description <code>Array</code> <p>chex.Array: Action</p> Source code in <code>xlron/heuristics/heuristics.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2, 3))\ndef mu_ksp(state: EnvState, params: EnvParams, unique_lightpaths: bool, relative: bool) -&gt; chex.Array:\n    \"\"\"Use the most-used available slot on any path.\n    The most-used slot is that which has the most unique lightpaths (if unique_lightpaths=True) or active lightpaths.\n    Method: Go through action mask and find the usage of available slots, choose available slot that is most utilised.\n\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n        unique_lightpaths (bool): Whether to consider unique lightpaths\n        relative (bool): Whether to return relative utilisation\n\n    Returns:\n        chex.Array: Action\n    \"\"\"\n    mask = get_action_mask(state, params)\n    # Get most used slots by summing the link_slot_array along the links\n    most_used_slots = most_used(state, params, unique_lightpaths, relative)\n    # Get usage of available slots\n    most_used_mask = most_used_slots * mask\n    # Chosen slot is the most used globally\n    action = jnp.argmax(most_used_mask)\n    return action\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.normalise_traffic_matrix","title":"<code>normalise_traffic_matrix(traffic_matrix)</code>","text":"<p>Normalise traffic matrix to sum to 1</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def normalise_traffic_matrix(traffic_matrix):\n    \"\"\"Normalise traffic matrix to sum to 1\"\"\"\n    traffic_matrix /= jnp.sum(traffic_matrix, promote_integers=False)\n    return traffic_matrix\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.pad_array","title":"<code>pad_array(array, fill_value)</code>","text":"<p>Pad a ragged multidimensional array to rectangular shape. Used for training on multiple topologies. Source: https://codereview.stackexchange.com/questions/222623/pad-a-ragged-multidimensional-array-to-rectangular-shape</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <p>array to pad</p> required <code>fill_value</code> <p>value to fill with</p> required <p>Returns:</p> Name Type Description <code>result</code> <p>padded array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def pad_array(array, fill_value):\n    \"\"\"\n    Pad a ragged multidimensional array to rectangular shape.\n    Used for training on multiple topologies.\n    Source: https://codereview.stackexchange.com/questions/222623/pad-a-ragged-multidimensional-array-to-rectangular-shape\n\n    Args:\n        array: array to pad\n        fill_value: value to fill with\n\n    Returns:\n        result: padded array\n    \"\"\"\n\n    def get_dimensions(array, level=0):\n        yield level, len(array)\n        try:\n            for row in array:\n                yield from get_dimensions(row, level + 1)\n        except TypeError: #not an iterable\n            pass\n\n    def get_max_shape(array):\n        dimensions = defaultdict(int)\n        for level, length in get_dimensions(array):\n            dimensions[level] = max(dimensions[level], length)\n        return [value for _, value in sorted(dimensions.items())]\n\n    def iterate_nested_array(array, index=()):\n        try:\n            for idx, row in enumerate(array):\n                yield from iterate_nested_array(row, (*index, idx))\n        except TypeError: # final level\n            yield (*index, slice(len(array))), array\n\n    dimensions = get_max_shape(array)\n    result = np.full(dimensions, fill_value)\n    for index, value in iterate_nested_array(array):\n        result[index] = value\n    return result\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.path_action_only","title":"<code>path_action_only(topology_pattern, action_counter, remaining_actions)</code>","text":"<p>This is to check if node has already been assigned, therefore just need to assign slots (n=0)</p> <p>Parameters:</p> Name Type Description Default <code>topology_pattern</code> <code>Array</code> <p>Topology pattern</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>remaining_actions</code> <code>Scalar</code> <p>Remaining actions</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if only path action, False if node action</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def path_action_only(topology_pattern: chex.Array, action_counter: chex.Array, remaining_actions: chex.Scalar):\n    \"\"\"This is to check if node has already been assigned, therefore just need to assign slots (n=0)\n\n    Args:\n        topology_pattern: Topology pattern\n        action_counter: Action counter\n        remaining_actions: Remaining actions\n\n    Returns:\n        bool: True if only path action, False if node action\n    \"\"\"\n    # Get topology segment to be assigned e.g. [2,1,4]\n    topology_segment = jax.lax.dynamic_slice(topology_pattern, ((remaining_actions-1)*2, ), (3, ))\n    topology_indices = jnp.arange(topology_pattern.shape[0])\n    # Check if the latest node in the segment is found in \"prev_assigned_topology\"\n    new_node_to_be_assigned = topology_segment[0]\n    prev_assigned_topology = jnp.where(topology_indices &gt; (action_counter[-1]-1)*2, topology_pattern, 0)\n    nodes_already_assigned_check = jnp.any(jnp.sum(jnp.where(prev_assigned_topology == new_node_to_be_assigned, 1, 0)) &gt; 0)\n    return nodes_already_assigned_check\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.poisson","title":"<code>poisson(key, lam, shape=(), dtype=dtypes.float_)</code>","text":"<p>Sample Exponential random values with given shape and float dtype.</p> <p>The values are distributed according to the probability density function:</p> <p>.. math::  f(x) = \\lambda e^{-\\lambda x}</p> <p>on the domain :math:<code>0 \\le x &lt; \\infty</code>.</p> <p>Args: key: a PRNG key used as the random key. lam: a positive float32 or float64 <code>Tensor</code> indicating the rate parameter shape: optional, a tuple of nonnegative integers representing the result   shape. Default (). dtype: optional, a float dtype for the returned values (default float64 if   jax_enable_x64 is true, otherwise float32).</p> <p>Returns: A random array with the specified shape and dtype.</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2, 3))\ndef poisson(key: Union[Array, prng.PRNGKeyArray],\n            lam: ArrayLike,\n            shape: Shape = (),\n            dtype: DTypeLike = dtypes.float_) -&gt; Array:\n    r\"\"\"Sample Exponential random values with given shape and float dtype.\n\n    The values are distributed according to the probability density function:\n\n    .. math::\n     f(x) = \\lambda e^{-\\lambda x}\n\n    on the domain :math:`0 \\le x &lt; \\infty`.\n\n    Args:\n    key: a PRNG key used as the random key.\n    lam: a positive float32 or float64 `Tensor` indicating the rate parameter\n    shape: optional, a tuple of nonnegative integers representing the result\n      shape. Default ().\n    dtype: optional, a float dtype for the returned values (default float64 if\n      jax_enable_x64 is true, otherwise float32).\n\n    Returns:\n    A random array with the specified shape and dtype.\n    \"\"\"\n    key, _ = jax._src.random._check_prng_key(key)\n    if not dtypes.issubdtype(dtype, np.floating):\n        raise ValueError(f\"dtype argument to `exponential` must be a float \"\n                       f\"dtype, got {dtype}\")\n    dtype = dtypes.canonicalize_dtype(dtype)\n    shape = core.canonicalize_shape(shape)\n    return _poisson(key, lam, shape, dtype)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.process_path_action","title":"<code>process_path_action(state, params, path_action)</code>","text":"<p>Process path action to get path index and initial slot index.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>current state</p> required <code>params</code> <code>Params</code> <p>environment parameters</p> required <code>path_action</code> <code>int</code> <p>path action</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>(Array, Array)</code> <p>path index</p> <code>int</code> <code>(Array, Array)</code> <p>initial slot index</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef process_path_action(state: EnvState, params: EnvParams, path_action: chex.Array) -&gt; (chex.Array, chex.Array):\n    \"\"\"Process path action to get path index and initial slot index.\n\n    Args:\n        state (State): current state\n        params (Params): environment parameters\n        path_action (int): path action\n\n    Returns:\n        int: path index\n        int: initial slot index\n    \"\"\"\n    num_slot_actions = math.ceil(params.link_resources/params.aggregate_slots)\n    path_index = jnp.floor(path_action / num_slot_actions).astype(LARGE_INT_DTYPE).reshape(1)\n    initial_aggregated_slot_index = jnp.mod(path_action, num_slot_actions).reshape(1)\n    initial_slot_index = initial_aggregated_slot_index*params.aggregate_slots\n    if params.aggregate_slots &gt; 1:\n        # Get the path mask do a dynamic slice and get the index of first unoccupied slot in the slice\n        path_mask = jax.lax.dynamic_slice(state.full_link_slot_mask, path_index*params.link_resources, (params.link_resources,))\n        path_mask_slice = jax.lax.dynamic_slice(path_mask, initial_slot_index, (params.aggregate_slots,))\n        # Use argmax to get index of first 1 in slice of mask\n        initial_slot_index = initial_slot_index + jnp.argmax(path_mask_slice).astype(MED_INT_DTYPE)\n    return path_index[0], initial_slot_index[0]\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.read_rsa_request","title":"<code>read_rsa_request(request_array)</code>","text":"<p>Read RSA request from request array. Return source-destination nodes and bandwidth request.</p> <p>Parameters:</p> Name Type Description Default <code>request_array</code> <code>Array</code> <p>request array</p> required <p>Returns:</p> Type Description <code>Tuple[Array, Array]</code> <p>Tuple[chex.Array, chex.Array]: source-destination nodes and bandwidth request</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def read_rsa_request(request_array: chex.Array) -&gt; Tuple[chex.Array, chex.Array]:\n    \"\"\"Read RSA request from request array. Return source-destination nodes and bandwidth request.\n\n    Args:\n        request_array: request array\n\n    Returns:\n        Tuple[chex.Array, chex.Array]: source-destination nodes and bandwidth request\n    \"\"\"\n    node_s = jax.lax.dynamic_slice(request_array, (0,), (1,))\n    requested_datarate = jax.lax.dynamic_slice(request_array, (1,), (1,))\n    node_d = jax.lax.dynamic_slice(request_array, (2,), (1,))\n    nodes_sd = jnp.concatenate((node_s, node_d))\n    return nodes_sd, requested_datarate\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.remove_expired_node_requests","title":"<code>remove_expired_node_requests(state, params)</code>","text":"<p>Check for values in node_departure_array that are less than the current time but greater than zero (negative time indicates the request is not yet finalised). If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase node_capacity_array by expired resources on each node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_node_requests(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"Check for values in node_departure_array that are less than the current time but greater than zero\n    (negative time indicates the request is not yet finalised).\n    If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase\n    node_capacity_array by expired resources on each node.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    mask = jnp.where(state.node_departure_array &lt; jnp.squeeze(state.current_time), 1, 0)\n    mask = jnp.where(0 &lt; state.node_departure_array, mask, 0)\n    expired_resources = jnp.sum(jnp.where(mask == 1, state.node_resource_array, 0), axis=1, promote_integers=False)\n    state = state.replace(\n        node_capacity_array=state.node_capacity_array + expired_resources,\n        node_resource_array=jnp.where(mask == 1, 0, state.node_resource_array),\n        node_departure_array=jnp.where(mask == 1, jnp.inf, state.node_departure_array)\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.remove_expired_services_rmsa_gn_model","title":"<code>remove_expired_services_rmsa_gn_model(state, params)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rmsa_gn_model(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                      state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                      updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=jnp.where(mask_remove == one, zero, state.link_slot_array),\n        link_slot_departure_array=updated_link_slot_departure_array,\n        link_snr_array=jnp.where(mask_remove == one, zero, state.link_snr_array),\n        path_index_array=jnp.where(mask_remove == one, -one, state.path_index_array),\n        channel_centre_bw_array=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array),\n        channel_power_array=jnp.where(mask_remove == one, zero, state.channel_power_array),\n        modulation_format_index_array=jnp.where(mask_remove == one, -one, state.modulation_format_index_array),\n        path_index_array_prev=jnp.where(mask_remove == one, -one, state.path_index_array_prev),\n        channel_centre_bw_array_prev=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array_prev),\n        channel_power_array_prev=jnp.where(mask_remove == one, zero, state.channel_power_array_prev),\n        modulation_format_index_array_prev=jnp.where(mask_remove == one, -one, state.modulation_format_index_array_prev),\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.remove_expired_services_rsa","title":"<code>remove_expired_services_rsa(state, params)</code>","text":"<p>Check for values in link_slot_departure_array that are less than the current time but greater than zero (negative time indicates the request is not yet finalised). If found, set to zero in link_slot_array and link_slot_departure_array.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rsa(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"Check for values in link_slot_departure_array that are less than the current time but greater than zero\n    (negative time indicates the request is not yet finalised).\n    If found, set to zero in link_slot_array and link_slot_departure_array.\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_array = jnp.where(mask_remove == one, zero, state.link_slot_array)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                     state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                     updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=updated_link_slot_array,\n        link_slot_departure_array=updated_link_slot_departure_array,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.remove_expired_services_rsa_gn_model","title":"<code>remove_expired_services_rsa_gn_model(state, params)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rsa_gn_model(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                      state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                      updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=jnp.where(mask_remove == one, zero, state.link_slot_array),\n        link_slot_departure_array=updated_link_slot_departure_array,\n        link_snr_array=jnp.where(mask_remove == one, zero, state.link_snr_array),\n        path_index_array=jnp.where(mask_remove == one, -one, state.path_index_array),\n        channel_centre_bw_array=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array),\n        channel_power_array=jnp.where(mask_remove == one, zero, state.channel_power_array),\n        path_index_array_prev=jnp.where(mask_remove == one, -one, state.path_index_array_prev),\n        channel_centre_bw_array_prev=jnp.where(mask_remove == one, zero, state.channel_centre_bw_array_prev),\n        channel_power_array_prev=jnp.where(mask_remove == one, zero, state.channel_power_array_prev),\n    )\n    if params.monitor_active_lightpaths:\n        # The active_lightpaths_array is set to -1 when the lightpath is not active\n        # The active_lightpaths_array_departure is set to 0 when the lightpath is not active\n        # (active_lightpaths_array is used to calculate the total throughput)\n        mask_remove = jnp.where(\n            (zero &lt;= state.active_lightpaths_array_departure) &amp; (state.active_lightpaths_array_departure &lt;= jnp.squeeze(current_time)),\n            one, zero)\n        state = state.replace(\n            active_lightpaths_array=jnp.where(mask_remove == one, -one, state.active_lightpaths_array),\n            active_lightpaths_array_departure=jnp.where(mask_remove == one, zero, state.active_lightpaths_array_departure),\n        )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.remove_expired_services_rwalr","title":"<code>remove_expired_services_rwalr(state, params)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <code>params</code> <code>Optional[EnvParams]</code> <p>Environment parameters</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef remove_expired_services_rwalr(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"\n\n    Args:\n        state: Environment state\n        params: Environment parameters\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # Set one where link_slot_departure_array is &gt;= zero and &lt;= current time\n    current_time = state.current_time if not params.relative_arrival_times else state.arrival_time\n    mask_remove = jnp.where(\n        (zero &lt;= state.link_slot_departure_array) &amp; (state.link_slot_departure_array &lt;= jnp.squeeze(current_time)),\n        one, zero)\n    updated_link_slot_departure_array = jnp.where(mask_remove == one, zero, state.link_slot_departure_array)\n    if params.relative_arrival_times:\n        mask_subtract = jnp.where(updated_link_slot_departure_array &lt;= zero, zero, one)\n        updated_link_slot_departure_array = jnp.where(mask_subtract == one,\n                                                     state.link_slot_departure_array - jnp.squeeze(current_time),\n                                                     updated_link_slot_departure_array)\n    state = state.replace(\n        link_slot_array=jnp.where(mask_remove == one, zero, state.link_slot_array),\n        path_index_array=jnp.where(mask_remove == one, -one, state.path_index_array),\n        link_slot_departure_array=updated_link_slot_departure_array,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.required_slots","title":"<code>required_slots(bitrate, se, channel_width, guardband=1)</code>","text":"<p>Calculate required slots for a given bitrate and spectral efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>bit_rate</code> <code>float</code> <p>Bit rate in Gbps</p> required <code>se</code> <code>float</code> <p>Spectral efficiency in bps/Hz</p> required <code>channel_width</code> <code>float</code> <p>Channel width in GHz</p> required <code>guardband</code> <code>int</code> <p>Guard band. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>int</code> <code>Array</code> <p>Required slots</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(2, 3))\ndef required_slots(bitrate: float, se: int, channel_width: float, guardband: int = 1) -&gt; chex.Array:\n    \"\"\"Calculate required slots for a given bitrate and spectral efficiency.\n\n    Args:\n        bit_rate (float): Bit rate in Gbps\n        se (float): Spectral efficiency in bps/Hz\n        channel_width (float): Channel width in GHz\n        guardband (int, optional): Guard band. Defaults to 1.\n\n    Returns:\n        int: Required slots\n    \"\"\"\n    # If bitrate is zero, then required slots should be zero\n    return ((jnp.ceil(bitrate/(se*channel_width))+guardband) * (one - (bitrate == zero))).astype(MED_INT_DTYPE)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.set_band_gaps","title":"<code>set_band_gaps(link_slot_array, params, val)</code>","text":"<p>Set band gaps in link slot array Args:     link_slot_array (chex.Array): Link slot array     params (RSAGNModelEnvParams): Environment parameters     val (int): Value to set Returns:     chex.Array: Link slot array with band gaps</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1, 2))\ndef set_band_gaps(link_slot_array: chex.Array, params: RSAGNModelEnvParams, val: int) -&gt; chex.Array:\n    \"\"\"Set band gaps in link slot array\n    Args:\n        link_slot_array (chex.Array): Link slot array\n        params (RSAGNModelEnvParams): Environment parameters\n        val (int): Value to set\n    Returns:\n        chex.Array: Link slot array with band gaps\n    \"\"\"\n    # Create array that is size of link_slot array with values of column index\n    mask = jnp.arange(params.link_resources)\n    mask = jnp.tile(mask, (params.num_links, 1))\n    def set_band_gap(i, arr):\n        gap_start = params.gap_starts.val[i]\n        gap_end = gap_start + params.gap_widths.val[i]\n        condition = jnp.logical_and(arr &gt;= gap_start, arr &lt; gap_end)\n        arr = jnp.where(condition, -one, arr)\n        return arr\n    mask = jax.lax.fori_loop(0, params.gap_widths.val.shape[0], set_band_gap, mask)\n    link_slot_array = jnp.where(mask == -one, val, link_slot_array)\n    return link_slot_array\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.undo_action_rmsa_gn_model","title":"<code>undo_action_rmsa_gn_model(state, params)</code>","text":"<p>Undo action for RMSA GN model Args:     state (EnvState): Environment state     action (chex.Array): Action array     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef undo_action_rmsa_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; EnvState:\n    \"\"\"Undo action for RMSA GN model\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action array\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    state = undo_action_rsa(state, params)  # Undo link_slot_array and link_slot_departure_array\n    state = state.replace(\n        link_slot_array=set_band_gaps(state.link_slot_array, params, -one),  # Set C+L band gap\n        channel_centre_bw_array=state.channel_centre_bw_array_prev,\n        path_index_array=state.path_index_array_prev,\n        channel_power_array=state.channel_power_array_prev,\n        modulation_format_index_array=state.modulation_format_index_array_prev,\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.undo_action_rsa","title":"<code>undo_action_rsa(state, params)</code>","text":"<p>If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation. Partial resource allocation is indicated by negative time in link slot departure array. Check for values in link_slot_departure_array that are less than zero. If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef undo_action_rsa(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation.\n    Partial resource allocation is indicated by negative time in link slot departure array.\n    Check for values in link_slot_departure_array that are less than zero.\n    If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # If departure array is negative, then undo the action\n    mask = jnp.where(state.link_slot_departure_array &lt; zero, one, zero)\n    # If link slot array is &lt; -1, then undo the action\n    # (departure might be positive because existing service had holding time after current)\n    # e.g. (time_in_array = t1 - t2) where t2 &lt; t1 and t2 = current_time + holding_time\n    # but link_slot_array = -2 due to double allocation, so undo the action\n    mask = jnp.where(state.link_slot_array &lt; -one, one, mask)\n    state = state.replace(\n        link_slot_array=jnp.where(mask == one, state.link_slot_array + one, state.link_slot_array),\n        link_slot_departure_array=jnp.where(\n            mask == one,\n            state.link_slot_departure_array + state.current_time + state.holding_time,\n            state.link_slot_departure_array),\n        total_bitrate=state.total_bitrate + read_rsa_request(state.request_array)[1][0],\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.undo_action_rsa_gn_model","title":"<code>undo_action_rsa_gn_model(state, params)</code>","text":"<p>Undo action for RSA GN model Args:     state (EnvState): Environment state     action (chex.Array): Action array     params (EnvParams): Environment parameters Returns:     EnvState: Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, static_argnums=(1,))\ndef undo_action_rsa_gn_model(state: RSAGNModelEnvState, params: RSAGNModelEnvParams) -&gt; EnvState:\n    \"\"\"Undo action for RSA GN model\n    Args:\n        state (EnvState): Environment state\n        action (chex.Array): Action array\n        params (EnvParams): Environment parameters\n    Returns:\n        EnvState: Updated environment state\n    \"\"\"\n    state = undo_action_rsa(state, params)  # Undo link_slot_array and link_slot_departure_array\n    state = state.replace(\n        link_slot_array=set_band_gaps(state.link_slot_array, params, -one),  # Set C+L band gap\n        channel_centre_bw_array=state.channel_centre_bw_array_prev,\n        path_index_array=state.path_index_array_prev,\n        channel_power_array=state.channel_power_array_prev,\n    )\n    if params.monitor_active_lightpaths:\n        # If departure array is negative, then undo the action\n        mask = jnp.where(state.active_lightpaths_array_departure &lt; zero, one,  zero)\n        state = state.replace(\n            active_lightpaths_array=jnp.where(mask == one, -one, state.active_lightpaths_array),\n            active_lightpaths_array_departure=jnp.where(\n                mask == one,\n                state.active_lightpaths_array_departure + state.current_time + state.holding_time,\n                state.active_lightpaths_array_departure),\n        )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.undo_action_rwalr","title":"<code>undo_action_rwalr(state, params)</code>","text":"<p>If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation. Partial resource allocation is indicated by negative time in link slot departure array. Check for values in link_slot_departure_array that are less than zero. If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef undo_action_rwalr(state: EnvState, params: Optional[EnvParams]) -&gt; EnvState:\n    \"\"\"If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation.\n    Partial resource allocation is indicated by negative time in link slot departure array.\n    Check for values in link_slot_departure_array that are less than zero.\n    If found, increase link_slot_array by +1 and link_slot_departure_array by current_time + holding_time of current request.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # If departure array is negative, then undo the action\n    mask = jnp.where(state.link_slot_departure_array &lt; zero, one, zero)\n    # If link slot array is &lt; -1, then undo the action\n    # (departure might be positive because existing service had holding time after current)\n    # e.g. (time_in_array = t1 - t2) where t2 &lt; t1 and t2 = current_time + holding_time\n    # but link_slot_array = -2 due to double allocation, so undo the action\n    mask = jnp.where(state.link_slot_array &lt; -one, one, mask)\n    state = state.replace(\n        link_slot_array=jnp.where(mask == one, state.link_slot_array + one, state.link_slot_array),\n        link_slot_departure_array=jnp.where(\n            mask == one,\n            state.link_slot_departure_array + state.current_time + state.holding_time,\n            state.link_slot_departure_array),\n        total_bitrate=state.total_bitrate + read_rsa_request(state.request_array)[1][0]\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.undo_node_action","title":"<code>undo_node_action(state)</code>","text":"<p>If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation. Partial resource allocation is indicated by negative time in node departure array. Check for values in node_departure_array that are less than zero. If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase node_capacity_array by expired resources on each node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>EnvState</code> <p>Environment state</p> required <p>Returns:</p> Type Description <code>EnvState</code> <p>Updated environment state</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@partial(jax.jit, donate_argnums=(0,))\ndef undo_node_action(state: EnvState) -&gt; EnvState:\n    \"\"\"If the request is unsuccessful i.e. checks fail, then remove the partial (unfinalised) resource allocation.\n    Partial resource allocation is indicated by negative time in node departure array.\n    Check for values in node_departure_array that are less than zero.\n    If found, set to infinity in node_departure_array, set to zero in node_resource_array, and increase\n    node_capacity_array by expired resources on each node.\n\n    Args:\n        state: Environment state\n\n    Returns:\n        Updated environment state\n    \"\"\"\n    # TODO - Check that node resource clash doesn't happen (so time is always negative after implementation)\n    #  and undoing always succeeds with negative time\n    mask = jnp.where(state.node_departure_array &lt; 0, 1, 0)\n    resources = jnp.sum(jnp.where(mask == 1, state.node_resource_array, 0), axis=1, promote_integers=False)\n    state = state.replace(\n        node_capacity_array=state.node_capacity_array + resources,\n        node_resource_array=jnp.where(mask == 1, 0, state.node_resource_array),\n        node_departure_array=jnp.where(mask == 1, jnp.inf, state.node_departure_array),\n    )\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.update_action_history","title":"<code>update_action_history(action_history, action_counter, action)</code>","text":"<p>Update action history by adding action to first available index starting from the end.</p> <p>Parameters:</p> Name Type Description Default <code>action_history</code> <code>Array</code> <p>Action history</p> required <code>action_counter</code> <code>Array</code> <p>Action counter</p> required <code>action</code> <code>Array</code> <p>Action to add to history</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated action_history</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_action_history(action_history: chex.Array, action_counter: chex.Array, action: chex.Array) -&gt; chex.Array:\n    \"\"\"Update action history by adding action to first available index starting from the end.\n\n    Args:\n        action_history: Action history\n        action_counter: Action counter\n        action: Action to add to history\n\n    Returns:\n        Updated action_history\n    \"\"\"\n    return jax.lax.dynamic_update_slice(action_history, jnp.flip(action, axis=0).astype(MED_INT_DTYPE), ((action_counter[-1]-1)*2,))\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.update_active_lightpaths_array","title":"<code>update_active_lightpaths_array(state, path_index, initial_slot_index, num_slots)</code>","text":"<p>Update active lightpaths array with new path index. Find the first index of the array with value -1 and replace with path index. Args:     state (RSAGNModelEnvState): Environment state     path_index (int): Path index to add to active lightpaths array Returns:     jnp.array: Updated active lightpaths array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_active_lightpaths_array(state: RSAGNModelEnvState, path_index: int, initial_slot_index: int, num_slots: int) -&gt; chex.Array:\n    \"\"\"Update active lightpaths array with new path index.\n    Find the first index of the array with value -1 and replace with path index.\n    Args:\n        state (RSAGNModelEnvState): Environment state\n        path_index (int): Path index to add to active lightpaths array\n    Returns:\n        jnp.array: Updated active lightpaths array\n    \"\"\"\n    first_empty_index = jnp.argmin(state.active_lightpaths_array[:, 0])  # Just look at the first column\n    return jax.lax.dynamic_update_slice(state.active_lightpaths_array, jnp.array([[path_index, initial_slot_index, num_slots[0]]]), (first_empty_index, 0))\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.update_active_lightpaths_array_departure","title":"<code>update_active_lightpaths_array_departure(state, time)</code>","text":"<p>Update active lightpaths array with new path index. Find the first index of the array with value -1 and replace with path index. Args:     state (RSAGNModelEnvState): Environment state     time (float): Departure time Returns:     jnp.array: Updated active lightpaths array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_active_lightpaths_array_departure(state: RSAGNModelEnvState, time: float) -&gt; chex.Array:\n    \"\"\"Update active lightpaths array with new path index.\n    Find the first index of the array with value -1 and replace with path index.\n    Args:\n        state (RSAGNModelEnvState): Environment state\n        time (float): Departure time\n    Returns:\n        jnp.array: Updated active lightpaths array\n    \"\"\"\n    first_empty_index = jnp.argmin(state.active_lightpaths_array[:, 0])  # Just look at the first column\n    return jax.lax.dynamic_update_slice(state.active_lightpaths_array_departure, jnp.stack((time, time, time)), (first_empty_index, 0))\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.update_graph_tuple","title":"<code>update_graph_tuple(state, params)</code>","text":"<p>Update graph tuple for use with Jraph GNNs. Edge and node features are updated from link_slot_array and node_capacity_array respectively. Global features are updated as request_array. Args:     state (EnvState): Environment state     params (EnvParams): Environment parameters Returns:     state (EnvState): Environment state with updated graph tuple</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_graph_tuple(state: EnvState, params: EnvParams):\n    \"\"\"Update graph tuple for use with Jraph GNNs.\n    Edge and node features are updated from link_slot_array and node_capacity_array respectively.\n    Global features are updated as request_array.\n    Args:\n        state (EnvState): Environment state\n        params (EnvParams): Environment parameters\n    Returns:\n        state (EnvState): Environment state with updated graph tuple\n    \"\"\"\n    # Get source and dest from request array\n    source_dest, datarate = read_rsa_request(state.request_array)\n    source, dest = source_dest[0], source_dest[2]\n    # Global feature is normalised data rate of current request\n    globals = jnp.array([datarate / jnp.max(params.values_bw.val)], dtype=LARGE_FLOAT_DTYPE)\n    # One-hot encode source and destination\n    source_dest_features = jnp.zeros((params.num_nodes, 2), dtype=LARGE_FLOAT_DTYPE)\n    source_dest_features = source_dest_features.at[source.astype(MED_INT_DTYPE), 0].set(1)\n    source_dest_features = source_dest_features.at[dest.astype(MED_INT_DTYPE), 1].set(-1)\n    spectral_features = state.graph.nodes[..., :3]\n    holding_time_edge_features = state.link_slot_departure_array / params.mean_service_holding_time\n\n    if params.__class__.__name__ in [\"RSAGNModelEnvParams\", \"RMSAGNModelEnvParams\"]:\n        # Normalize by max parameters (converted to linear units)\n        max_power = isrs_gn_model.from_dbm(params.max_power)\n        normalized_power = jnp.round(state.channel_power_array / max_power, 3)\n        max_snr = isrs_gn_model.from_db(params.max_snr)\n        normalized_snr = jnp.round(state.link_snr_array / max_snr, 3)\n        edge_features = jnp.stack([normalized_snr, normalized_power], axis=-1)\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n    elif params.__class__.__name__ == \"VONEEnvParams\":\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        node_features = getattr(state, \"node_capacity_array\", jnp.zeros(params.num_nodes))\n        node_features = node_features.reshape(-1, 1)\n        node_features = jnp.concatenate([node_features, spectral_features, source_dest_features], axis=-1)\n    else:\n        edge_features = state.link_slot_array if params.mean_service_holding_time &gt; 1e5 else holding_time_edge_features\n        node_features = jnp.concatenate([spectral_features, source_dest_features], axis=-1)\n\n    if params.disable_node_features:\n        node_features = jnp.zeros((1,), dtype=LARGE_FLOAT_DTYPE)\n\n    edge_features = edge_features if params.directed_graph else jnp.repeat(edge_features, 2, axis=0)\n    graph = state.graph._replace(nodes=node_features, edges=edge_features, globals=globals)\n    state = state.replace(graph=graph)\n    return state\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.update_node_array","title":"<code>update_node_array(node_indices, array, node, request)</code>","text":"<p>Used to udated selected_nodes array with new requested resources on each node, for use in</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>def update_node_array(node_indices, array, node, request):\n    \"\"\"Used to udated selected_nodes array with new requested resources on each node, for use in \"\"\"\n    return jnp.where(node_indices == node, array-request, array)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.vmap_set_path_links","title":"<code>vmap_set_path_links(link_slot_array, path, initial_slot, num_slots, value)</code>","text":"<p>Set relevant slots along links in path to val.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>path</code> <code>Array</code> <p>Path (row from path-link array that indicates links used by path)</p> required <code>initial_slot</code> <code>int</code> <p>Initial slot</p> required <code>num_slots</code> <code>int</code> <p>Number of slots</p> required <code>value</code> <code>int</code> <p>Value to set on link slot array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated link slot array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_set_path_links(link_slot_array: chex.Array, path: chex.Array, initial_slot: int, num_slots: int, value: int) -&gt; chex.Array:\n    \"\"\"Set relevant slots along links in path to val.\n\n    Args:\n        link_slot_array: Link slot array\n        path: Path (row from path-link array that indicates links used by path)\n        initial_slot: Initial slot\n        num_slots: Number of slots\n        value: Value to set on link slot array\n\n    Returns:\n        Updated link slot array\n    \"\"\"\n    return jax.vmap(set_path, in_axes=(0, 0, None, None, None))(link_slot_array, path, initial_slot, num_slots, value)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.vmap_update_node_departure","title":"<code>vmap_update_node_departure(node_departure_array, selected_nodes, value)</code>","text":"<p>Called when implementing node action. Sets request departure time (\"value\") in place of first \"inf\" i.e. unoccupied index on node departure array for selected nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_departure_array</code> <code>Array</code> <p>(N x R) Node departure array</p> required <code>selected_nodes</code> <code>Array</code> <p>(N x 1) Selected nodes (non-zero value on selected node indices)</p> required <code>value</code> <code>int</code> <p>Value to set on node departure array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated node departure array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_update_node_departure(node_departure_array: chex.Array, selected_nodes: chex.Array, value: int) -&gt; chex.Array:\n    \"\"\"Called when implementing node action.\n    Sets request departure time (\"value\") in place of first \"inf\" i.e. unoccupied index on node departure array for selected nodes.\n\n    Args:\n        node_departure_array: (N x R) Node departure array\n        selected_nodes: (N x 1) Selected nodes (non-zero value on selected node indices)\n        value: Value to set on node departure array\n\n    Returns:\n        Updated node departure array\n    \"\"\"\n    first_inf_indices = jnp.argmax(node_departure_array, axis=1).astype(MED_INT_DTYPE)\n    return jax.vmap(update_selected_node_departure, in_axes=(0, 0, 0, None))(node_departure_array, selected_nodes, first_inf_indices, value)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.vmap_update_node_resources","title":"<code>vmap_update_node_resources(node_resource_array, selected_nodes)</code>","text":"<p>Called when implementing node action. Sets requested node resources on selected nodes in place of first \"zero\" i.e. unoccupied index on node resource array for selected nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_resource_array</code> <p>(N x R) Node resource array</p> required <code>selected_nodes</code> <p>(N x 1) Requested resources on selected nodes</p> required <p>Returns:</p> Type Description <p>Updated node resource array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_update_node_resources(node_resource_array, selected_nodes):\n    \"\"\"Called when implementing node action.\n    Sets requested node resources on selected nodes in place of first \"zero\" i.e.\n    unoccupied index on node resource array for selected nodes.\n\n    Args:\n        node_resource_array: (N x R) Node resource array\n        selected_nodes: (N x 1) Requested resources on selected nodes\n\n    Returns:\n        Updated node resource array\n    \"\"\"\n    first_zero_indices = jnp.argmin(node_resource_array, axis=1)\n    return jax.vmap(update_selected_node_resources, in_axes=(0, 0, 0))(node_resource_array, selected_nodes, first_zero_indices)\n</code></pre>"},{"location":"reference/#xlron.heuristics.heuristics.vmap_update_path_links","title":"<code>vmap_update_path_links(link_slot_array, path, initial_slot, num_slots, value)</code>","text":"<p>Update relevant slots along links in path to current_val - val.</p> <p>Parameters:</p> Name Type Description Default <code>link_slot_array</code> <code>Array</code> <p>Link slot array</p> required <code>path</code> <code>Array</code> <p>Path (row from path-link array that indicates links used by path)</p> required <code>initial_slot</code> <code>int</code> <p>Initial slot</p> required <code>num_slots</code> <code>int</code> <p>Number of slots</p> required <code>value</code> <code>int</code> <p>Value to subtract from link slot array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>Updated link slot array</p> Source code in <code>xlron/environments/env_funcs.py</code> <pre><code>@jax.jit\ndef vmap_update_path_links(link_slot_array: chex.Array, path: chex.Array, initial_slot: int, num_slots: int, value: int) -&gt; chex.Array:\n    \"\"\"Update relevant slots along links in path to current_val - val.\n\n    Args:\n        link_slot_array: Link slot array\n        path: Path (row from path-link array that indicates links used by path)\n        initial_slot: Initial slot\n        num_slots: Number of slots\n        value: Value to subtract from link slot array\n\n    Returns:\n        Updated link slot array\n    \"\"\"\n    return jax.vmap(update_path, in_axes=(0, 0, None, None, None))(link_slot_array, path, initial_slot, num_slots, value)\n</code></pre>"},{"location":"understanding_xlron/","title":"Understanding XLRON","text":"<p>This page provides an overview of the conceptual underpinnings of XLRON and descriptions of its more advanced features. It explains how it is different from other network simulators that are reliant on standard graph libraries such as networkx, and instead uses an array-based approach to represent the network state. This allows JIT-compilation using JAX, parallelisation on GPU, and consequently fast generation of state transitions and reduced training time.</p> <p>For a primer on how to begin training and evaluating agents, jump to section 5 of this document or see the quick start guide.</p>"},{"location":"understanding_xlron/#1-functional-programming-and-jax","title":"1. Functional programming and JAX","text":"<p>XLRON is built using the JAX high-performance array computing framework. JAX is designed for use with functional programs - programs which are defined by applying and composing pure functions. This functional paradigm allows JAX programs to be JIT (Just In Time)-compiled to XLA (Accelerated Linear Algebra) and run on GPU or TPU hardware.</p> <p>How does this affect XLRON? While programming in JAX has many advantages, it also imposes constraints on how to program. These constraints are necessary for JAX programs to be compiled and run on GPU/TPU/XPU. This means that the code for XLRON environments is in a different style to that of other network simulators, which are often object-oriented with standard control flow and rely on graph libraries such as networkx.</p> <p>The chief constraints that XLRON obeys to be compatible with JAX are:</p> <ul> <li>Pure functions: Functions must be pure, meaning that they have no side effects and return the same output for the same input.</li> <li>Static array shapes: Array shapes must be known at compile time and immutable. </li> <li>No Python control flow: JAX does not support Python's built-in <code>for</code> loops, and instead requires the use of <code>jax.lax.scan</code> or <code>jax.lax.fori_loop</code> for iteration. Similarly, JAX does not support Python's built-in <code>if</code> statements, and instead requires the use of <code>jax.lax.cond</code> for branching.</li> </ul> <p>The JAX documentation (https://jax.readthedocs.io/en/latest/) is excellent and provides a comprehensive guide to these constraints and how to work with them.</p>"},{"location":"understanding_xlron/#2-training-architecture-devices-learners-environments","title":"2. Training architecture: Devices, Learners, Environments","text":"<p>To use XLRON, it helps to understand the logical structure of a typical training loop and have a mental picture of how the different components interact. The diagram below shows the main components of a training loop in XLRON:</p> <p></p> <p>The upper section of the diagram details the logical components of the parallelisation scheme: DEVICE<sub>LEARN</sub>, LEARNER, DEVICE<sub>ENV</sub>, and ENV. </p> <p>When specifying a training run using XLRON, the number of learners, devices, and environments are specified using the <code>--NUM_LEARNERS</code>, <code>--NUM_DEVICES</code>, and <code>--NUM_ENVS</code> flags respectively. Each learner represents a single set of neural network parameters (i.e. the AGENT), the machinery required to train them e.g. optimiser and trajectory buffer, and the environments with which they interact. Each device represents a single accelerator device (CPU or GPU or TPU) that is used to run the learner. There can be multiple learners per device. Within a single learner are multiple parallel environments (ENV), that represent the optical network to be simulated. Each ENV is a separate instance of the environment, with its own state but fixed environment parameters that are common to the learner (see next section). A learner can have its environments spread across multiple devices or co-located on a single device. </p> <p>This parallelisation scheme offers flexibility in the degree of parallelisation and use of multiple devices, with multiple learners permitting parallel training of distinct agents with different hyperparameters and/or random seeds, for the purposes of hyperaparameter tuning or meta-learning.</p> <p>The lower section of the diagram shows the details of the training loop within a single LEARNER that comprises 1 or more parallel environments (ENV) and a single set of neural network parameters (AGENT). The agent-environment interation is shown in the central box, with the agent selecting actions based on its observations of the current state of the environment, and the environment transitioning to a new state based on the action selected and any stochastic transition dynamics (e.g. the arrival and departure times of new connection requests).</p> <p>The batch size for the update step for a single learner is  <code>NUM_DEVICES x NUM_ENVS x ROLLOUT_LENGTH</code>  where <code>ROLLOUT_LENGTH</code> is the number of steps in a trajectory before an update is performed. This batch size can then be subdivided into multiple minibatches for training the neural network parameters, however this may be less stable due to updates becoming more off-policy.</p> <p>We recommend Barto and Sutton's authoritative textbook on RL for a comprehensive introduction to the field: Reinforcement Learning: An Introduction.</p>"},{"location":"understanding_xlron/#3-environment-state-and-parameters","title":"3. Environment state and parameters","text":"<p>In order to satisfy the constraints of JAX, XLRON environments are implemented as a series of pure functions that take a <code>state</code> and <code>params</code> as input, and return an updated state as output. (Other arguments may also be passed to the functions e.g. pseudo random number generator keys). Both the state and the parameters are defined as custom dataclasses. Each of the main environments supported by XLRON (RWA, RSA, RMSA, DeepRMSA, RWALightpathReuse, VONE) has a custom state and parameters. Both state and parameters are defined as <code>flax.struct.dataclass</code> objects.</p> <p>The environment state represents the current state of our network including currently active traffic requests, occupancy of spectral slots on links, and other relevant information that can change over the course of an episode. The state is updated by the environment's <code>step()</code> transition function.</p> <p>The environment parameters represent the parameters of the environment, such as the topology of the network, the capacity of links, the number of slots on each link, and other relevant information. The parameters are fixed and do not change during the course of an episode. Parameters are specified as static arguments to functions, to indicate their values are known at compile time.</p>"},{"location":"understanding_xlron/#4-data-initialisation","title":"4. Data initialisation","text":"<p>To satisfy the constraint of static array shapes, XLRON environments are initialised with a fixed number of slots on each link, and a fixed number of resources at each node. This is done by specifying the number of slots and resources as parameters to the environment. The number of slots and resources are then used to initialise arrays of zeros to represent the occupancy of slots on links and the remaining resources at nodes. These arrays are then passed as part of the environment state.</p>"},{"location":"understanding_xlron/#41-routing-representation","title":"4.1 Routing representation","text":"<p>In order to capture the topological information of the network in array form, the k-shortest paths between each node pair on the network are calculated and the constituent links of each path are encoded as a binary array for each row of <code>path_link_array</code>. </p>"},{"location":"understanding_xlron/#42-key-data-structures","title":"4.2 Key data structures","text":"<p>We list here the key data structures used in the XLRON environments. This not an exhaustive list but gives an overview of the main data structures used.</p> <p>For <code>RSAEnv</code> (including the RMSA and RWA problems), the following data structures are used:</p> <ul> <li><code>path_link_array</code>: in <code>params</code>. Each row is a binary array </li> <li><code>link_slot_array</code>: Binary array to represent occupancy of slots on links. 0 for free, -1 for occupied.</li> <li><code>link_slot_departure_array</code>: Contains departure times of services occupying slots. Time is set as negative when service is first initialised then set to positive once checked to be valid and finalised.</li> <li><code>request_array</code>: Contains newly arrived request in format (source, datarate, destination)</li> </ul> <p>For <code>RWALightpathReuseEnv</code>, in addition to the data structures used in RSAEnv, the following data structures are used:</p> <ul> <li><code>path_index_array</code>:  Contains indices of lightpaths currently in use on slots.</li> <li><code>path_capacity_array</code>:  Contains maximum capacity of each lightpath (source-dest node pair and route)</li> <li><code>link_capacity_array</code>:  Contains remaining capacity of lightpath on each link-slot</li> </ul> <p>For <code>VONEEnv</code>, in addition to the data structures used in RSAEnv, the following data structures are used:</p> <ul> <li><code>node_capacity_array</code>:  Contains remaining capacity of each node</li> <li><code>node_resource_array</code>:  Contains remaining resources of each node</li> <li><code>node_departure_array</code>:  Contains departure times of each node</li> </ul> <p><code>DeepRMSAEnv</code> is a child class of <code>RSAEnv</code> and uses the same data structures as <code>RSAEnv</code>, with an action and observation space that is compatible with the DeepRMSA paper.</p>"},{"location":"understanding_xlron/#5-environment-transitions","title":"5. Environment transitions","text":"<p>The environment transitions are implemented as a series of pure functions that take a <code>state</code> and <code>params</code> as input, and return an updated state as output. The main functions are <code>step()</code> and <code>reset()</code>. The <code>step()</code> function is called by the agent to transition the environment from one state to the next, based on the action selected by the agent. The <code>reset()</code> function is called to reset the environment to its initial state at the start of a new episode.</p> <p>In this section we describe in detail the steps involved in the <code>step()</code> function for each environment.</p>"},{"location":"understanding_xlron/#51-implement-action","title":"5.1 Implement action","text":"<p>After an action is inferred by the agent from the observation, the action is implemented in the environment. The action is a single digit that represents the index of the path to be used for the new connection request (from 0 to k-1) and the slot to be used on each link of the path (from 0 to num_slots-1). The action is implemented by updating the <code>link_slot_array</code> and <code>link_slot_departure_array</code> arrays to reflect the new connection request. The number of frequency slot units (FSU) occupied by the connections request is determined by the required datarate and the highest available modulation format for the connection, usually determined by maximum reach from the  <code>modulation_format_array</code> in the params, but can be determined by available GSNR in more advanced environments.</p>"},{"location":"understanding_xlron/#52-check","title":"5.2 Check","text":"<p>The action is valid if the slots on the path are free and the request can be accommodated on the path, e.g. any element of the link-slot-array is = -2 (meaning two active connections occupy the same FSU), then the action is invalid. Otherwise, the action is valid. Additional checks are required for more advanced environments. RWALightpathReuseEnv requires checking that the lightpath has sufficient capacity to accommodate the request, and VONEEnv requires checking that the node has sufficient resources to accommodate the request.</p>"},{"location":"understanding_xlron/#53-finalise-undo","title":"5.3 Finalise / Undo","text":"<p>If the action is valid, the departure time array is updated to set the new request times to positive values. If the action is invalid, the departure time array has the new request times added back to the initial slots, so as to reset their values to the departure time of the already-occupying request. Same for the other relevant arrays. For more advanced environments, a copy of the previous state arrays are held in state at all times, such that the state can be reset to the previous state if the action is invalid.</p>"},{"location":"understanding_xlron/#54-reward","title":"5.4 Reward","text":"<p>The reward is calculated on the basis of the reward function, which can be customised in-code but has predefined options accessed through the <code>--reward-type</code> flag, such as:</p> <ul> <li><code>service</code>: +1 for success -1 for fail</li> <li><code>bitrate</code>: Return <code>+/-(requested bitrate / maximum requested bitrate)</code> for success/fail</li> </ul> <p>N.B. The connection request arrival and departure times are generated according to Poisson distributions described by the arrival rate and departure rates, respectively, as is common practice in the modelling of dynamic optical networks. The network load in Erlangs is the product of mean arrival rate and mean holding time, which gives the mean number of active connections on a non-blocking network.</p> <p>N.B. The return values of the <code>step()</code> and <code>reset()</code> methods differ for XLRON compared to other gym-style environments ((<code>observation</code>, <code>state</code>, <code>reward</code>, <code>done</code>, <code>info</code>) vs. (<code>observation</code>, <code>reward</code>, <code>terminated</code>, <code>truncated</code>, <code>info</code>)). To match the gym API exactly for use with other RL libraries such as stable-baselines3, use the <code>GymnaxToGymWrapper</code> from the gymnax library.</p>"},{"location":"understanding_xlron/#6-training-an-agent","title":"6. Training an agent","text":"<p>XLRON contains an implementation of Proximal Policy Optimization (PPO) as the main RL algorithm. PPO is a policy gradient method that is computationally efficient and has been used to achieve state-of-the-art results in a number of domains. It is appropriate for use in environments with stochastic environment dynamics (such as optical network resource allocation problems), since it can retain stochasticity in its policy. The PPO implementation in XLRON is based on the excellent PureJaxRL. Users can modify <code>ppo.py</code> if they want to experiment with different RL algorithms, or find many more options in the Stoix library.</p> <p>Training is done using the <code>train.py</code> script, which is a wrapper around the <code>train</code> function in <code>train.py</code>. The script takes a number of commandline arguments to specify the environment, the agent, the training hyperparameters, and other settings. The script then calls the <code>train</code> function with these arguments. See the quick start guide for example commands. For multi-device training, use the <code>train_multidevice.py</code> script.</p> <p>N.B. Evaluation runs of trained models or heuristics follow the same DEVICE-LEARNER-DEVICE-ENV structure as described in section 2. Evaluation is accessed through the training script using the flags <code>--EVAL_MODEL</code> or <code>--EVAL_HEURISTIC</code>.</p>"},{"location":"understanding_xlron/#other-topics","title":"Other topics","text":""},{"location":"understanding_xlron/#invalid-action-masking","title":"Invalid Action Masking","text":"<p>Invalid action masking is a technique used to prevent the agent from selecting invalid actions. This is particularly important in the context of optical network resource allocation problems, where the action space is large and many actions are invalid. Each XLRON environment provides a method <code>action_mask</code> to generate a mask of valid actions for a given state. This mask can be used to prevent the agent from selecting invalid actions.</p> <p>Invalid action masking is activated by using the flag <code>--ACTION_MASKING</code> when running the 'train.py' script. </p>"},{"location":"understanding_xlron/#slot-aggregation","title":"Slot aggregation","text":"<p>Slot aggregation is a technique used to reduce the action space in the context of optical network resource allocation problems. It is particularly useful for the RWA problem, where the action space is large and many actions are invalid. Each XLRON environment provides a method <code>aggregate_slots</code> to aggregate slots on links. This groups the available slots into blocks of size N. The agent then selects a block of slots as an action, and  first fit allocation is used to select the initial slot for the service within the selected block of slots.</p> <p>Slot aggregation is activated by using the flag <code>--aggregate_slots=N</code> when running the 'train.py' script.</p>"},{"location":"understanding_xlron/#weights-biases-wandb-integration","title":"Weights &amp; Biases (wandb) integration","text":"<p>Weights and Biases is a tool for experiment tracking, model management, and hyperparameter optimization. It's free for individual use and is a great way to keep track of your experiments and share them with others. To set up your account and start using it with xlron, follow the steps here: https://docs.wandb.ai/quickstart/</p> <p>Hyperparameters (e.g. learning rate, batch size, rollout length, discount factor (gamma), generalized advantage estimation (GAE) lambda factor, number of MLP layers, number of hidden units, number of parallel environments, etc.) are extremely important for the success of any deep learning model and especially for reinforcement learning, which introduces additional parameters. </p> <p>XLRON features support for wandb experiment tracking and hyperparameter sweeps. The following commandline flags, when running the 'train.py' script, will enable wandb integration:</p> <pre><code>  --[no]WANDB: Use wandb\n    (default: 'false')\n  --EXPERIMENT_NAME: Name of experiment (equivalent to run name in wandb) \n  (auto-generated based on other flags if unspecified)\n    (default: '')\n  --PROJECT: Name of project (same as experiment name if unspecified)\n    (default: '')\n  --DOWNSAMPLE_FACTOR: Downsample factor to reduce data uploaded to wandb\n    (default: '1')\n    (an integer)\n  --[no]SAVE_MODEL: Save model (will be saved to --MODEL_PATH locally and uploaded to wandb if --WANDB is True)\n    (default: 'false')\n</code></pre> <p>To run a hyperparameter sweep, you must define a sweep configuration file (e.g. <code>sweep.yaml</code>) and run the sweep using the <code>wandb sweep</code> command. We provide an example sweep configuration file here: example_sweep_config.yaml. Once you have defined your sweep configuration file, you can initialise the sweep using the following command:</p> <pre><code>wandb sweep sweep.yaml\n</code></pre> <p>W&amp;B then provides you with a sweep ID in the output of the command, which you can use to launch a sweep agent using the following command:</p> <pre><code>wandb agent &lt;SWEEP_ID&gt;\n</code></pre> <p>You can run multiple sweep agents in parallel to speed up the search for optimal hyperparameters. Each agent will run a different configuration of hyperparameters, following the \"method\" defined in your sweep configuration file, e.g. \"random\", \"grid\", or \"bayes\".</p> <p>See wandb docs for more details on launching sweeps: https://docs.wandb.ai/guides/sweeps</p>"},{"location":"understanding_xlron/#learning-rate-schedules","title":"Learning rate schedules","text":"<p>XLRON supports diverse learning rate schedules for the agent. See the flags for learning rate schedules in the commandline options section.</p>"},{"location":"understanding_xlron/#gnns-with-jraph","title":"GNNs with Jraph","text":"<p>We use the Jraph library for graph neural networks in JAX to implement the policy and/or value networks of our agent, while retaining the advantages of JIT compilation and accelerator hardware. Jraph agents are now fully implemented and accessible through the <code>--USE_GNN</code> flag. The GNN agent is a multi-layer graph neural network with message passing and aggregation layers. We also make Graph Attention Network (GAT) models available. The GNN agent is compatible with all environments. The GNN agent is implemented in <code>agents.py</code> and can be modified to experiment with different architectures. The GNN agent is trained using the same <code>train.py</code> script as a MLP agent, with the <code>--USE_GNN</code> flag enabled.</p>"}]}